<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>源码分析</title>
    <link href="/2024/10/31/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/10/31/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol><li>确定阅读目标</li><li>站在实现的思路上分析<br>如果我要去实现这个功能，应该怎么做</li><li>源码调用链分析。。。（比较难理解）</li></ol><p><img src="https://i.imgur.com/kkSIlLa.png" alt="image-20241031203815020"></p>]]></content>
    
    
    <categories>
      
      <category>醍醐灌顶</category>
      
      <category>技术篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.RPC</title>
    <link href="/2024/10/31/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.RPC/"/>
    <url>/2024/10/31/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="golang中的-RPC"><a href="#golang中的-RPC" class="headerlink" title="golang中的 RPC"></a>golang中的 RPC</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    Id    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id,omitempty&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name,omitempty&quot;`</span><br>    Phone <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;phone&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">var</span> users = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*User&#123;<br>    <span class="hljs-string">&quot;1&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;1&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xx&quot;</span>,<br>    &#125;,<br>    <span class="hljs-string">&quot;2&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;2&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xxx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-keyword">type</span> UserServer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserServer)</span></span> GetUser(req GetUserReq, resp *GetUserResp) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> u, ok := users[req.Id]; ok &#123;<br>        *resp = GetUserResp&#123;<br>            Id:    u.Id,<br>            Name:  u.Name,<br>            Phone: u.Phone,<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;未找到用户&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    userServer := <span class="hljs-built_in">new</span>(UserServer)<br>    rpc.Register(userServer)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;监听客户端连接失败&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> rpc.ServeConn(conn)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> client.Close()<br>    <span class="hljs-keyword">var</span> (<br>        req = GetUserReq&#123;<br>            Id: <span class="hljs-string">&quot;3&quot;</span>,<br>        &#125;<br>        res GetUserResp<br>    )<br>    err = client.Call(<span class="hljs-string">&quot;UserServer.GetUser&quot;</span>, req, &amp;res)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;请求异常&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    log.Println(res)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="怎么分析这一块的源码？"><a href="#怎么分析这一块的源码？" class="headerlink" title="怎么分析这一块的源码？"></a>怎么分析这一块的源码？</h3><blockquote><p>源码分析三步</p></blockquote><ol><li><p>目的</p><ol><li>客户端为啥能直接调用服务端的方法</li><li>客户端与服务端的交互的数据格式确定</li></ol></li><li><p>构思实现：</p><ol><li><p>Rpc 之间通讯的数据格式与传输参数</p></li><li><p>Rpc 之间的的通讯数据格式与传输参数</p><p>标准库是通过 json 实现的，需要考虑其他类型转换情况</p></li><li><p>接受到请求消息之后是如何运行对应服务的</p><p>​<img src="https://i.imgur.com/PTGAkaq.png" alt="image-20241031203029336"></p></li></ol></li><li><p>直接阅读源码</p></li></ol><h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><p><img src="https://i.imgur.com/cE6mxPs.png" alt="image-20241031203127867"></p>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.gRPC</title>
    <link href="/2024/10/31/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4.gRPC/"/>
    <url>/2024/10/31/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4.gRPC/</url>
    
    <content type="html"><![CDATA[<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="gRPC-介绍"><a href="#gRPC-介绍" class="headerlink" title="gRPC 介绍"></a>gRPC 介绍</h2><p>gPRC 官网（<a href="https://grpc.io/%EF%BC%89%E4%B8%8A%E7%9A%84">https://grpc.io/）上的</a> Slogan 是：A high performance, open source universal RPC framework。就是：一个高性能、开源的通用 RPC 框架。</p><p>支持多数主流语言：C#、C++、Dart、<strong>Go</strong>、Java、Kotlin、Node、Objective-C、PHP、Python、Ruby。其中 Go 支持 Windows, Linux, Mac 上的 Go 1.13+ 版本。</p><p>gRPC 是一个 Google 开源的高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一步，将设备、移动应用程序和浏览器与后端服务接。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过 <code>goctl</code> 可以一键安装 <code>protoc</code>，<code>protoc-gen-go</code>，<code>protoc-gen-go-grpc</code> 相关组件，你可以执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bsh">goctl env check --install --verbose --force<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h3><p>默认情况下，gRPC 使用 Protocol Buffers，这是 Google 用于序列化结构化数据的成熟开源机制（尽管它可以与 JSON 等其他数据格式一起使用）。</p><blockquote><p>Protocol Buffers 的文档：<a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a></p></blockquote><p>使用 Protocol Buffers 的基本步骤是</p><ol><li>使用 protocol buffers 语法定义消息，消息是用于传递的数据</li><li>使用 protocol buffers 语法定义服务，服务是 RPC 方法的集合，来使用消息</li><li>使用 Protocol Buffer编 译工具 <code>protoc</code> 来编译，生成对应语言的代码，例如 Go 的代码</li></ol><p>使用 Protocol Buffers 的第一步是在 <code>.proto</code> 文件中定义序列化的数据的结构，.proto 文件是普通的文本文件。Protocol Buffers 数据被结构化为消息，其中每条消息都是一个小的信息逻辑记录，包含一系列称为字段的 name-value 对。</p><p>除了核心内容外，<code>.proto</code> 文件还需要指定语法版本，目前主流的也是最新的 proto3 版本。在 <code>.proto</code> 文件的开头指定。</p><p>一个简单的产品信息示例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> user; <span class="hljs-comment">// 默认包名</span><br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./user&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserReq</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserResp</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">string</span> phone = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> GetUser(GetUserReq) <span class="hljs-keyword">returns</span> (GetUserResp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>protoc</code> 工具将 <code>.proto</code> 定义的消息和包含 rpc 方法的服务编译为目标语言的代码，我们选择 Go 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --go-grpc_out=. --go_out=. ./user.proto<br><span class="hljs-comment"># --go_out *.pb.go 目录</span><br><span class="hljs-comment"># --go-grpc_out *_grpc.pb.go 目录</span><br></code></pre></td></tr></table></figure><h4 id="消息类型的定义"><a href="#消息类型的定义" class="headerlink" title="消息类型的定义"></a>消息类型的定义</h4><p>以一个简单的请求消息为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先指定版本 proto3，否则编译器默认为 proto2。版本指定为文件的第一非空白、非注释行。</p><p>message 关键字用于定义消息，需要指定消息类型的名称。</p><p>消息由多个名称&#x2F;值对组成，称为字段，每个字段要指定名字和类型。string、int32 是典型的标量类型，除了标量类型 protobuf 还支持构造类型，例如枚举或其他消息类型。</p><p>应该为每个字段分配唯一的字段序号，用于在二进制编码中标识该字段。序号范围1-15会消耗1个字节的存储，16-2047 会消耗2个字节。因此应该将常用的字段分配1-15字段序号。编号全部的范围是1到2^29-1，其中19000到19999是 proto编译器保留序号，不要使用。</p><p>消息的字段分为单一和重复两种规则：</p><ul><li><p>单一 Singular，proto3 中字段的默认规则。一个消息中仅可以包含0或1个该字段，就是字段不能重复。</p></li><li><p>重复的 repeated，该规则说明此字段可以重复多次（包含0次）。重复值的顺序是保留的。</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> keywords = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>.proto</code> 文件支持 C&#x2F;C++ 风格的注释 <code>//</code> 和 <code>/* ... */</code></p><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>标量消息字段可以具有以下类型之一。该表显示了 .proto 文件中指定的类型，以及自动生成的类中的相应类型：</p><table><thead><tr><th align="left">.proto Type</th><th>说明</th><th align="left">Go Type</th></tr></thead><tbody><tr><td align="left">double</td><td></td><td align="left">float64</td></tr><tr><td align="left">float</td><td></td><td align="left">float32</td></tr><tr><td align="left">int32</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint32</td><td align="left">int32</td></tr><tr><td align="left">int64</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint64</td><td align="left">int64</td></tr><tr><td align="left">uint32</td><td>变长编码</td><td align="left">uint32</td></tr><tr><td align="left">uint64</td><td>变长编码</td><td align="left">uint64</td></tr><tr><td align="left">sint32</td><td>变长编码，带符号的 int 值。这些比常规 int32 更有效地编码负数</td><td align="left">int32</td></tr><tr><td align="left">sint64</td><td>变长编码，带符号的 int 值。这些比常规 int64 更有效地编码负数</td><td align="left">int64</td></tr><tr><td align="left">fixed32</td><td>固定4个字节，如果值通常大于 2^28，则比 uint32 更有效</td><td align="left">uint32</td></tr><tr><td align="left">fixed64</td><td>固定8个字节，如果值通常大于 2^56，则比 uint64 更有效</td><td align="left">uint64</td></tr><tr><td align="left">sfixed32</td><td>固定4个字节</td><td align="left">int32</td></tr><tr><td align="left">sfixed64</td><td>固定8个字节</td><td align="left">int64</td></tr><tr><td align="left">bool</td><td></td><td align="left">bool</td></tr><tr><td align="left">string</td><td>始终包含 UTF-8 编码或 7 位 ASCII 文本，并且长度不能超过 2^32</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td>可以包含不超过 2^32 的任意字节序列</td><td align="left">[]byte</td></tr></tbody></table><p>解析消息时，如果编码的消息不包含特定元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是基于类型的：</p><ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于布尔值，默认值为 false。</li><li>对于数字类型，默认值为零。</li><li>对于枚举，默认值是第一个定义的枚举值，必须为 0。</li><li>对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息，请参阅生成的代码指南。</li><li>重复字段的默认值为空（通常是相应语言的空列表）。</li></ul><h5 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h5><p>在定义消息类型时，您可能希望其字段之一仅具有预定义的值列表之一。例如，假设您要为每个 SearchRequest 添加一个 <code>corpus</code> 字段，其中值可以是 UNIVERSAL、WEB、IMAGES、LOCAL、NEWS、PRODUCTS 或 VIDEO。您可以通过在消息定义中添加一个枚举来非常简单地做到这一点，每个可能的值都有一个常量。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Corpus</span> &#123;<br>    UNIVERSAL = <span class="hljs-number">0</span>;<br>    WEB = <span class="hljs-number">1</span>;<br>    IMAGES = <span class="hljs-number">2</span>;<br>    LOCAL = <span class="hljs-number">3</span>;<br>    NEWS = <span class="hljs-number">4</span>;<br>    PRODUCTS = <span class="hljs-number">5</span>;<br>    VIDEO = <span class="hljs-number">6</span>;<br>  &#125;<br>  Corpus corpus = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举值列表的第一常量值必须为0，这样可以更好的处理默认值。（也为了向下兼容）</p><p>也可以为同一个枚举值分配不同的常量，称为别名。需要使用选项 <code>option allow_alias = true</code> 来启用别名设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">MyMessage1</span> &#123;<br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">EnumAllowingAlias</span> &#123;<br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    UNKNOWN = <span class="hljs-number">0</span>;<br>    STARTED = <span class="hljs-number">1</span>;<br>    RUNNING = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="保留值"><a href="#保留值" class="headerlink" title="保留值"></a>保留值</h5><p>当某些字段不再使用时，例如更新消息类型时移除了某些字段，为了防止其他人重新使用了之前的字段名或字段序号而导致逻辑混乱的问题，可以把这些不用的字段设置为保留字段，关键字 <code>reserved</code> 用来设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Foo</span> &#123;<br>  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>, <span class="hljs-number">40</span> to max;<br>  reserved <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;BAR&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，以上的序号和字段名就不能后续使用了，避免了逻辑混乱。</p><h5 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h5><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;<br>  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>  <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将不同类型的消息定义在不同的 .proto 文件中，需要时导入进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">import &quot;myproject/other_protos.proto&quot;;<br></code></pre></td></tr></table></figure><h5 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h5><p>未知字段是格式良好的 Protocol Buffer 序列化数据，表示解析器无法识别的字段。例如，当旧二进制文件用新字段解析新二进制文件发送的数据时，这些新字段将成为旧二进制文件中的未知字段。</p><p>最初，proto3 消息在解析过程中总是丢弃未知字段，但在 3.5 版本中，我们重新引入了保留未知字段以匹配 proto2 行为。在 3.5 及更高版本中，未知字段在解析期间保留并包含在序列化输出中。</p><h5 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h5><p>Any 消息类型允许您将消息用作嵌入类型，而无需定义它们的 .proto。 Any 包含作为 <code>Bytes</code> 的任意序列化消息，以及充当全局唯一标识符并解析为该消息类型的 URL。要使用 Any 类型，您需要导入 google&#x2F;protobuf&#x2F;any.proto。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/any.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ErrorStatus</span> &#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">repeated</span> google.protobuf.Any details = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Onef"><a href="#Onef" class="headerlink" title="Onef"></a>Onef</h5><p>如果您有一条包含多个字段的消息，并且最多同时设置一个字段，您可以强制执行此行为并使用 <code>oneof</code> 功能节省内存。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SampleMessage</span> &#123;<br>  <span class="hljs-keyword">oneof</span> test_oneof &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">4</span>;<br>    SubMessage sub_message = <span class="hljs-number">9</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>如果您想创建关联映射作为数据定义的一部分，protocol buffers 提供了一种方便的快捷语法：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;key_type, value_type&gt; map_field = N;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;<span class="hljs-type">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="语法指导"><a href="#语法指导" class="headerlink" title="语法指导"></a>语法指导</h4><h5 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h5><p>您可以将可选的 <code>package</code> 说明符添加到 .proto 文件中，以防止协议消息类型之间的名称冲突。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">package</span> foo.bar;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Open</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>在 GO 中，该软件包被用作 GO 软件包名称，除非您在 .proto 文件中明确提供 <code>option go_package</code>。</p><h5 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h5><p>如果您想在 RPC（远程过程调用）系统中使用您的消息类型，您可以在 .proto 文件中定义一个 RPC 服务接口，并且协议缓冲区编译器将以您选择的语言生成服务接口代码和存根。因此，例如，如果您想使用获取 SearchRequest 并返回 SearchResponse 的方法定义 RPC 服务，您可以在 .proto 文件中定义它，如下所示：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 Proto Buffers 一起使用的最直接的 RPC 系统是 gRPC：由 Google 开发的一种语言和平台中立的开源 RPC 系统。 gRPC 特别适用于协议缓冲区，并允许您使用特殊的协议缓冲区编译器插件直接从 .proto 文件生成相关的 RPC 代码。</p><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><p>.proto 文件中支持定义选项。全部的选项定义在 <code>google/protobuf/descriptor.proto</code> 中。</p><p>例如我们使用 option go_package 选项来控制生成的 go 代码所在的 package。</p><h3 id="gRPC-支持四种定义服务的方法"><a href="#gRPC-支持四种定义服务的方法" class="headerlink" title="gRPC 支持四种定义服务的方法"></a>gRPC 支持四种定义服务的方法</h3><h4 id="一元-RPC"><a href="#一元-RPC" class="headerlink" title="一元 RPC"></a>一元 RPC</h4><p>首先考虑最简单的 RPC 类型，其中客户端发送单个请求并返回单个响应。</p><ol><li>一旦客户端调用了一个存根方法，服务器就会被通知该 RPC 已被调用，其中包含该调用的客户端元数据、方法名称和指定的截止日期（如果适用）。</li><li>然后，服务器可以立即发回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。</li><li>一旦服务器收到客户端的请求消息，它就会执行任何必要的工作来创建和填充响应。然后将响应连同状态详细信息（状态代码和可选状态消息）和可选尾随元数据一起返回（如果成功）给客户端。</li><li>如果响应状态为 OK，则客户端得到响应，从而完成客户端的调用。</li></ol><blockquote><p>一元  RPC，其中客户端向服务器发送单个请求并获得单个响应，就像正常的函数调用一样</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="服务器流式-RPC"><a href="#服务器流式-RPC" class="headerlink" title="服务器流式 RPC"></a>服务器流式 RPC</h4><p>服务器流式 RPC 类似于一元 RPC，除了服务器返回消息流以响应客户端的请求。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端在拥有所有服务器消息后完成。</p><blockquote><p>服务器流式 RPC，其中客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。 gRPC 保证单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h4><p>客户端流式 RPC 类似于一元 RPC，不同之处在于客户端向服务器发送消息流而不是单个消息。服务器响应一条消息（连同其状态详细信息和可选的尾随元数据），通常但不一定是在它收到所有客户端的消息之后</p><blockquote><p>客户端流式 RPC，其中客户端写入一系列消息并将它们发送到服务器，再次使用提供的流。一旦客户端完成了消息的写入，它就会等待服务器读取它们并返回它的响应。 gRPC 再次保证了单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h4><p>在双向流式 RPC 中，调用由调用方法的客户端和接收客户端元数据、方法名称和截止日期的服务器发起。服务器可以选择发回其初始元数据或等待客户端开始流式传输消息。</p><p>客户端和服务器端流处理是特定于应用程序的。<strong>由于这两个流是独立的，客户端和服务器可以以任意顺序读写消息</strong>。例如，服务器可以等到它收到客户端的所有消息后再写入它的消息，或者服务器和客户端可以玩 “ping-pong”——服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。</p><blockquote><p>双向流式 RPC，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。保留每个流中消息的顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> BidiHello(stream HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span><br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期指的是 gRPC 客户端调用 gRPC 服务端方法的过程。区别于不同的4种服务定义，过程如下：</p><h4 id="截止日期-超时"><a href="#截止日期-超时" class="headerlink" title="截止日期&#x2F;超时"></a>截止日期&#x2F;超时</h4><p>gRPC 允许客户端指定在 RPC 因 DEADLINE_EXCEEDED 错误而终止之前，他们愿意等待 RPC 完成多长时间。在服务器端，服务器可以查询特定的 RPC 是否已超时，或者还剩多少时间来完成 RPC。指定期限或超时是特定于语言的：一些语言 API 根据超时（持续时间）工作，而一些语言 API 根据期限（固定时间点）工作，可能有也可能没有默认期限。</p><h4 id="RPC-终止"><a href="#RPC-终止" class="headerlink" title="RPC 终止"></a>RPC 终止</h4><p>在 gRPC 中，客户端和服务器都对调用是否成功做出独立的本地判断，并且它们的结论可能不匹配。这意味着，例如，您可能有一个 RPC 在服务器端成功完成（“我已经发送了所有响应！”）但在客户端失败（“响应在我的截止日期之后到达！”）。服务器也可以在客户端发送所有请求之前决定完成。</p><h4 id="取消-RPC"><a href="#取消-RPC" class="headerlink" title="取消 RPC"></a>取消 RPC</h4><p>客户端或服务器都可以随时取消 RPC。取消会立即终止 RPC，以便不再进行任何工作。</p><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><blockquote><p> http2 是 gRPC 中的关键协议</p></blockquote><h3 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP! 存在的问题"></a>HTTP! 存在的问题</h3><ul><li>低效的 TCP 利用<ul><li>连接是一次性的，不能重复使用</li></ul></li><li>臃肿的消息首部<ul><li>请求行（url、请求头、版本）</li><li>首部行</li><li>空行</li><li>实体主体</li></ul></li><li>明文传输<ul><li>可以通过加 SSL 证书，将请求转成 HTTPS</li></ul></li><li>传输效率低</li></ul><h3 id="HTP2-改进的地方"><a href="#HTP2-改进的地方" class="headerlink" title="HTP2 改进的地方"></a>HTP2 改进的地方</h3><ul><li><p>传输的改进</p><ul><li>HTTP1 中一次处理一个请求，并且不能停止解析</li><li>HTTP1 中对于服务端来说无法预判使用多少内存</li><li>HTTP1 冗余过多的 LF 分隔符</li><li>HTTP2 中tcp连接之后不会断掉<ul><li>会将一次请求分成一定数量的帧，给关键帧打上标识，然后客户端会根据这些标识组装数据</li></ul></li></ul></li><li><p>请求头优化</p><ul><li><p>HTTP1 是属于无状态的，每次都需要将所有请求头发送到服务方（ http2 在将请求头帧发送到服务后，后续的帧只会发送不同的东西）</p><p><img src="https://i.imgur.com/qqbaMCU.png" alt="image-20241031212104738"></p></li><li><p>多路复用</p><ul><li>HTTP1 连接是一次性的，打开一个网页会发起多次请求，每个请求完之后就会关闭</li><li>HTTP2 在请求过程中只会建立一次连接，后续的请求都可以通过这个连接进行发送</li></ul></li><li><p>服务端可推送</p><ul><li><p>HTTP1 不支持</p></li><li><p>HTTP2 服务端与客户端会保持长连接</p></li></ul></li></ul></li></ul><h2 id="gRPC-实战"><a href="#gRPC-实战" class="headerlink" title="gRPC 实战"></a>gRPC 实战</h2><h3 id="gRPC-的服务端连接调度实现原理分析"><a href="#gRPC-的服务端连接调度实现原理分析" class="headerlink" title="gRPC 的服务端连接调度实现原理分析"></a>gRPC 的服务端连接调度实现原理分析</h3><h4 id="自定义服务加载"><a href="#自定义服务加载" class="headerlink" title="自定义服务加载"></a>自定义服务加载</h4><p><img src="https://i.imgur.com/DW8LO8s.png" alt="image-20241031212647536"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User_ServiceDesc is the grpc.ServiceDesc for User service.</span><br><span class="hljs-comment">// It&#x27;s only intended for direct use with grpc.RegisterService,</span><br><span class="hljs-comment">// and not to be introspected or modified (even as a copy)</span><br><span class="hljs-keyword">var</span> User_ServiceDesc = grpc.ServiceDesc&#123;<br>    ServiceName: <span class="hljs-string">&quot;user.User&quot;</span>,<br>    HandlerType: (*UserServer)(<span class="hljs-literal">nil</span>),<br>    Methods: []grpc.MethodDesc&#123;<br>       &#123;<br>          MethodName: <span class="hljs-string">&quot;GetUser&quot;</span>,<br>          Handler:    _User_GetUser_Handler,<br>       &#125;,<br>    &#125;,<br>    Streams:  []grpc.StreamDesc&#123;&#125;,<br>    Metadata: <span class="hljs-string">&quot;user.proto&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">User_GetUser_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    in := <span class="hljs-built_in">new</span>(GetUserReq)<br>    <span class="hljs-keyword">if</span> err := dec(in); err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">if</span> interceptor == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, in)<br>    &#125;<br>    info := &amp;grpc.UnaryServerInfo&#123;<br>       Server:     srv,<br>       FullMethod: User_GetUser_FullMethodName,<br>    &#125;<br>    handler := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, req.(*GetUserReq))<br>    &#125;<br>    <span class="hljs-keyword">return</span> interceptor(ctx, in, info, handler)<br>&#125;<br><br><span class="hljs-comment">// RegisterService registers a service and its implementation to the gRPC</span><br><span class="hljs-comment">// server. It is called from the IDL generated code. This must be called before</span><br><span class="hljs-comment">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to</span><br><span class="hljs-comment">// ensure it implements sd.HandlerType.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> RegisterService(sd *ServiceDesc, ss any) &#123;<br>    <span class="hljs-keyword">if</span> ss != <span class="hljs-literal">nil</span> &#123;<br>       ht := reflect.TypeOf(sd.HandlerType).Elem()<br>       st := reflect.TypeOf(ss)<br>       <span class="hljs-keyword">if</span> !st.Implements(ht) &#123;<br>          logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;</span>, st, ht)<br>       &#125;<br>    &#125;<br>    s.register(sd, ss)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> register(sd *ServiceDesc, ss any) &#123;<br>    s.mu.Lock()<br>    <span class="hljs-keyword">defer</span> s.mu.Unlock()<br>    s.printf(<span class="hljs-string">&quot;RegisterService(%q)&quot;</span>, sd.ServiceName)<br>    <span class="hljs-keyword">if</span> s.serve &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    <span class="hljs-keyword">if</span> _, ok := s.services[sd.ServiceName]; ok &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    info := &amp;serviceInfo&#123;<br>       serviceImpl: ss,<br>       methods:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*MethodDesc),<br>       streams:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*StreamDesc),<br>       mdata:       sd.Metadata,<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Methods &#123;<br>       d := &amp;sd.Methods[i]<br>       info.methods[d.MethodName] = d<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Streams &#123;<br>       d := &amp;sd.Streams[i]<br>       info.streams[d.StreamName] = d<br>    &#125;<br>    s.services[sd.ServiceName] = info<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务初始化"><a href="#服务初始化" class="headerlink" title="服务初始化"></a>服务初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go">s := grpc.NewServer()<br><br><br><br><span class="hljs-comment">// NewServer creates a gRPC server which has no service registered and has not</span><br><span class="hljs-comment">// started to accept requests yet.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(opt ...ServerOption)</span></span> *Server &#123;<br>    opts := defaultServerOptions<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> globalServerOptions &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opt &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    s := &amp;Server&#123;<br>       lis:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[net.Listener]<span class="hljs-type">bool</span>),<br>       opts:     opts,<br>       conns:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[transport.ServerTransport]<span class="hljs-type">bool</span>),<br>       services: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*serviceInfo),<br>       quit:     grpcsync.NewEvent(),<br>       done:     grpcsync.NewEvent(),<br>       channelz: channelz.RegisterServer(<span class="hljs-string">&quot;&quot;</span>),<br>    &#125;<br>    chainUnaryServerInterceptors(s)<br>    chainStreamServerInterceptors(s)<br>    s.cv = sync.NewCond(&amp;s.mu)<br>    <span class="hljs-keyword">if</span> EnableTracing &#123;<br>       _, file, line, _ := runtime.Caller(<span class="hljs-number">1</span>)<br>       s.events = newTraceEventLog(<span class="hljs-string">&quot;grpc.Server&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, file, line))<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> s.opts.numServerWorkers &gt; <span class="hljs-number">0</span> &#123;<br>       s.initServerWorkers()<br>    &#125;<br><br>    channelz.Info(logger, s.channelz, <span class="hljs-string">&quot;Server created&quot;</span>)<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrInterceptor</span><span class="hljs-params">(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp any, err <span class="hljs-type">error</span>) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;err begin&quot;</span>)<br>    resp, err = handler(ctx, req)<br>    fmt.Println(<span class="hljs-string">&quot;err end&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br><br>    s := grpc.NewServer(grpc.ChainUnaryInterceptor(interceptor.LogInterceptor, interceptor.ErrInterceptor))<br>    user.RegisterUserServer(s, <span class="hljs-built_in">new</span>(UserService))<br>    log.Println(<span class="hljs-string">&quot;启动成功&quot;</span>)<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="请求监听处理"><a href="#请求监听处理" class="headerlink" title="请求监听处理"></a>请求监听处理</h4><p><img src="https://i.imgur.com/ImC3Tbc.png" alt="image-20241031212849420"></p><h3 id="go-zero"><a href="#go-zero" class="headerlink" title="go-zero"></a>go-zero</h3><blockquote><p>对 go-zero的安装不做赘述</p></blockquote><h4 id="实践-go-zero-基础功能案例（api-rpc）"><a href="#实践-go-zero-基础功能案例（api-rpc）" class="headerlink" title="实践 go-zero 基础功能案例（api&#x2F;rpc）"></a>实践 go-zero 基础功能案例（api&#x2F;rpc）</h4><ol><li><p>编写.proto文件</p></li><li><p>构建 rpc 服务</p></li><li><p>编写 api 文件</p><ol><li><p>构建 api 服务</p><ol><li><p>构建 rpc 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl rpc new user<br></code></pre></td></tr></table></figure></li><li><p>构建 api 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl api new api<br></code></pre></td></tr></table></figure></li><li><p>一般情况是编写 <code>.api</code> 文件和编写 <code>.proto</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.<br></code></pre></td></tr></table></figure></li></ol></li><li><p>服务联调</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.flag</title>
    <link href="/2024/10/31/Go%E7%B3%BB%E5%88%97/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/1.flag/"/>
    <url>/2024/10/31/Go%E7%B3%BB%E5%88%97/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/1.flag/</url>
    
    <content type="html"><![CDATA[<p>flag</p>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>每日一库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录认证篇</title>
    <link href="/2024/08/23/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%AF%87/"/>
    <url>/2024/08/23/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>Cookie</strong> 是一种在 Web 浏览器中存储数据的小文件，主要用于在用户与网站之间传递状态信息。它们使得 Web 服务器可以记住用户的状态或信息，并在后续请求中恢复这些状态。Cookies 被广泛用于各种目的，包括用户认证、会话管理、个性化设置以及跟踪用户行为等。</p><p><strong>Cookie</strong> 是由 <strong>Web</strong> 服务器通过 <strong>HTTP</strong> 响应头发送到用户浏览器的一个小的文本数据块。浏览器会将其存储在本地，当用户访问相同网站时，浏览器会将这些 <strong>Cookie</strong> 附带在请求中<code>发送回服务器</code>。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><p><strong>名称（Name）</strong>: Cookie 的标识符。</p></li><li><p><strong>值（Value）</strong>: 与名称相关联的数据。</p></li><li><p><strong>过期时间（Expires）</strong>: Cookie 的有效期，浏览器在此时间之前会保持 Cookie 的存在。如果没有设置过期时间，Cookie 是会话 Cookie，会在浏览器关闭时删除。</p></li><li><p><strong>路径（Path）</strong>: 指定 Cookie 适用的 URL 路径。</p></li><li><p><strong>域（Domain）</strong>: 指定 Cookie 可用的域名。</p></li><li><p><strong>安全标志（Secure）</strong>: 指示 Cookie 只能通过 HTTPS 协议传输。</p><ul><li><strong>HttpOnly 标志</strong>: 防止 JavaScript 访问 Cookie，以增加安全性。</li></ul></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h4><ul><li><strong>用户登录</strong>: 记录用户的登录状态，避免每次访问都要求重新登录。</li><li><strong>购物车</strong>: 在电商网站上存储购物车的内容。</li></ul><h4 id="用户个性化"><a href="#用户个性化" class="headerlink" title="用户个性化"></a>用户个性化</h4><ul><li><strong>用户设置</strong>: 记录用户的语言偏好、主题设置等个性化信息。</li><li><strong>推荐系统</strong>: 根据用户的行为历史提供个性化推荐。</li></ul><h4 id="跟踪与分析"><a href="#跟踪与分析" class="headerlink" title="跟踪与分析"></a>跟踪与分析</h4><ul><li><strong>用户行为分析</strong>: 跟踪用户在网站上的活动，以分析用户行为和网站性能。</li><li><strong>广告定向</strong>: 跟踪用户的兴趣，以展示相关的广告。</li></ul><h3 id="如何使用-Cookie"><a href="#如何使用-Cookie" class="headerlink" title="如何使用 Cookie"></a>如何使用 Cookie</h3><p>在 Go 的 <code>net/http</code> 包中，你可以通过 HTTP 请求和响应操作 Cookies。以下是一些基本操作的示例：</p><h4 id="设置-Cookie"><a href="#设置-Cookie" class="headerlink" title="设置 Cookie"></a>设置 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个新的 Cookie</span><br>    cookie := &amp;http.Cookie&#123;<br>        Name:     <span class="hljs-string">&quot;username&quot;</span>,<br>        Value:    <span class="hljs-string">&quot;john_doe&quot;</span>,<br>        Path:     <span class="hljs-string">&quot;/&quot;</span>,<br>        MaxAge:   <span class="hljs-number">3600</span>, <span class="hljs-comment">// 1 hour</span><br>        HttpOnly: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 不能被 JavaScript 访问</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置 Cookie</span><br>    http.SetCookie(w, cookie)<br><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie has been set!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/set-cookie&quot;</span>, setCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 读取 Cookie</span><br>    cookie, err := r.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err == http.ErrNoCookie &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Cookie not found&quot;</span>, http.StatusNotFound)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Error retrieving cookie&quot;</span>, http.StatusInternalServerError)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Cookie 的值</span><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie value: &quot;</span> + cookie.Value))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/read-cookie&quot;</span>, readCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个新的 Cookie，并设置过期时间</span><br>    cookie := &amp;http.Cookie&#123;<br>        Name:    <span class="hljs-string">&quot;username&quot;</span>,<br>        Value:   <span class="hljs-string">&quot;&quot;</span>,<br>        Path:    <span class="hljs-string">&quot;/&quot;</span>,<br>        Expires: time.Unix(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-comment">// 设置为过去的时间</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除 Cookie</span><br>    http.SetCookie(w, cookie)<br><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie has been deleted!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/delete-cookie&quot;</span>, deleteCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>Session（会话）</strong> 是一种在用户与 Web 应用程序之间保持状态的机制，通常用于存储和管理用户的状态信息。与 Cookie 不同，Session 数据通常存储在服务器端，而非客户端。Session 通常用来跟踪用户的会话状态、存储用户数据、处理认证和授权等</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Session 是一段时间内用户与服务器之间的交互。在用户首次访问网站时，服务器创建一个 Session，并为其分配一个唯一的标识符（通常是一个随机生成的字符串，称为 Session ID）。这个 Session ID 通常会被存储在用户的 Cookie 中，随着每次请求被发送到服务器。服务器使用这个 Session ID 来查找并检索对应的会话数据。</p><p>组成:</p><ul><li><strong>Session ID</strong>: 唯一标识用户会话的标识符。</li><li><strong>Session 数据</strong>: 与用户相关的信息，比如用户身份、偏好设置、购物车内容等。</li><li><strong>Session 存储</strong>: Session 数据的存储方式，通常可以是内存、数据库、文件系统等。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>创建 Session</strong>: 用户首次访问应用时，服务器生成一个新的 Session ID，并创建一个新的会话存储区域。</p></li><li><p><strong>存储 Session 数据</strong>: 服务器将与用户相关的数据存储在会话中。</p></li><li><p><strong>传递 Session ID</strong>: 服务器将 Session ID 发送给客户端，通常通过 Cookie。</p></li><li><p><strong>识别 Session</strong>: 客户端在后续请求中将 Session ID 发送回服务器，服务器根据 Session ID 查找相应的会话数据。</p></li><li><p><strong>更新 Session 数据</strong>: 服务器可以更新会话数据，用户的每个请求都可以修改这些数据。</p></li><li><p><strong>销毁 Session</strong>: 会话可以在用户登出、会话超时或者服务器主动清除时被销毁。</p></li></ol><h3 id="Session-的用途"><a href="#Session-的用途" class="headerlink" title="Session 的用途"></a>Session 的用途</h3><h4 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h4><ul><li><strong>登录状态管理</strong>: 记录用户的登录状态，使得用户在浏览不同页面时不需要重新登录。</li></ul><h4 id="会话数据存储"><a href="#会话数据存储" class="headerlink" title="会话数据存储"></a>会话数据存储</h4><ul><li><strong>用户设置</strong>: 存储用户的个性化设置和偏好。</li><li><strong>购物车</strong>: 在电子商务网站上存储用户的购物车内容。</li></ul><h4 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h4><ul><li><strong>表单数据</strong>: 在多步表单过程中保持用户填写的数据。</li></ul><h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h2><p>Cookie 和 Session 的关系 </p><p><strong>服务器创建和管理 Session</strong>: 服务器创建 Session，并为每个会话分配唯一的 Session ID。</p><p><strong>浏览器存储和发送 Cookie</strong>: 服务器通过 Cookie 将 Session ID 发送到浏览器，浏览器将 Cookie 随后每次请求自动发送回服务器。</p><p><strong>服务器使用 Session ID 访问 Session 数据</strong>: 服务器通过 Cookie 中的 Session ID 查找和操作对应的 Session 数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟的 session 存储 (在真实应用中，通常会使用数据库或内存缓存)</span><br><span class="hljs-keyword">var</span> sessionStore = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>    http.HandleFunc(<span class="hljs-string">&quot;/welcome&quot;</span>, welcomeHandler)<br><br>    fmt.Println(<span class="hljs-string">&quot;Server started at :8080&quot;</span>)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// 登录处理程序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 模拟用户登录并生成 Session ID</span><br>    sessionID := <span class="hljs-string">&quot;123456&quot;</span> <span class="hljs-comment">// 在真实场景下，这应该是一个随机生成的唯一 ID</span><br>    userID := <span class="hljs-string">&quot;user42&quot;</span>    <span class="hljs-comment">// 假设这是从数据库中查到的用户ID</span><br><br>    <span class="hljs-comment">// 将 Session ID 和 用户ID 存储到 sessionStore 中</span><br>    sessionStore[sessionID] = userID<br><br>    <span class="hljs-comment">// 将 Session ID 写入 Cookie</span><br>    cookie := http.Cookie&#123;<br>        Name:    <span class="hljs-string">&quot;session_id&quot;</span>,<br>        Value:   sessionID,<br>        Expires: time.Now().Add(<span class="hljs-number">24</span> * time.Hour), <span class="hljs-comment">// 设置 Cookie 有效期为24小时</span><br>    &#125;<br>    http.SetCookie(w, &amp;cookie)<br><br>    fmt.Fprintf(w, <span class="hljs-string">&quot;User logged in. Session ID set: %s\n&quot;</span>, sessionID)<br>&#125;<br><br><span class="hljs-comment">// 欢迎页面处理程序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">welcomeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 从请求中获取 Cookie</span><br>    cookie, err := r.Cookie(<span class="hljs-string">&quot;session_id&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err == http.ErrNoCookie &#123;<br>            <span class="hljs-comment">// 如果没有找到 session_id Cookie</span><br>            http.Error(w, <span class="hljs-string">&quot;Session not found&quot;</span>, http.StatusUnauthorized)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        http.Error(w, <span class="hljs-string">&quot;Internal Server Error&quot;</span>, http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Cookie 中的 Session ID 查找对应的用户</span><br>    sessionID := cookie.Value<br>    userID, exists := sessionStore[sessionID]<br>    <span class="hljs-keyword">if</span> !exists &#123;<br>        http.Error(w, <span class="hljs-string">&quot;Invalid Session ID&quot;</span>, http.StatusUnauthorized)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果 Session ID 有效，显示欢迎信息</span><br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome back, User ID: %s\n&quot;</span>, userID)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Oauth-2-0"><a href="#Oauth-2-0" class="headerlink" title="Oauth 2.0"></a>Oauth 2.0</h1><blockquote><p>着重介绍如何接入， 及授权的过程</p><p>不详细介绍安全部分</p></blockquote><h2 id="背景及使用场景"><a href="#背景及使用场景" class="headerlink" title="背景及使用场景"></a>背景及使用场景</h2><ul><li>关于授权的开放网络标准，目前的版本是2.0版</li><li><a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">https://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></li><li>Oauth2.0 主要用于授权</li><li>核心就是向第三方颁发令牌，用于访问资源</li></ul><h2 id="四种获取授权码的方式"><a href="#四种获取授权码的方式" class="headerlink" title="四种获取授权码的方式"></a>四种获取授权码的方式</h2><ul><li>授权码（authorization code）</li><li>隐藏式（implicit）</li><li>密码式（resource owner password credentials）</li><li>凭证式（client credentials）</li></ul><table><thead><tr><th>方式</th><th>适用范围</th><th>特点</th></tr></thead><tbody><tr><td>授权码</td><td>有后端的 Web 应用</td><td>最常用最安全</td></tr><tr><td>隐藏式</td><td>纯前端 Web 应用</td><td>所有步骤在浏览器完成</td></tr><tr><td>密码式</td><td>高度信任应用</td><td>直接获取到用户名和密码</td></tr><tr><td>凭证式</td><td>命令行应用</td><td></td></tr></tbody></table><h3 id="授权码-（authorization-code）"><a href="#授权码-（authorization-code）" class="headerlink" title="授权码 （authorization  code）"></a>授权码 （authorization  code）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>最常用</li><li>安全性最高</li><li>适用于那些有后端的 Web 应用</li></ul><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li><p>A网站提供一个链接，用户点击后就会跳转到 B 网站。如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">https://b.com/oauth/authorize?<br>  response<span class="hljs-emphasis">_type=code&amp;</span><br><span class="hljs-emphasis">  client_</span>id=CLIENT<span class="hljs-emphasis">_ID&amp;</span><br><span class="hljs-emphasis">  redirect_</span>uri=CALLBACK<span class="hljs-emphasis">_URL&amp;</span><br><span class="hljs-emphasis">  scope=read</span><br></code></pre></td></tr></table></figure><ul><li><code>response_type</code>: <code>code</code> 要返回授权码</li><li><code>client_id</code>: 让 B 知道是谁在请求</li><li><code>redirect_url</code>: B 接受或者拒绝请求后的跳转网址</li><li><code>scope</code>: 表示请求的授权范围</li></ul></li><li><p>用户跳转之后， B 网站会要求用户登录，然后询问是否愿意给予 A 网站授权。用户表示同意，这时 B 网站会跳会<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs md">https://a.com/callback?code=AUTHORIZATION<span class="hljs-emphasis">_CODE</span><br></code></pre></td></tr></table></figure></li><li><p>A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md">https://b.com/oauth/token?<br> client<span class="hljs-emphasis">_id=CLIENT_</span>ID&amp;<br> client<span class="hljs-emphasis">_secret=CLIENT_</span>SECRET&amp;<br> grant<span class="hljs-emphasis">_type=authorization_</span>code&amp;<br> code=AUTHORIZATION<span class="hljs-emphasis">_CODE&amp;</span><br><span class="hljs-emphasis"> redirect_</span>uri=CALLBACK<span class="hljs-emphasis">_URL</span><br></code></pre></td></tr></table></figure><ul><li><code>client_id client_secret</code>: 用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）</li><li><code>grant_type</code>: <code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码</li><li><code>code</code>: 上一步拿到的授权码</li><li><code>redirect_uri</code>: 与步骤1中的<code>redirect_uri</code>一致</li></ul></li><li><p>B 网站收到请求以后，就会颁发令牌。具体做法是发送一段 JSON 数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;read&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">100101</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span>...<span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>第三方登录<ul><li>以允许 github 第三方登录举例<ul><li>实际为需要授权访问用户信息</li></ul></li><li><a href="https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps">https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps</a></li><li>Github 只支持授权码方式</li></ul></li></ul><h3 id="用户使用流程"><a href="#用户使用流程" class="headerlink" title="用户使用流程"></a>用户使用流程</h3><ol><li>A 网站让用户跳转到 GitHub</li><li>GitHub 要求用户登录，然后询问”A 网站要求获得 xx 权限，你是否同意？”</li><li>用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码</li><li>A 网站使用授权码，向 GitHub 请求令牌</li><li>GitHub 返回令牌</li><li>A 网站使用令牌，向 GitHub 请求用户数据</li></ol><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li>应用登记<ol><li>一个应用要求 Oauth 授权，必须先到对方网站登记，让对方知道是谁在请求</li><li>提交登记之后，会返回客户端 ID 和客户端秘钥</li></ol></li><li>开发跳转部分:      </li><li>开发回调接口（上述的步骤3）<ol><li>拿着授权码访问 Github 索要 AccessToken:      </li><li>设置重定向地址，重定向至主页</li></ol></li><li>后续便可以通过 AccessToken 获取用户信息资源<ol><li>拿着 AccessToken 向 github 获取用户信息:</li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Oauth 在第三方登录例子中，仅用于获取用户信息，但不仅限于此</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;net/http&quot;</span><br><br>   <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>   <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>   <br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   cli := httpcli.New()<br>   engine := gin.Default()<br><br>   <span class="hljs-keyword">var</span> accessToken <span class="hljs-type">string</span><br><br>   engine.GET(<span class="hljs-string">&quot;/oauth/redirect&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      <span class="hljs-keyword">type</span> CodeS <span class="hljs-keyword">struct</span> &#123;<br>         Code <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;code&quot; binding:&quot;required&quot;`</span><br>      &#125;<br><br>      <span class="hljs-keyword">var</span> code CodeS<br>      <span class="hljs-keyword">if</span> err := ctx.ShouldBindQuery(&amp;code); err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">400</span>&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      req, err := request.Post(<span class="hljs-string">&quot;https://github.com/login/oauth/access_token&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;client_id&quot;</span>, <span class="hljs-string">&quot;---&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;client_secret&quot;</span>, <span class="hljs-string">&quot;---&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;code&quot;</span>, code.Code).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">type</span> AccessTokenResp <span class="hljs-keyword">struct</span> &#123;<br>         AccessToken <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;access_token&quot;`</span><br>         Scope       <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;scope&quot;`</span><br>         TokenType   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;token_type&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> accessTokenResp AccessTokenResp<br>      _, err = cli.DoDecodeJSON(req, &amp;accessTokenResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      accessToken = accessTokenResp.AccessToken<br><br>      req, err = request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessTokenResp.AccessToken).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>         Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;login&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>      _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      ctx.SetCookie(<span class="hljs-string">&quot;username&quot;</span>, userInfoResp.Name, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>      ctx.Redirect(http.StatusFound, <span class="hljs-string">&quot;http://localhost:8080/homepage&quot;</span>)<br>   &#125;)<br><br>   engine.GET(<span class="hljs-string">&quot;/homepage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      username, err := ctx.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> errors.Is(err, http.ErrNoCookie) &#123;<br>            ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;请先登录&lt;/p&gt;\n&lt;a href=\&quot;https://github.com/login/oauth/authorize?client_id=c263072748e5306ad088&amp;redirect_uri=http://localhost:8080/oauth/redirect\&quot;&gt;github 登录&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> company <span class="hljs-type">string</span><br>      <span class="hljs-keyword">if</span> accessToken != <span class="hljs-string">&quot;&quot;</span> &#123;<br>         req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessToken).<br>            Build()<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br><br>         <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">interface</span>&#123;&#125;<br>         <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>         _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         company = userInfoResp.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;company&quot;</span>].(<span class="hljs-type">string</span>)<br>      &#125;<br>      ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello %s!&lt;/p&gt;\n&lt;p&gt;Company: %s&lt;/p&gt;    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>, username, company)))<br>   &#125;)<br><br>   engine.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结合现有库"><a href="#结合现有库" class="headerlink" title="结合现有库"></a>结合现有库</h3><blockquote><p>可以帮你简化一部分工作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;context&quot;</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;net/http&quot;</span><br><br>   <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>   <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>   <span class="hljs-string">&quot;golang.org/x/oauth2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   oauthConfig := oauth2.Config&#123;<br>      ClientID:     <span class="hljs-string">&quot;---&quot;</span>,<br>      ClientSecret: <span class="hljs-string">&quot;---&quot;</span>,<br>      Endpoint: oauth2.Endpoint&#123;<br>         AuthURL:  <span class="hljs-string">&quot;https://github.com/login/oauth/authorize&quot;</span>,<br>         TokenURL: <span class="hljs-string">&quot;https://github.com/login/oauth/access_token&quot;</span>,<br>      &#125;,<br>      RedirectURL: <span class="hljs-string">&quot;http://localhost:8080/oauth/redirect&quot;</span>,<br>      Scopes:      <span class="hljs-literal">nil</span>,<br>   &#125;<br><br>   state := <span class="hljs-string">&quot;a-random-string&quot;</span><br><br>   cli := httpcli.New()<br>   engine := gin.Default()<br>   engine.GET(<span class="hljs-string">&quot;/github_login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      url := oauthConfig.AuthCodeURL(state)<br>      ctx.Redirect(http.StatusTemporaryRedirect, url)<br>   &#125;)<br><br>   <span class="hljs-keyword">var</span> accessToken <span class="hljs-type">string</span><br><br>   engine.GET(<span class="hljs-string">&quot;/oauth/redirect&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      <span class="hljs-keyword">type</span> CodeS <span class="hljs-keyword">struct</span> &#123;<br>         State <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;state&quot; binding:&quot;required&quot;`</span><br>         Code  <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;code&quot; binding:&quot;required&quot;`</span><br>      &#125;<br><br>      <span class="hljs-keyword">var</span> code CodeS<br>      <span class="hljs-keyword">if</span> err := ctx.ShouldBindQuery(&amp;code); err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">400</span>&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br><br>      token, err := oauthConfig.Exchange(context.Background(), code.Code)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br><br>      req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+token.AccessToken).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      accessToken = token.AccessToken<br>      <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>         Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;login&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>      _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      ctx.SetCookie(<span class="hljs-string">&quot;username&quot;</span>, userInfoResp.Name, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>      ctx.Redirect(http.StatusFound, <span class="hljs-string">&quot;http://localhost:8080/homepage&quot;</span>)<br>   &#125;)<br><br>   engine.GET(<span class="hljs-string">&quot;/homepage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      username, err := ctx.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> errors.Is(err, http.ErrNoCookie) &#123;<br>            ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;请先登录&lt;/p&gt;\n&lt;a href=\&quot;http://localhost:8080/github_login\&quot;&gt;github 登录&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> company <span class="hljs-type">string</span><br>      <span class="hljs-keyword">if</span> accessToken != <span class="hljs-string">&quot;&quot;</span> &#123;<br>         req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessToken).<br>            Build()<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br><br>         <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">interface</span>&#123;&#125;<br>         <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>         _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         company = userInfoResp.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;company&quot;</span>].(<span class="hljs-type">string</span>)<br>      &#125;<br>      ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello %s!&lt;/p&gt;\n&lt;p&gt;Company: %s&lt;/p&gt;    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>, username, company)))<br>   &#125;)<br><br>   engine.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Oauth2-0-和-单点登录的关系"><a href="#Oauth2-0-和-单点登录的关系" class="headerlink" title="Oauth2.0 和 单点登录的关系"></a>Oauth2.0 和 单点登录的关系</h2><ul><li>Oauth2.0 主要用于授权资源<ul><li>授权原则上不一定必须用户点击来授权</li></ul></li><li>单点登录可以利用 Oauth2.0 来实现，利用 Oauth2.0 授权用户信息资源至目标应用来实现登录，并可以获取用户信息</li><li>Oauth2.0 本身是需要用户授权，才能第三方登录（授权用户信息），但如果当前应用本身足够信任目标应用，认为在当前应用中的用户都可以直接授权用户信息到目标应用，则可以实现无缝单点登录</li></ul><h2 id="令牌和密码的区别"><a href="#令牌和密码的区别" class="headerlink" title="令牌和密码的区别"></a>令牌和密码的区别</h2><ul><li>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异<ul><li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li><li>令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</li><li>令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li></ul></li><li>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</li><li>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</li></ul>]]></content>
    
    
    <categories>
      
      <category>醍醐灌顶</category>
      
      <category>技术篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术篇</tag>
      
      <tag>Cookie</tag>
      
      <tag>Session</tag>
      
      <tag>Oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.微服务架构</title>
    <link href="/2024/07/12/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/07/12/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><h2 id="微服务架构整体感受"><a href="#微服务架构整体感受" class="headerlink" title="微服务架构整体感受"></a>微服务架构整体感受</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol><li>什么是微服务架构？</li><li>服务应该如何拆分？</li><li>微服务架构带来了哪些问题？以及如何去解决这些问题。</li></ol><h3 id="典型架构图"><a href="#典型架构图" class="headerlink" title="典型架构图"></a>典型架构图</h3><p><img src="https://i.imgur.com/JXw7vLg.png" alt="image-20240710222819833"></p><p>微服务架构知识内容：</p><ol><li>应用由多个服务构成。</li><li>服务独享自身数据。</li><li>服务会共享配置，使用配置中心来支持。</li><li>服务还会共享中间件，主要缓存、消息队列、搜索、日志等。</li><li>服务间需要通信，第一步需要找到目标服务。需要服务注册中心，提供服务注册和发现。</li><li>服务需要通信，规范通信协议，典型的协议：gRPC，RestFul API，HTTP、MQ。</li><li>应用要响应外部的请求，并将请求转发给目标服务。需要 API 网关技术。</li><li>服务请求需要被控制的管理，使用负载均衡、限流、熔断、降级等控制。</li><li>服务间数据一致性的问题，通常需要分布式事务、分布式锁、分布式 Session。</li><li>服务需要被监控、需要链路追踪、监控平台、日志分析。</li></ol><h3 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h3><ol><li>Go 核心语法，我们需要用 go 编写测试用例。</li><li>Linux 基础操作，需要的程序软件大都安装在 linux 上。</li><li>Web 相关编程技术，需要使用 http 请求响应相关操作。</li></ol><h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><h3 id="巨石架构"><a href="#巨石架构" class="headerlink" title="巨石架构"></a>巨石架构</h3><p>早期，大部分的应用程序是将全部的功能模块作为一个整体进行打包、发布、运行。这样程序会越来越大，像一块大石头一样，因此称为巨石架构（the monolithic architecture）。例如，一个商城系统可能包含：分类、商品、购物车、订单、支付、物流、评价、售后、会员、推广、商户等功能模块。那么程序的架构就是：</p><p><img src="https://i.imgur.com/6GYGacV.png" alt="image-20240710223242786"></p><p>巨石应用的劣势：</p><ul><li>更新局部，需要重新部署整体</li><li>整体发布时间过长，包括编译、发布等</li><li>回归测试周期过长</li><li>不利于新技术应用，否则需要重构整体应用</li></ul><p>巨石应用也有自己的优势，例如部署容易，整体打包，整体部署即可；IDE 友好，测试容易、监控方便。</p><h3 id="微服务架构-1"><a href="#微服务架构-1" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构（MicroServices Architecture Pattern）的目的是将大型的、复杂的、长期运行的应用程序（巨石应用）构建为一组相互配合的服务，每个服务都可以很容易得局部改良。<strong>Micro</strong> 意味着服务应该足够小，服务的大小应该从业务逻辑上衡量，而不是用代码量。符合 SRP （单一职责原则）的才叫微服务。</p><p>微服务是去中心化的分布式软件架构。微服务通常是无状态服务。</p><p>微服务架构的优势：</p><ul><li>服务可以使用不同技术栈研发</li><li>每个微服务都可以独立优化，部署或扩展</li><li>更好的故障处理和错误检测</li><li>服务复用性强</li><li>服务扩展性强</li></ul><p>单体应用拆解成大量的微服务，带来的新问题是服务间通信和一致性等问题，通常需要通过服务注册发现、服务网格、分布式锁、分布式事务来解决。</p><p>上面的应用，拆分之后：</p><p><img src="https://i.imgur.com/84ZJjjR.png" alt="image-20240710223419599"></p><h3 id="SOA-与服务"><a href="#SOA-与服务" class="headerlink" title="SOA 与服务"></a>SOA 与服务</h3><p>SOA（Service-Oriented Architecture，面向服务的架构）是一种在计算机环境中设计、开发、部署和管理离散模型的方法。在 SOA 模型中，所有的功能都被定义成了独立的服务，所有的服务通过企业服务总线(ESB, Enterprise Service Bus)或流程管理器来连接。</p><p>带有 ESB 的架构典型如下：</p><p><img src="https://i.imgur.com/8K6F5ei.png" alt="image-20240710223558517"></p><p>微服务架构与 SOA 架构最重要的区别是：</p><ul><li>微服务架构是去中心化的分布式架构</li><li>SOA 是中心化的分布式架构。</li></ul><h3 id="云原生中的微服务"><a href="#云原生中的微服务" class="headerlink" title="云原生中的微服务"></a>云原生中的微服务</h3><p>微服务是云原生技术的核心部分，在微服务架构上运行的现代云原生应用程序依赖于以下关键组件：</p><ul><li>容器化，通过将服务分成多个进程来进行有效的管理和部署，例如 Docker 类平台。</li><li>编排，用于配置、分配和管理服务的可用系统资源，例如 Kubernetes 类平台。</li><li>服务网格，通过服务代理网格进行服务间通信，连接，管理和保护微服务，例如 Istio 类平台。</li></ul><p>以上三个是微服务架构在云原生中最重要的组件，这些组件允许云原生中的应用程序在负载下扩展，甚至在故障期间也能执行。</p><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><p>微服务是化整为零、分而治之的思想。</p><p>拆分原则一览：</p><p><strong>业务拆分：</strong></p><p>业务逻辑拆分，单一职责，服务自身可治理数据库。</p><p>独立功能用例拆分，独立的二方或三方用例，通常拆分为独立服务。例如二方的账号服务和三方的支付服务。</p><p><strong>技术拆分：</strong></p><p>服务的并发性，考虑持续并发、瞬时并发，拆分服务独立。</p><p>服务处理的数据，考虑数据量、读写操作的数据、冷热数据量、边长定长数据类型，将服务拆分。</p><p>服务的安全等级，考虑服务业务、数据的安全等级、采用不同的安全策略，来进行拆分。</p><p>服务需要的资源，考虑服务需要计算、I&#x2F;O、网络、存储等资源、来进行拆分。</p><p>服务扩展性，考虑服务中技术、业务等的更新率、扩展率，进行拆分。</p><p>架构的稳定性，考虑单体服务的技术架构稳定性。</p><p>便于测试，测试可集成、可回溯。</p><p>便于监控，便于日志分析、指标监控等。</p><p><strong>项目拆分：</strong></p><p>团队（开发、测试、运维）小而美。小指的是规模，团队通常 10 人左右；美指的是团队可自治，与其他团队人员协调尽量少。</p><p>成本因素，考虑技术（学习）成本、人力成本、时间成本、设施成本，来拆分服务。</p><h3 id="AKF-扩展立方体"><a href="#AKF-扩展立方体" class="headerlink" title="AKF 扩展立方体"></a>AKF 扩展立方体</h3><p>立方体图：</p><p><img src="https://i.imgur.com/VWvqOOl.png" alt="image-20240711113639989"></p><h4 id="X-轴，克隆扩展（水平复制）"><a href="#X-轴，克隆扩展（水平复制）" class="headerlink" title="X 轴，克隆扩展（水平复制）"></a>X 轴，克隆扩展（水平复制）</h4><p>X轴，代表无差别服务和数据的克隆，也称水平扩展。它指的是，相同的服务部署多个，通过负载均衡器在多个应用间做选择。</p><p>图例：</p><p><img src="https://i.imgur.com/98Xf4y3.png" alt="image-20240711113729258"></p><h4 id="Y-轴，功能拆分扩展"><a href="#Y-轴，功能拆分扩展" class="headerlink" title="Y 轴，功能拆分扩展"></a>Y 轴，功能拆分扩展</h4><p>Y轴，代表依据资源、服务或功能进行拆分。指的是把任何特定功能的操作以及操作所需的数据资源从整体（或其他操作）中分离出来。X 轴体现的是相同功能的复制，而 Y 轴体现的是多个不同功能的组合。</p><p>如图：用户购买商品，需要浏览商品信息、购买、订单管理、支付等操作，依据功能将应用拆分为：</p><p><img src="https://i.imgur.com/lyE8H0n.png" alt="image-20240711113804383"></p><p>这种拆分，就是典型微服务架构中业务逻辑的拆分方案，每个服务负责具体的某个特定功能，整体应用由多个服务组成。</p><p>同样，若某个服务需要更多的资源，也可以采用 X 轴扩展模式，例如上图中的订单服务。</p><h4 id="Z-轴，数据拆分扩展"><a href="#Z-轴，数据拆分扩展" class="headerlink" title="Z 轴，数据拆分扩展"></a>Z 轴，数据拆分扩展</h4><p>当业务基于 X、Y 做了克隆或拆分后，数据存储的压力需要通过 Z 轴扩展解决。Z 轴扩展通常指的是数据库拆分。数据库拆分如依据地域划分、依据不同功能的表划分或将表中的记录依据主键hash（或其他分区算法）划分等。</p><p>地域：</p><p><img src="https://i.imgur.com/njoLZmv.png" alt="image-20240711113907153"></p><p>基于功能：</p><p><img src="https://i.imgur.com/7XsuXnX.png" alt="image-20240711113957121"></p><p>记录划分：</p><p><img src="https://i.imgur.com/j1C2q2p.png" alt="image-20240711114009105"></p><h4 id="原点"><a href="#原点" class="headerlink" title="原点"></a>原点</h4><p>坐标原点 (0, 0, 0) 表示应用系统的最小扩展性。</p><h3 id="SRP-单一职责原则"><a href="#SRP-单一职责原则" class="headerlink" title="SRP 单一职责原则"></a>SRP 单一职责原则</h3><p>单一职责原则，应该表达最朴素的一个原则了，顾名思义，就是一个服务负责单独的一个职责，就意味着我们的设计满足单一职责。</p><p>SRP，Single Responsibility Principle，单一职责原则来自于面向对象设计的基本原则，是这么说的：</p><blockquote><p>There should never be more than one reason for a class to change.</p></blockquote><p>映射到我们微服务其实就是：对于服务而言，应该只有一个理由引起它的变化。</p><p>也就是，一个服务的功能要单一，只做与之相关的事情，在服务的设计过程中要按照职责进行设计。如果需要更多功能呢，那么就需要更多的服务，服务彼此互不干涉。</p><p>单一职责原则在使用时，要注意粒度，也就是我们应该将单体服务的规模设计多大。如果粒度过细，会导致在开发、测试、部署上都会带来额外的负担。同样若粒度过粗，那么特定功能的更新，直接会导致整体服务更新。因此，我们在拆分服务时，除了要考虑功能性，还要考虑和预测需求的变化点、变化率，以及数据增长点、并发热点等，相互结合，设计出相对平衡的独立服务。</p><p>例如，对于商品服务，商品的品牌、标签、属性、库存等，是否需要独立设计为一个服务呢？这个需要基于我们自身的业务逻辑进行设计。这个例子中，库存通常需要独立服务设计的，因为库存在订单生成和仓库管理时，会被高频率使用。而其他功能，通常隶属于商品服务的范畴。</p><p>SRP 原则通常也会被表述为服务设计的高内聚低耦合。内聚度是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好只做一件事，高内聚就是一个类封装的很完善，每个类只完成一项任务，也就是常说的单一责任原则。   耦合度是对模块间关联程度的度量，模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系，模块间联系越多，耦合性越强，模块的独立性越差。</p><h3 id="DDD-领域设计"><a href="#DDD-领域设计" class="headerlink" title="DDD 领域设计"></a>DDD 领域设计</h3><h2 id="微服务架构需要解决的问题"><a href="#微服务架构需要解决的问题" class="headerlink" title="微服务架构需要解决的问题"></a>微服务架构需要解决的问题</h2><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><h3 id="服务间发现"><a href="#服务间发现" class="headerlink" title="服务间发现"></a>服务间发现</h3><h3 id="服务间通讯"><a href="#服务间通讯" class="headerlink" title="服务间通讯"></a>服务间通讯</h3><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="熔断和降级"><a href="#熔断和降级" class="headerlink" title="熔断和降级"></a>熔断和降级</h3>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes</title>
    <link href="/2024/05/24/k8s/"/>
    <url>/2024/05/24/k8s/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h1><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="主机准备"><a href="#主机准备" class="headerlink" title="主机准备"></a>主机准备</h4><h4 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h4><table><thead><tr><th>角色</th><th>主机名</th><th>CPU（推荐4C+）</th><th>Memorty（推荐8G+）</th><th>Disk（推荐512G）</th></tr></thead><tbody><tr><td>master</td><td>k8s-master</td><td>3C</td><td>4G</td><td>50G</td></tr><tr><td>node</td><td>k8s-node1</td><td>3C</td><td>4G</td><td>50G</td></tr><tr><td>node</td><td>k8s-node2</td><td>3C</td><td>4G</td><td>50G</td></tr></tbody></table><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>CentOS7， 内核版本5.4</p><p>查看内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -rs<br>Linux 3.10.0-1127.el7.x86_64<br></code></pre></td></tr></table></figure><h4 id="主机IP地址"><a href="#主机IP地址" class="headerlink" title="主机IP地址"></a>主机IP地址</h4><p>虚拟机使用NAT和桥接的方式</p><table><thead><tr><th>角色</th><th>主机名</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>k8s-master</td><td>192.168.50.160</td></tr><tr><td>node</td><td>k8s-node1</td><td>192.168.50.161</td></tr><tr><td>node</td><td>k8s-node2</td><td>192.168.50.162</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vi ifcfg-ens03</span><br>BOOTPROTO=<span class="hljs-string">&quot;static&quot;</span><br>ONBOOT=<span class="hljs-string">&quot;yes&quot;</span><br>IPADDR=<span class="hljs-string">&quot;192.168.50.160&quot;</span><br>PREFIX=<span class="hljs-string">&quot;24&quot;</span><br>GATEWAY=<span class="hljs-string">&quot;192.168.50.2&quot;</span><br>DNS1=<span class="hljs-string">&quot;119.29.29.29&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>可查看下<strong>注意</strong></p></blockquote><h4 id="主机名配置"><a href="#主机名配置" class="headerlink" title="主机名配置"></a>主机名配置</h4><p>三台主机都要配置各自的主机名:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># k8s-master</span><br>hostnamectl set-hostname k8s-master.hailong.com<br><span class="hljs-comment"># k8s-node1</span><br>hostnamectl set-hostname k8s-node1.hailong.com<br><span class="hljs-comment"># k8s-node2</span><br>hostnamectl set-hostname k8s-node2.hailong.com<br><span class="hljs-comment"># k8s-harbor</span><br>hostnamectl set-hostname k8s-harbor.hailong.com<br></code></pre></td></tr></table></figure><h4 id="主机名与IP地址解析"><a href="#主机名与IP地址解析" class="headerlink" title="主机名与IP地址解析"></a>主机名与IP地址解析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 每台主机都需要设置</span><br>vi /etc/hosts<br><br>192.168.50.160 k8s-master.hailong.com<br>192.168.50.161 k8s-node1.hailong.com<br>192.168.50.162 k8s-node2.hailong.com<br>192.168.50.163 k8s-harbor.hailong.com<br></code></pre></td></tr></table></figure><h4 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h4><blockquote><p>可以不操作 可安装ntpdate</p></blockquote><h4 id="关闭防火墙（开发阶段）"><a href="#关闭防火墙（开发阶段）" class="headerlink" title="关闭防火墙（开发阶段）"></a>关闭防火墙（开发阶段）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop firewalld.service<br>systemctl <span class="hljs-built_in">disable</span> firewalld.service<br></code></pre></td></tr></table></figure><h4 id="关闭SeLinux（开发阶段）"><a href="#关闭SeLinux（开发阶段）" class="headerlink" title="关闭SeLinux（开发阶段）"></a>关闭SeLinux（开发阶段）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs BASH"><span class="hljs-comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用） 相当于关闭安全策略</span><br>sudo setenforce 0<br>sudo sed -i <span class="hljs-string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config<br></code></pre></td></tr></table></figure><h4 id="内网转发及网桥过滤"><a href="#内网转发及网桥过滤" class="headerlink" title="内网转发及网桥过滤"></a>内网转发及网桥过滤</h4><p>三台主机做相同操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加载br_netfilter模块</span><br>$ modprobe br_netfilter<br><br><span class="hljs-comment"># 加载br_netfilter模块</span><br>$ modprobe br_netfilter<br><br><span class="hljs-comment"># 查看是否加载</span><br>$ lsmod | grep br_netfilter<br>br_netfilter           22256  0<br>bridge                151336  1 br_netfilter<br><br><span class="hljs-comment">#允许 iptables 检查桥接流量 官方要求</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="hljs-string">br_netfilter</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># 让上面的配置生效</span><br>sudo sysctl --system<br><br></code></pre></td></tr></table></figure><h4 id="安装ipset及ipvsadm"><a href="#安装ipset及ipvsadm" class="headerlink" title="安装ipset及ipvsadm"></a>安装ipset及ipvsadm</h4><blockquote><p> 可以不执行</p></blockquote><p>三台主机做相同操作：</p><ul><li><p>ipset，ipset 是一个基于内核的数据结构，它可以用于管理 iptables 规则。</p></li><li><p>ipvsadm，ipvsadm是LVS在应用层的管理命令，我们可以通过这个命令去管理LVS的配置。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipset，ipset 是一个基于内核的数据结构，它可以用于管理 iptables 规则。<br>ipvsadm，ipvsadm是LVS在应用层的管理命令，我们可以通过这个命令去管理LVS的配置。<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置ipvsadm模块加载方式 </span><br><span class="hljs-comment"># 添加需要加载的模块 </span><br>$ <span class="hljs-built_in">cat</span> &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;<span class="hljs-string">EOF </span><br><span class="hljs-string">#!/bin/bash </span><br><span class="hljs-string">modprobe -- ip_vs </span><br><span class="hljs-string">modprobe -- ip_vs_rr </span><br><span class="hljs-string">modprobe -- ip_vs_wrr </span><br><span class="hljs-string">modprobe -- ip_vs_sh </span><br><span class="hljs-string">modprobe -- nf_conntrack EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 授权、运行、检查是否加载</span><br>$ <span class="hljs-built_in">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules <br>$ bash /etc/sysconfig/modules/ipvs.modules<br>$ lsmod | grep -e ip_vs -e nf_conntrack<br></code></pre></td></tr></table></figure><h4 id="关闭Swap分区"><a href="#关闭Swap分区" class="headerlink" title="关闭Swap分区"></a>关闭Swap分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapoff -a  <br>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<br></code></pre></td></tr></table></figure><h4 id="附内核升级"><a href="#附内核升级" class="headerlink" title="附内核升级"></a>附内核升级</h4><blockquote><p>yum方式</p></blockquote><ol><li><p>安装新版本内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 CentOS 7 上启用 ELRepo 仓库，是一个第三方仓库，可以将内核升级到最新版本</span><br><br><span class="hljs-comment"># 1.导入该源的秘钥</span><br>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org<br><br><span class="hljs-comment"># 2.启用该源仓库</span><br>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm<br><br><span class="hljs-comment"># 3.查看有哪些内核版本可供安装（可选）</span><br><span class="hljs-comment"># ml 主线版本，相对更新更激进</span><br><span class="hljs-comment"># lt 长期支持版本，相对更稳定</span><br>yum --disablerepo=<span class="hljs-string">&quot;*&quot;</span> --enablerepo=<span class="hljs-string">&quot;elrepo-kernel&quot;</span> list available<br><br><span class="hljs-comment"># 4.安装内核，选择LT版本</span><br>yum --enablerepo=elrepo-kernel install kernel-lt<br><br></code></pre></td></tr></table></figure></li><li><p>设置GRUP默认的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 编辑grub文件</span><br>vi /etc/default/grub<br><br><span class="hljs-comment"># 设置 GRUB_DEFAULT=0</span><br>GRUB_DEFAULT=0<br><br><span class="hljs-comment"># 2. 生成引导文件</span><br>grub2-mkconfig -o /boot/grub2/grub.cfg<br><br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot <span class="hljs-comment"># 测试 </span><br><span class="hljs-built_in">uname</span> -rs<br></code></pre></td></tr></table></figure></li></ol><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><p><img src="https://i.imgur.com/8DFhA7Z.png" alt="image-20240528204523510"></p><blockquote><p>前提条件 每台服务器都需要安装docker </p><p>kubelet</p><p>kubectl</p><p>master 节点需要安装kubeadm 其余节点选择安装即可</p></blockquote><p>docker 安装参考 <a href="https://hailong-bot.github.io/2024/05/11/Docker/#2-Docker%E7%9A%84%E5%AE%89%E8%A3%85">安装Docker</a></p><blockquote><p>tips:  按照上述文档安装版本是最新版（最新版已经移除了对docker的支持）,可以使用下面的方法</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils<br><br>sudo yum-config-manager \<br>--add-repo \<br>http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br><br>yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br>yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6<br></code></pre></td></tr></table></figure><p>如果以前有docker，卸载之后安装指定版本遇到问题可以查看<a href="https://hailong-bot.github.io/2024/05/11/Docker/#2-Docker%E7%9A%84%E5%AE%89%E8%A3%85">卸载Docker并重新安装</a></p><p><strong>配置加速</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/docker<br>sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;</span>],<br>  <span class="hljs-string">&quot;exec-opts&quot;</span>: [<span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span>],<br>  <span class="hljs-string">&quot;log-driver&quot;</span>: <span class="hljs-string">&quot;json-file&quot;</span>,<br>  <span class="hljs-string">&quot;log-opts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;max-size&quot;</span>: <span class="hljs-string">&quot;100m&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span><br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="cri环境安装"><a href="#cri环境安装" class="headerlink" title="cri环境安装"></a>cri环境安装</h3><blockquote><p>所有主机操作</p></blockquote><p>获取软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /data/softs -p &amp;&amp; <span class="hljs-built_in">cd</span> /data/softs<br>wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.2/cri-dockerd-0.3.2.amd64.tgz<br><br>tar xf cri-dockerd-0.3.2.amd64.tgz<br><span class="hljs-built_in">mv</span> cri-dockerd/cri-dockerd /usr/local/bin<br><br>cri-dockerd --version<br></code></pre></td></tr></table></figure><p>定制配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &gt; /etc/systemd/system/cri-dockerd.service&lt;&lt;-<span class="hljs-string">EOF</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=CRI Interface Docker Application Container Engin</span><br><span class="hljs-string">Document=https://docs.mirantis.com</span><br><span class="hljs-string">After=network-online.target firewalld.service docker.service</span><br><span class="hljs-string">Wants=network-online.target</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Type=notify</span><br><span class="hljs-string">ExecStart=/usr/local/bin/cri-dockerd --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.9 --network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock --cri-dockerd-root-directory=/var/lib/dockershim --docker-endpoint=unix:///var/run/docker.sock --cri-dockerd-root-directory=var/lib/docker</span><br><span class="hljs-string">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="hljs-string">TimeoutSec=0</span><br><span class="hljs-string">RestartSec=2</span><br><span class="hljs-string">Restart=always</span><br><span class="hljs-string">StartLimitBurst=3</span><br><span class="hljs-string">StartLimitInterval=60s</span><br><span class="hljs-string">LimitNOFILE=infinity</span><br><span class="hljs-string">LimitNPROC=infinity</span><br><span class="hljs-string">LimitCORE=infinity</span><br><span class="hljs-string">TasksMax=infinity</span><br><span class="hljs-string">Delegate=yes</span><br><span class="hljs-string">KillMode=process</span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>定制配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &gt; /etc/systemd/system/cri-dockerd.socket &lt;&lt;-<span class="hljs-string">EOF</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=CRI Docker Socket for the API</span><br><span class="hljs-string">PartOf=cri-docker.service</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Socket]</span><br><span class="hljs-string">ListenStream=/var/run/cri-dockerd.sock</span><br><span class="hljs-string">SocketMode=0660</span><br><span class="hljs-string">SocketUser=root</span><br><span class="hljs-string">SocketGroup=docker</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=sockets.target</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl <span class="hljs-built_in">enable</span> cri-dockerd.service<br>systemctl restart cri-dockerd.service<br></code></pre></td></tr></table></figure><h3 id="harbor-仓库操作"><a href="#harbor-仓库操作" class="headerlink" title="harbor 仓库操作"></a>harbor 仓库操作</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装docker</span><br><span class="hljs-comment"># 参考上述文档即可</span><br><br><span class="hljs-comment"># 安装docker-compose</span><br>yum install -y docker-compose<br></code></pre></td></tr></table></figure><h4 id="获取软件"><a href="#获取软件" class="headerlink" title="获取软件"></a>获取软件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">下载软件<br><span class="hljs-built_in">mkdir</span> /data/&#123;softs,server&#125; -p &amp;&amp; <br>wget https://github.com/goharbor/harbor/releases/download/v2.5.3/harbor-offline-installer-v2.5.3.tgz<br><br>解压软件<br>tar -zxvf harbor-offline-installer-v2.5.3.tgz -C /data/server<br><span class="hljs-built_in">cd</span> /data/server/harbor/<br><br>加载镜像<br>docker load &lt; harbor.v2.5.3.tar.gz<br>docker images<br></code></pre></td></tr></table></figure><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> harbor.yml.tmpl harbor.yml<br><br><br><span class="hljs-comment">## 修改以下部分内容</span><br>hostname: k8s-harbor.hailong.com <span class="hljs-comment"># 设置成本机域名</span><br><br>http:<br>  port: 80<br><br><span class="hljs-comment">#https related config</span><br><span class="hljs-comment">#https:  禁用https</span><br> <span class="hljs-comment"># https port for harbor, default is 443 禁用https</span><br> <span class="hljs-comment"># port: 443</span><br> <span class="hljs-comment"># The path of cert and key files for nginx</span><br> <span class="hljs-comment"># certificate: /your/certificate/path</span><br> <span class="hljs-comment"># private_key: /your/private/key/path</span><br><br>harbor_admin_password: 123456 <span class="hljs-comment"># 密码</span><br><br><span class="hljs-comment"># The default data volume</span><br>data_volume: /data/server/harbor/data <span class="hljs-comment"># 目录不存在也可以</span><br><br></code></pre></td></tr></table></figure><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">./prepare<br>./install<br><br><span class="hljs-comment"># 停止命令</span><br>docker-compose down<br><br><span class="hljs-comment"># 查看是否安装成功</span><br>docker-compose ps<br></code></pre></td></tr></table></figure><blockquote><p>这样安装会带来一个弊端， 每次启动harbor都需要进入这个目录，我们可以创建一个服务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/harbor.service<br><br>[Unit]<br>Description=Harbor<br>After=docker.service systemd-networkd.service systemd-resolved.service<br>Requires=docker.service<br>Documentation=http://github.com/vmware/harbor<br><br>[Service]<br>Type=simple<br>Restart=on-failure<br>RestartSec=5<br><span class="hljs-comment"># 需要注意harbor的安装位置</span><br>ExecStart=/usr/bin/docker-compose --file /data/server/harbor/docker-compose.yml up<br>ExecStop=/usr/bin/docker-compose --file /data/server/harbor/docker-compose.yml down<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl start harbor<br>systmectl status harbor<br>systemctl <span class="hljs-built_in">enable</span> harbor<br></code></pre></td></tr></table></figure><h4 id="harbor仓库定制"><a href="#harbor仓库定制" class="headerlink" title="harbor仓库定制"></a>harbor仓库定制</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 浏览器访问 账号 admin 密码 123456</span><br>[ip]://8080 <br><span class="hljs-comment"># 创建账户 hailong 权限为空开的 密码设置为Chenhailong123!</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/qePG6ZG.png" alt="image-20240624215455146"></p><p>然后用新用户登录并创建项目</p><p><img src="https://i.imgur.com/DI8FZl9.png" alt="image-20240624215810085"></p><h4 id="为harbor仓库提交镜像"><a href="#为harbor仓库提交镜像" class="headerlink" title="为harbor仓库提交镜像"></a>为harbor仓库提交镜像</h4><h5 id="镜像打标签"><a href="#镜像打标签" class="headerlink" title="镜像打标签"></a>镜像打标签</h5><p>必须携带harbor的主机</p><h5 id="登录harbor"><a href="#登录harbor" class="headerlink" title="登录harbor"></a>登录harbor</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker login<br></code></pre></td></tr></table></figure><h5 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push<br></code></pre></td></tr></table></figure><h5 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录仓库</span><br>docker login k8s-harbor.hailong.com -u hailong<br>Password: <span class="hljs-comment">#Chenhailong123！</span><br><br><span class="hljs-comment"># 下载镜像</span><br>docker pull busybox<br><br><span class="hljs-comment"># 定制镜像标签</span><br>docker tag busybox k8s-harbor.hailong.com/hailong/busybox:v0.1<br>docker tag nginx:latest k8s-harbor.hailong.com/hailong/nginx:1.25.1<br><span class="hljs-comment"># 推送镜像</span><br>docker push k8s-harbor.hailong.com/hailong/busybox:v0.1<br>docker push k8s-harbor.hailong.com/hailong/nginx:1.25.1<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/T8zauQs.png" alt="image-20240624230145740"></p><p><img src="https://i.imgur.com/Eq3kMko.png" alt="image-20240624230210517"></p><blockquote><p>注意 可能出现登录不了的情况</p></blockquote><p><img src="https://i.imgur.com/VBvJoiA.png" alt="image-20240624225116251"></p><p>解决办法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /usr/lib/systemd/system/docker.service <br><span class="hljs-comment"># 在ExecStart中增加insecure-registry选项 必须是域名 如下 可以连续用多个insercure-registry</span><br><br><span class="hljs-comment"># 第二种办法 </span><br>vim /etc/docker/daemon.json <br>&#123;<span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;master.example.com:5000&quot;</span>,<span class="hljs-string">&quot;192.168.50.0/24&quot;</span>]&#125;<br><br><br>systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl restart harbor<br></code></pre></td></tr></table></figure><blockquote><p>注意 docker login的时候默认是使用https，必须设置上述的安全仓库才有办法登录</p></blockquote><p><img src="https://i.imgur.com/KQqJL8g.png" alt="image-20240624225220963"></p><h3 id="K8s集群初始化"><a href="#K8s集群初始化" class="headerlink" title="K8s集群初始化"></a>K8s集群初始化</h3><blockquote><p>步骤 软件源定制 -&gt; 安装软件 -&gt; 镜像获取 -&gt; 主节点初始 -&gt; 工作节点加入集群</p></blockquote><h4 id="软件源定制"><a href="#软件源定制" class="headerlink" title="软件源定制"></a>软件源定制</h4><p>加入软件源，使用阿里源（版本不同指定不同）</p><p><a href="https://developer.aliyun.com/mirror/kubernetes?spm=a2c6h.13651102.0.0.3e221b11d1qMI">阿里源地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="hljs-string">[kubernetes]</span><br><span class="hljs-string">name=Kubernetes</span><br><span class="hljs-string">baseurl=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.27/rpm/</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=1</span><br><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.27/rpm/repodata/repomd.xml.key</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum makecache<br><br><span class="hljs-comment"># 每个节点都安装 kubeadm只在master安装即可 此处都安装</span><br><span class="hljs-comment"># 此处安装的版本是1.27.15（当前源的最新版，后面需要切换） 安装时 若有其他版本请指定</span><br>yum install -y kubeadm kubectl kubelet<br><br><span class="hljs-comment"># kubelet 采集节点数据</span><br><span class="hljs-comment"># kubeadm 集群管理使用</span><br><span class="hljs-comment"># kubectl 管理集群资源对象环境</span><br><br>kubeadm version<br></code></pre></td></tr></table></figure><h4 id="确认基本配置"><a href="#确认基本配置" class="headerlink" title="确认基本配置"></a>确认基本配置</h4><p><strong>这里前提是需要去去habor里面创建仓库</strong></p><p><img src="https://i.imgur.com/boizmOk.png" alt="image-20240625222335528"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检查镜像文件列表</span><br>kubeadm config images list<br><br><span class="hljs-comment"># 注意只能在bash中可以这样执行</span><br><span class="hljs-comment"># 获取镜像文件</span><br>images=$(kubeadm config images list --kubernetes-version=1.27.15 | awk -F <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-string">&#x27;&#123;print $NF&#125;&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;images&#125;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br>docker pull registry.aliyuncs.com/google_containers/<span class="hljs-variable">$i</span><br>docker tag registry.aliyuncs.com/google_containers/<span class="hljs-variable">$i</span> k8s-harbor.hailong.com/google_containers/<span class="hljs-variable">$i</span><br>docker push k8s-harbor.hailong.com/google_containers/<span class="hljs-variable">$i</span><br>docker rmi registry.aliyuncs.com/google_containers/<span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h5 id="master节点初始化"><a href="#master节点初始化" class="headerlink" title="master节点初始化"></a>master节点初始化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init \<br>--kubernetes-version=1.27.15 \<br>--apiserver-advertise-address=192.168.50.160 \<br>--image-repository k8s-harbor.hailong.com/google_containers \<br>--pod-network-cidr=10.244.0.0/16 \<br>--service-cidr=10.96.0.0/16 \<br>--ignore-preflight-errors=Swap \<br>--cri-socket=unix:///var/run/cri-dockerd.sock<br><br></code></pre></td></tr></table></figure><ul><li><p>kubernetes-version k8s版本</p></li><li><p>apiserver-advertise-addres master节点ip</p></li><li><p>image-repository  镜像地址</p></li><li><p>pod-network-cidr 节点网络</p><p><img src="https://i.imgur.com/mE4jkqq.png" alt="image-20240625235206726"></p></li><li><p>service-cid 默认即可</p></li><li><p>ignore-preflight-errors 忽略错误</p></li><li><p>cri-socket 使用的什么类型的cri </p><ul><li><a href="https://v1-27.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">CRI</a></li></ul></li></ul><p>在mster节点执行上述配置之后就可以准备node节点加入集群</p><p><img src="https://i.imgur.com/NQonA2L.png" alt="image-20240626203644048"></p><h5 id="node节点加入集群"><a href="#node节点加入集群" class="headerlink" title="node节点加入集群"></a>node节点加入集群</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm <span class="hljs-built_in">join</span> 192.168.50.160:6443 --token drx7un.83lpf5s4n9487nh0 \<br>        --discovery-token-ca-cert-hash sha256:51deec9624ec82f2b2af10dad4ed5fc7111e704467d4b2e9e7153ec8af1e7973 --cri-socket=unix:///var/run/cri-dockerd.sock<br></code></pre></td></tr></table></figure><p>这里只需要在<strong>每个节点</strong>增加cri-socket属性就可以了</p><p><img src="https://i.imgur.com/qet7kvz.png" alt="image-20240626203815023"></p><blockquote><p> 注意</p></blockquote><p><strong>此时集群无法使用</strong></p><p><img src="https://i.imgur.com/jkv9FIk.png" alt="image-20240626204321370"></p><p>此时需要执行master节点使用kubeadm初始化打印的日志 [<strong>master使用</strong>]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo <span class="hljs-built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">id</span> -u):$(<span class="hljs-built_in">id</span> -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p>此时其他节点也并不是Ready状态</p><p><img src="https://i.imgur.com/C2Y5rcC.png" alt="image-20240626211320570"></p><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">配置网络</a></p><blockquote><p>根据开始配置的pod-network-cidr 来确定网络</p></blockquote><p>安装 flannel</p><ul><li><p>下载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /data/kubernetes/network/flannel &amp;&amp; <span class="hljs-built_in">cd</span> /data/kubernete<br>wget https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml<br><span class="hljs-built_in">cp</span> kube-flannel.yml kube-flannel.yml.back<br></code></pre></td></tr></table></figure></li><li><p>拉去镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep image: kube-flannel.yml<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/0gGig3M.png" alt="image-20240626213357385"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉去上述的镜像 笔者是在虚拟机中执行即使切换了阿里源也很卡，也会出现超时的情况</span><br>docker pull docker.888666222.xyz/flannel/flannel:v0.25.4 <br>docker pull docker.888666222.xyz/flannel/flannel-cni-plugin:v1.4.1-flannel1<br><br><span class="hljs-comment"># 修改名称 推送到harbor</span><br>docker tag docker.888666222.xyz/flannel/flannel:v0.25.4  k8s-harbor.hailong.com/hailong/flannel:v0.25.4<br>docker tag docker.888666222.xyz/flannel/flannel-cni-plugin:v1.4.1-flannel1 k8s-harbor.hailong.com/hailong/flannel-cni-plugin:v1.4.1-flannel1<br>docker push k8s-harbor.hailong.com/hailong/flannel:v0.25.4<br>docker push k8s-harbor.hailong.com/hailong/flannel-cni-plugin:v1.4.1-flannel1<br><br></code></pre></td></tr></table></figure></li><li><p>推送完成之后，修改kube-flannel.yml中image里面的地址</p><p><img src="https://i.imgur.com/tjclBd3.png" alt="image-20240626232106734"></p></li></ul><p><img src="https://i.imgur.com/XTVgDzo.png" alt="image-20240626232234011"></p><p><img src="https://i.imgur.com/bmRaIgQ.png" alt="image-20240626232345502"></p><ul><li><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f kube-flannel.yml<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/icluj0I.png" alt="image-20240626232632469"></p></li><li><p>注意</p><p>开机自启的服务：</p><ol><li>kubelet</li><li>cri-dockerd</li><li>docker</li></ol><p>检查已经启动的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl list-unit-files --<span class="hljs-built_in">type</span>=service | grep enabled<br><br><span class="hljs-comment"># 如果没有开机自启的服务 请增加即可</span><br>systemctl <span class="hljs-built_in">enable</span> kubelet<br></code></pre></td></tr></table></figure></li></ul><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><h3 id="应用容器解读"><a href="#应用容器解读" class="headerlink" title="应用容器解读"></a>应用容器解读</h3><p><img src="https://i.imgur.com/zEG3msn.png" alt="image-20240627224201687"></p><h3 id="应用部署实战"><a href="#应用部署实战" class="headerlink" title="应用部署实战"></a>应用部署实战</h3><h4 id="资源对象管理"><a href="#资源对象管理" class="headerlink" title="资源对象管理"></a>资源对象管理</h4><p><img src="https://i.imgur.com/oyvvGTO.png" alt="image-20240627230514989"></p><h4 id="资源对象管理实战"><a href="#资源对象管理实战" class="headerlink" title="资源对象管理实战"></a>资源对象管理实战</h4><h5 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 手工方式</span><br>kubectl run pod [名称] --image=image[地址]<br><br>docker pull nginx<br>kubectl run h-nginx --image=k8s-harbor.hailong.com/hailong/nginx:latest<br>kubectl get pod <br>kubectl describe pod h-nginx<br>kubectl logs h-nginx<br>kubectl <span class="hljs-built_in">exec</span> h-nginx -- /bin/bash<br></code></pre></td></tr></table></figure><h5 id="yaml清单方式"><a href="#yaml清单方式" class="headerlink" title="yaml清单方式"></a>yaml清单方式</h5><h2 id="搭建须知"><a href="#搭建须知" class="headerlink" title="搭建须知"></a>搭建须知</h2><p>笔者使用虚拟机，但是虚拟机IP会发生改变，因此，笔者采用双网卡的方式，也就是虚拟机采用<strong>NAT网络+桥接网卡</strong>实现，桥接网卡是为了连接SSH，NAT设置静态IP</p><p>具体操作如下：</p><ol><li><p>设置NAT网络</p><p><img src="https://i.imgur.com/zLUNgHk.png" alt="image-20240606215043833"></p></li><li><p>虚拟机设置双网卡方式</p><p><img src="https://i.imgur.com/iK9WmTa.png" alt="image-20240606215132875"></p><p><img src="https://i.imgur.com/510ylPF.png" alt="image-20240606215151935"></p></li><li><p>虚拟机IP设置</p><p><img src="https://i.imgur.com/7vpnP5A.png" alt="image-20240606215311944"></p></li><li><p>宿主机IP设置</p><p><img src="https://i.imgur.com/HKv5M81.png" alt="image-20240606215411453"></p></li><li><p>远程的时候连接桥接网卡分配的IP即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>架构</tag>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fish Shell</title>
    <link href="/2024/05/11/GNULinux%20%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%20Fish%20shell%20%E5%B9%B6%E7%BE%8E%E5%8C%96/"/>
    <url>/2024/05/11/GNULinux%20%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%20Fish%20shell%20%E5%B9%B6%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="GNU-Linux-终端下使用-Fish-shell-并美化"><a href="#GNU-Linux-终端下使用-Fish-shell-并美化" class="headerlink" title="GNU&#x2F;Linux 终端下使用 Fish shell 并美化"></a><strong>GNU&#x2F;Linux 终端下使用 Fish shell 并美化</strong></h1><h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h1><p>相信大多数开发者在使用 GNU&#x2F;Linux 的同时也免不了使用终端这个“黑框框”😃。对于绝大多数终端而言，默认的 shell 皆为<code>bash</code>。原生的 bash 看起来并不“现代化”，哦~这不免比较糟糕！<br>于是，在此基础上。开发者们通过选择其他 shell 代替 bash 以获得更佳的体验。比如：<code>zsh shell</code>，虽然原生的 zsh shell 有许多功能并不具备，但是在众多开发者的应用美化下，zsh shell 看起来很“现代化”。But 😃，虽然 zsh shell 深受开发者的喜爱，但是 zsh 整体加载性能并不是很快，同时需要依靠<code>oh-my-zsh</code>的配置才能使得 zsh 更为优雅，配置相对麻烦。<br>这就引出我们今天的主角“Fish shell”，相较于 zsh shell，<code>Fish shell</code>具有一下特点：</p><ul><li>开箱即用，内置自动提示、语法高亮、自动补全、搜索历史等功能，无需添加额外插件。</li><li>可视化的 Web 配置功能。</li><li>可以使用人机界面数据完成制表页。</li><li>具有<code>Oh-My-Fish</code> shell 框架，若 Fish shell 并不能满足您的需要，可以使用该框架进行更深入配置。</li><li>相较于<code>zsh shell</code>个更加高效的<code>prompt</code>（命令提示符）加载速度。</li></ul><p>这里，列出 <a href="https://www.slant.co/topics/16984/~linux-shells">Slant</a> 网站“What are the best Linux shells?”6 佳 shell 排名：</p><p><img src="https://i.imgur.com/1xvA0ph.png" alt="img"></p><p>了解完背景，就让我开始 Fish shell 之旅吧！</p><h1 id="二-Fish-简介及安装"><a href="#二-Fish-简介及安装" class="headerlink" title="二. Fish 简介及安装"></a>二. Fish 简介及安装</h1><p>Fish 是什么呢？</p><p>笔者先简单介绍一些什么是<code>shell</code>，为读者提供清晰地认识。</p><h2 id="（一）shell简介"><a href="#（一）shell简介" class="headerlink" title="（一）shell简介"></a>（一）shell简介</h2><p>Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。<br>实际上 Shell 是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell 有自己的编程语言用于对命令的编辑，它允许用户编写由 shell 命令组成的程序。Shell 编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的 Shell 程序与其他应用程序具有同样的效果[^1]。</p><p>常见的 shell 包括：Bash 、Korn Shell 、C Shell、Z Shell 等。</p><p>简单来说，关系图谱如下：</p><pre><code class=" mermaid">graph TD;A[用户层] --&gt; B&#123;应用层&#125;;B&#123;应用层&#125; --&gt; C[shell层];C --&gt; E[end]</code></pre><p>介绍完 shell 是什么，我们便开始进入今天的正题：“Fish shell”。</p><h2 id="（二）Fish简介"><a href="#（二）Fish简介" class="headerlink" title="（二）Fish简介"></a>（二）Fish简介</h2><p>什么是 Fish 呢？鱼 @_@ ? 。其实 Fish 的全名叫做“”friendly interactive shell”, 即友好的交互式 Shell。如其名，对比 Bash 和 Z shell(zsh) 来说，Fish 具有更加优雅的定制化策略、开箱即用的便捷。相信您一定会对 Fish 爱不释手！</p><h2 id="（三）Fish-安装"><a href="#（三）Fish-安装" class="headerlink" title="（三）Fish 安装"></a>（三）Fish 安装</h2><h4 id="1-下载及安装"><a href="#1-下载及安装" class="headerlink" title="1.下载及安装"></a>1.下载及安装</h4><p>在 Fish 官网上有详细的教程供各位读者安装在不同的 <a href="https://fishshell.com/">GNU&#x2F;Linux</a> 发行版上（当然，Fish 远不止此，还可以安装在 <a href="https://fishshell.com/">Windows</a>、<a href="https://fishshell.com/">macOS</a>、<a href="https://fishshell.com/">BSD</a> 上），由于笔者的工作环境在linux mint（基于Debian的操作系统）上，笔者仅对笔者使用的 GNU&#x2F;Linux 发行版环境做详细介绍，望海涵。</p><ul><li><p>首先我们，需要下载Fish官网提供的deb包</p><blockquote><p>我们得到的包名为“fish_3.6.1-1_amd64.deb”。</p></blockquote></li><li><p>如果读者使用的操作系统具备图形化界面，当然可以直接使用包管理器进行安装。假如仅有命令行界面，这可以使用命令：“sudo dpkg -i fish_3.6.1-1_amd64.deb”进行安装</p></li></ul><h4 id="2-应用Fish"><a href="#2-应用Fish" class="headerlink" title="2.应用Fish"></a>2.应用Fish</h4><p>由于大部分的终端默认 shell 使用的是 Bash，所以我们还需要修改当前使用的 shell 为 Fish。</p><p>笔者使用的终端模拟器为Alacritty，可以直接设置终端模拟器默认shell</p><h1 id="三-Fish的特别之处"><a href="#三-Fish的特别之处" class="headerlink" title="三. Fish的特别之处"></a>三. Fish的特别之处</h1><p>Fish 有什么特别之处？</p><p>简单易用<br>相对于需要进行大量的配置才能获得良好体验的 ZSH，Fish 原生附带有最为广泛使用的特性，比如：自动提示、语法高亮等等。同时其配置设置的语法清晰明了，通过模块化和 Web 可视化配置，能为您节省大量时间</p><ul><li><p>自动提示。</p><ul><li><p>Fish 会通过显示灰色提示，提醒您最近浏览历史，和您可能希望浏览的内容。如果命令有误，则会将命令设置为红色提醒您。</p></li><li><p>除了显示命令是否正确外，Fish 还可以显示你所搜索的目录是否存在、拼写是否正确、括号是否匹配等等。</p></li><li><p>哦~，除此之外，如果你觉得 Fish 的色彩显示并不美观，还可以自行配置美化。在 <a href="https://fishshell.com/">Fish</a> 官网有详细的教程。</p><p><img src="https://i.imgur.com/Lq6RZ7X.png" alt="图一"></p></li></ul></li><li><p>文件和命令高亮</p><ul><li>Fish 会将文件设置为绿色，目录设置为蓝色。（当然，颜色设置您也可以自行配置）、</li><li>当然，除了高亮当前目录下的文件与目录，还可以将命令高亮显示。比如输入“sudo apt”命令就会将“apt”进行高亮显示。</li></ul><p><img src="https://i.imgur.com/9HMRkGp.png" alt="img"></p></li><li><p>生成数据制表页</p><ul><li>Fish 可以解析各种格式的工具手册页，假如你不知道该命令下有什么作用，可以通过输入“Tab”键获得提示</li></ul><p><img src="https://i.imgur.com/HwDB5LI.png" alt="img"></p></li><li><p>自动补全</p><ul><li>输入命令时，Fish 会自动显示上一次使用该命令历史记录（如果还希望查看之前的历史，还可以通过按”up”向上键查看）。</li><li>假如，并没有该命令历史记录，则会显示可能使用的命令。</li><li>使用<code>Tab</code>键进行补全，假如有多种结果，则会都列出来并显示给出理由。当然，除了补全命令外，还可以补全参数以及 Git 分支，是不是很优雅 b（￣▽￣）d</li></ul></li><li><p>可视化 Web 配置页面</p><ul><li>笔者认为这绝对是 Fish 如此受欢迎的原因之一，可视化的操作为配置 Fish 提供很大的帮助。</li></ul><p><img src="https://i.imgur.com/BP2h8vN.png" alt="img"></p><blockquote><p>解释</p><blockquote><p>进入可视化界面，仅需要在Final Shell 下输入”fish_config” 命令即可</p><p>在可视化web页面下，你可以设置主题颜色（包括自定义）、提示符样式、函数、变量、查看历史命令、快捷键、设置缩写等。</p></blockquote></blockquote></li><li><p>简单配置</p><ul><li>Fish 通过函数封装命令或者起别名。同时 Fish 使用的语法也很简单，比如常见的：“if”、“switch”、“for”、“while”等</li></ul></li></ul><p>相信你一定会爱上 Fish 的！</p><h1 id="四-Fish的美化与配置"><a href="#四-Fish的美化与配置" class="headerlink" title="四.Fish的美化与配置"></a>四.Fish的美化与配置</h1><blockquote><p> 注意：<br>由于 Fish 对于笔者来说已经足够优秀了，所以笔者仅仅对 Fish 进行简单的微调和美化，如果还希望更加深入了解 Fish，可以直接在输入<code>help</code>命令，查看 Fish 的<a href="https://fishshell.com/docs/current/index.html">帮助文档</a>。请见谅。</p></blockquote><p>终于来到本文的第二个关键点了！体验完 Fish 是不是觉得很 nice？<br>假如，您觉得 Fish 还差一点味道。那么欢迎来到 Fish 的配置与美化。 😉</p><p>本节共分为三节，分别介绍：对 Fish 进行配置、oh-my-fish 使用、oh-my-posh 使用。<br>那么，开始吧！</p><h2 id="（一）对Fish进行配置"><a href="#（一）对Fish进行配置" class="headerlink" title="（一）对Fish进行配置"></a>（一）对Fish进行配置</h2><p>Fish 的配置文件位于<code>~/.config/fish/config.fish</code>。</p><p>由于，Fish 使用函数对命令进行封装。我们也可以直接在可视化 Web 页面通过编写函数实现我们想要的效果。</p><p><img src="https://i.imgur.com/HwVHHlr.png" alt="img"></p><p>在这里，我仅做一个演示，望理解。</p><h2 id="（二）使用Oh-My-Fish"><a href="#（二）使用Oh-My-Fish" class="headerlink" title="（二）使用Oh-My-Fish"></a>（二）使用Oh-My-Fish</h2><p>相信大家都听说过“Oh-My-Zsh”，对“Oh-My-Fish”可能有些陌生，其实“Oh-My-Fish”和“Oh-My-Zsh”一样都是基于对应 shell 所设计的框架，通过该框架您可以自行安装所需扩展、Shell 外观等。</p><h4 id="1-安装-Oh-My-Fish"><a href="#1-安装-Oh-My-Fish" class="headerlink" title="1.安装 Oh-My-Fish"></a>1.安装 Oh-My-Fish</h4><p>使用以下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L https://get.oh-my.fish | fish<br></code></pre></td></tr></table></figure><h4 id="2-使用Oh-MyFish进行美化"><a href="#2-使用Oh-MyFish进行美化" class="headerlink" title="2.使用Oh-MyFish进行美化"></a>2.使用Oh-MyFish进行美化</h4><p>通过使用“omf list”命令，可以查看 Fish 中已经安装的插件和主题。比如：我并未安装任何主题，则会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>$ omf list<br>Plugins<br>fish-spec       omf<br><br>Themes<br>default<br></code></pre></td></tr></table></figure><p>如果想要更改背景，则可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">omf theme<br></code></pre></td></tr></table></figure><p>查看 Oh-My-Fish 全部背景和已经安装背景。如果希望查看背景具体效果，则可以 <a href="https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md">点击这里</a></p><p>有关主题的一些命令，可以查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">omf install 主题名  <span class="hljs-comment">#安装主题</span><br><br>omf theme 主题名  <span class="hljs-comment">#更换主题</span><br><br>omf search 主题名  <span class="hljs-comment">#搜索主题</span><br><br>omf search -t 主题名  <span class="hljs-comment">#限制搜索主题，比如 omf search -t cha 便仅会搜索含有 cha 名的主题</span><br></code></pre></td></tr></table></figure><p>同样，插件的使用命令也类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">omf install  插件名  <span class="hljs-comment">#安装主题</span><br><br>omf theme 插件名  <span class="hljs-comment">#更换主题</span><br><br>omf search 插件名  <span class="hljs-comment">#搜索主题</span><br><br>omf search -p 插件名  <span class="hljs-comment">#限制搜索插件</span><br></code></pre></td></tr></table></figure><p>如果还想了解更多信息，可以查看 Oh-My-Fish 官方 <a href="https://github.com/oh-my-fish/oh-my-fish/tree/master/docs/zh-CN">README</a> 文件，也可以阅读 Linux 中国推出的 <a href="https://linux.cn/article-9515-1.html">Oh My Fish! 让你的 Shell 漂亮起来</a>。</p><h4 id="3-使用oh-my-posh美化"><a href="#3-使用oh-my-posh美化" class="headerlink" title="3.使用oh-my-posh美化"></a>3.使用oh-my-posh美化</h4><blockquote><p>注意：<br><strong>使用 oh-my-posh 需要 Fish 版本高于或等于 V3.4.0</strong><br>可以使用命令“fish –version”查看当前 Fish 版本</p></blockquote><p>oh-my-posh 是什么？用官方原话来说是：“A prompt theme engine for any shell.”，适用于任何 shell 的提示主题引擎。</p><p>如其名，oh-my-posh 对主流的 shell 都进行了配置。笔者喜欢使用 oh-my-posh 的原因便因其美丽的主题和对 Git 的良好支持。</p><p>比如，笔者现在所使用的一款主题<code>clean-detailed</code>：</p><p><img src="https://i.imgur.com/TPoRx19.png" alt="img"></p><p>除了常规的显示当前目录外，还显示 CPU 使用率、内存所占容量、命令执行时间以及最为重要的 Git 信息显示。</p><p>是不是觉得挺不错的。づ￣ 3￣) づ</p><p>就让我们开始 oh-my-posh 美化之路吧！</p><blockquote><p>注意：<br>在本次配置过程中，会进行详略讲解。如果读者并未明白某个配置过程，可以查阅「<a href="https://ohmyposh.dev/docs/installation/linux">官方文档</a>」</p></blockquote><h5 id="（1）下载oh-my-posh"><a href="#（1）下载oh-my-posh" class="headerlink" title="（1）下载oh-my-posh"></a>（1）下载oh-my-posh</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 注意：此 CPU 架构为 amd64</span><br>sudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O /usr/local/bin/oh-my-posh<br><span class="hljs-comment"># 注意：此 CPU 架构为 arm64</span><br>sudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-arm64 -O /usr/local/bin/oh-my-posh<br><span class="hljs-comment"># 注意：此 CPU 架构为 arm</span><br>sudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-arm -O /usr/local/bin/oh-my-posh<br></code></pre></td></tr></table></figure><p>并设置其权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/oh-my-posh<br></code></pre></td></tr></table></figure><blockquote><p>解释：<br>如果读者不知晓自己电脑的处理器体系结构，可以在命令行输入命令“uname -m”查看。<br>比如：笔者输出结果为“X86_64”，那么我就应该选择“amd64”。</p></blockquote><p>以上是笔者自己的做法，但其实官方提供了一个脚本，但是由于其脚本下载github源文件速度太慢所以被舍弃。</p><p>以下是官方的做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>curl -s https://ohmyposh.dev/install.sh | bash -s<br><span class="hljs-comment"># 上述是官方原本的写法，如果你不是root用户，请使用下述方式：</span><br><span class="hljs-comment"># curl -s https://ohmyposh.dev/install.sh | sudo bash -s</span><br></code></pre></td></tr></table></figure><p>默认的安装路径为：<code>/usr/local/bin/oh-my-posh</code>，可以自己设置路径，比如我希望在<code>～/bin</code>下，那么则应该写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://ohmyposh.dev/install.sh | sudo bash -s -- -d ~/bin<br></code></pre></td></tr></table></figure><p>注意，如果你安装的路径为自定义，则需要在<code>~/.config/fish/config.fish</code>下，也就是在fish的配置文件下设置oh-my-posh的PATH。</p><h5 id="（2）下载主题"><a href="#（2）下载主题" class="headerlink" title="（2）下载主题"></a>（2）下载主题</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建主题存放文件夹，读者可以根据需要自定义存放位置，</span><br><span class="hljs-comment"># 如果自定义修改位置，那么后续的命令也需要做出相应更改</span><br><span class="hljs-built_in">mkdir</span> ~/.poshthemes<br><span class="hljs-comment"># 获取主题zip文件并存放至对应主题文件夹（如果使用该命令下载zip较慢，</span><br><span class="hljs-comment"># 可以通过复制该URL使用“github文件加速下载下载”文件</span><br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zip<br><span class="hljs-comment"># 解压主题压缩包文件</span><br>unzip ~/.poshthemes/themes.zip -d ~/.poshthemes<br><span class="hljs-comment"># 将所有主题文件设置可读权限</span><br><span class="hljs-built_in">chmod</span> u+rw ~/.poshthemes/*.omp.*<br><span class="hljs-comment"># 删除主题压缩包</span><br><span class="hljs-built_in">rm</span> ~/.poshthemes/themes.zip<br></code></pre></td></tr></table></figure><h5 id="（3-安装字体"><a href="#（3-安装字体" class="headerlink" title="（3) 安装字体"></a>（3) 安装字体</h5><p>因为 oh-my-posh 的主题需要显示字体图标，所以需要使用 <a href="https://www.nerdfonts.com/font-downloads">Nerd Fonts</a>“家族”的字体。在 oh-my-posh 官方文档推荐使用 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip">Meslo LGM NF</a> 字体，但是根据笔者的经验，使用其他“Nerd Fonts”也是没有问题的。比如笔者使用的字体便是“JetBrainsMono Nerd Font”，随读者自己的爱好。</p><p>除了手动下载安装字体外，oh-my-posh 也提供在线安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo oh-my-posh font install<br></code></pre></td></tr></table></figure><p>通过移动上下键选择自己想要安装的字体即可。</p><h5 id="（4）安装主题"><a href="#（4）安装主题" class="headerlink" title="（4）安装主题"></a>（4）安装主题</h5><p>oh-my-posh 安装 Fish 也比较简单，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 注意“~/.poshthemes/jandedobbeleer.omp.json”，根据实际安装情况选择读者自己设置的 oh-my-posh 主题位置而定，在此仅作为参考。</span><br>oh-my-posh init fish --config ~/.poshthemes/jandedobbeleer.omp.json | <span class="hljs-built_in">source</span><br></code></pre></td></tr></table></figure><blockquote><p>注意</p><p>主题可以在<a href="https://ohmyposh.dev/docs/themes">官网</a>查看，当读者看到适合自己的主题时，可以暂时通过命令“oh-my-posh init fish –config ~&#x2F;.poshthemes&#x2F;看到的主题名.omp.json | source”查看使用效果，如果合适则直接将该命令添加到fish的配置文件中即可。</p></blockquote><p>重载 Fish 配置文件，那么 oh-my-posh 便成功完成美化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">. ~/.config/fish/config.fish<br></code></pre></td></tr></table></figure><p>至此，便结束 Fish 的配置与美化。</p><p>如果，读者对配置教程有不明白地方，可以阅读下方的参考文档。</p><p><strong>参考</strong></p><p><a href="https://stackoverflow.com/questions/52281264/how-to-reset-fish-shell-key-bindings">遇到的错误结局办法</a></p><p><a href="https://blog.csdn.net/duninet/article/details/107115082">Fish vs. Zsh vs. Bash 以及为什么要改用 Fish</a></p><p><a href="https://blog.csdn.net/lixinze779/article/details/81012318">Zsh 和 Bash 究竟有何不同</a></p><p><a href="https://www.ruanyifeng.com/blog/2017/05/fish_shell.html">Fish shell 入门教程</a></p><p><a href="https://linux.cn/article-9515-1.html">Oh My Fish! 让你的 Shell 漂亮起来</a></p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Fish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.微服务概览</title>
    <link href="/2024/05/11/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/"/>
    <url>/2024/05/11/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务-一-微服务概览"><a href="#微服务-一-微服务概览" class="headerlink" title="微服务(一) 微服务概览"></a>微服务(一) 微服务概览</h1><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>先问自己几个问题，看是否可以回答，下面我们就带着问题总结课程的内容</p><ul><li>为什么会有微服务？</li><li>微服务是什么？</li><li>微服务可以带来什么好处，又有那些缺点？</li><li>微服务如何构建？</li><li>微服务如何对外暴露？</li><li>微服务如何拆分？</li><li>如何保证微服务之间的安全？</li></ul><h3 id="Q1-为什么会有微服务？"><a href="#Q1-为什么会有微服务？" class="headerlink" title="Q1:为什么会有微服务？"></a>Q1:为什么会有微服务？</h3><ul><li>之前一般是一个单一的巨石架构，存在很多问题<ul><li>应用比较复杂，没有人能够搞懂</li><li>应用扩展比较复杂，可靠性比较低</li><li>无法进行敏捷开发和部署</li></ul></li><li>所以一般这个时候就会考虑按照服务、功能进行拆分</li></ul><h3 id="Q2-微服务是什么？"><a href="#Q2-微服务是什么？" class="headerlink" title="Q2:微服务是什么？"></a>Q2:微服务是什么？</h3><ul><li>SOA （面向服务）是什么？<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>单一职责，</strong>一个服务只做一件事情</li><li><strong>尽可能的早的创建原型，</strong>先定义 API，达成契约</li><li><strong>可移植性比效率更重要，</strong>通讯协议的可移植性更加重要</li></ul></li><li>SOA 和 微服务 是什么关系？<ul><li>微服务是 SOA 的一种实践，微服务也是面向服务的一种架构</li></ul></li><li>微服务是什么？<ul><li><strong>围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术</strong></li></ul></li></ul><h3 id="Q3-微服务可以带来哪些好处，又有哪些缺点？"><a href="#Q3-微服务可以带来哪些好处，又有哪些缺点？" class="headerlink" title="Q3:微服务可以带来哪些好处，又有哪些缺点？"></a>Q3:微服务可以带来哪些好处，又有哪些缺点？</h3><ul><li><p>优点</p><ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>原子服务，</strong>一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去</li><li><strong>独立进程，</strong>一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处</li><li><strong>隔离部署，</strong>每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本</li><li>去中心化服务治理<ul><li>数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台</li><li>治理去中心化</li><li>技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的</li></ul></li></ul></li><li><p>缺点</p><ul><li><p>服务之间的依赖关系复杂成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。</p><ul><li>常见的解决方案：全链路追踪，例如， opentracing</li></ul></li><li><p>微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</p><ul><li>例子：服务调用流量会容易被放大，如果 服务 A -&gt; B -&gt;C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的</li><li><strong>常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡</strong></li></ul></li><li><p>会有分布式事务问题，</p><p>因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦</p><ul><li>常见解决方案：两阶段提交、TCC 等</li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">小米信息部技术团队: 分布式事务，这一篇就够了</a></li></ul></li><li><p>测试会非常复杂，</p><p>由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题</p><ul><li>常见解决方案：独立测试环境，后面会有一个解决方案</li></ul></li><li><p>服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。</p><ul><li>切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，<strong>时刻谨记保持服务契约(接口)的兼容性</strong></li><li>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</li></ul></li><li><p>对基础建设的要求很高，</p><p>基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等</p><ul><li>常见解决方案：上云</li></ul></li></ul><h3 id="Q4-微服务如何构建？"><a href="#Q4-微服务如何构建？" class="headerlink" title="Q4: 微服务如何构建？"></a>Q4: <strong>微服务如何构建？</strong></h3><blockquote><p>多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</p></blockquote><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><h3 id="Q5-微服务如何对外暴露？"><a href="#Q5-微服务如何对外暴露？" class="headerlink" title="Q5:微服务如何对外暴露？"></a>Q5:<strong>微服务如何对外暴露？</strong></h3><p><img src="https://i.imgur.com/qejM7Jh.png" alt="1718629799961"></p></li></ul><h4 id="流量链路是什么？"><a href="#流量链路是什么？" class="headerlink" title="流量链路是什么？"></a>流量链路是什么？</h4><ul><li>移动端 -&gt; API Gateway -&gt; BFF -&gt; 微服务</li><li>不含 CDN、负载均衡（LB）</li><li>BFF 纯 web 的业务一般用 nodejs 做 SSR</li></ul><h4 id="为什么我们的服务不直接对外进行暴露？"><a href="#为什么我们的服务不直接对外进行暴露？" class="headerlink" title="为什么我们的服务不直接对外进行暴露？"></a>为什么我们的服务不直接对外进行暴露？</h4><ul><li>前端（移动端、客户端、web）同学非常痛苦，需要对接多个服务，兼容性差，沟通效率低</li><li>后端同学也很痛苦，一年前的版本都有人使用，服务无法进行重构升级</li></ul><h4 id="为什么需要最外层的-api-gateway"><a href="#为什么需要最外层的-api-gateway" class="headerlink" title="为什么需要最外层的 api gateway?"></a>为什么需要最外层的 api gateway?</h4><ul><li>基础库的同学非常痛苦，限流熔断安全等业务无关的功能需要进行升级的时候升不动</li></ul><h3 id="Q6-微服务如何拆分？"><a href="#Q6-微服务如何拆分？" class="headerlink" title="Q6: 微服务如何拆分？"></a>Q6: <strong>微服务如何拆分？</strong></h3><ul><li><p>在对业务领域不是特别熟悉的时候，按照<strong>部门职能进行划分，例如账号、财务等</strong></p><ul><li>注意划分的时候<strong>要闭环</strong>，不要相同的功能散落到几个部门当中</li></ul></li><li><p>在系统稳定之后，积累了相关的业务经验和微服务开发经验之后，再考虑使用 DDD 限界上下文进行划分</p></li><li><p>如果可以闭环的解决一个用户场景，那么它应该是一个微服务</p></li><li><p>还可以根据访问频率进行区分划分，将用户高频访问的部分划分为一个服务</p></li><li><p>还可以根据读写进行划分</p><ul><li><p>CQRS: 将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新</p><p><img src="https://i.imgur.com/k83Ex8Q.png" alt="1718630014302"></p></li></ul></li></ul><h3 id="Q7-如何保证微服务之间的安全？"><a href="#Q7-如何保证微服务之间的安全？" class="headerlink" title="Q7:如何保证微服务之间的安全？"></a>Q7:<strong>如何保证微服务之间的安全？</strong></h3><p><img src="https://i.imgur.com/aUAJjYf.png" alt="1718630058407"></p><p>在内网主要看安全级别一般有三种：</p><ul><li>Full Trust：假定内网服务之间是安全的，在内网裸奔</li><li>Half Trust：内网服务之间需要进行认证鉴权，但是不需要所有的都进行加密</li><li>Zero Trust: 零信任，任务内部网络是不安全的，类似公网，所有的请求通过身份认证鉴权之后，都需要通过安全加密，防止被嗅探<ul><li><a href="https://www.microsoft.com/en-us/security/business/zero-trust">https://www.microsoft.com/en-us/security/business/zero-trust</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2024/05/11/Docker/"/>
    <url>/2024/05/11/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li>官方文档地址:<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></li><li>中文参考手册:<a href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></li></ul><h2 id="1-Docker的基本概念"><a href="#1-Docker的基本概念" class="headerlink" title="1. Docker的基本概念"></a>1. Docker的基本概念</h2><h3 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h3><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h3 id="1-2-为什么是Docker"><a href="#1-2-为什么是Docker" class="headerlink" title="1.2 为什么是Docker"></a>1.2 为什么是Docker</h3><ul><li><p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p><p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p><p><strong>优势1: 一致的运行环境,更轻松的迁移</strong></p></li><li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p><p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p><p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p></li><li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p><p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p><p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p></li></ul><h3 id="1-3-Docker和虚拟机的区别"><a href="#1-3-Docker和虚拟机的区别" class="headerlink" title="1.3 Docker和虚拟机的区别"></a>1.3 Docker和虚拟机的区别</h3><blockquote><p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p></blockquote><p><img src="https://i.imgur.com/pwU9rfo.png" alt="img"></p><p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p><table><thead><tr><th align="left"></th><th align="left">传统虚拟机</th><th align="left">Docker容器</th></tr></thead><tbody><tr><td align="left">磁盘占用</td><td align="left">几个GB到几十个GB左右</td><td align="left">几十MB到几百MB左右</td></tr><tr><td align="left">CPU内存占用</td><td align="left">虚拟操作系统非常占用CPU和内存</td><td align="left">Docker引擎占用极低</td></tr><tr><td align="left">启动速度</td><td align="left">（从开机到运行项目）几分钟</td><td align="left">（从开启容器到运行项目）几秒</td></tr><tr><td align="left">安装管理</td><td align="left">需要专门的运维技术</td><td align="left">安装、管理方便</td></tr><tr><td align="left">应用部署</td><td align="left">每次部署都费时费力</td><td align="left">从第二次部署开始轻松简捷</td></tr><tr><td align="left">耦合性</td><td align="left">多个应用服务安装到一起，容易互相影响</td><td align="left">每个应用服务一个容器，达成隔离</td></tr><tr><td align="left">系统依赖</td><td align="left">无</td><td align="left">需求相同或相似的内核，目前推荐是Linux</td></tr></tbody></table><hr><h2 id="2-Docker的安装"><a href="#2-Docker的安装" class="headerlink" title="2. Docker的安装"></a>2. Docker的安装</h2><blockquote><p>以centos7为例 文档： <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p></blockquote><ul><li><p>卸载原始docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><p>安装docker依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils<br>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo <span class="hljs-comment"># 国内可能无法使用 可以使用下面的镜像源</span><br><span class="hljs-comment"># sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure></li><li><p>兼容性卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 卸载旧版本的docker</span><br>yum remove docker \<br>           docker-client \<br>           docker-client-latest \<br>           docker-common \<br>           docker-latest \<br>           docker-latest-logrotate \<br>           docker-logrotate \<br>           docker-selinux \<br>           docker-engine-selinux \<br>           docker-engine<br><span class="hljs-comment"># 卸载新版本的docker（叫docker-ce）</span><br>yum remove docker-ce \<br>           docker-ce-cli \<br>           containerd<br><br><span class="hljs-comment"># 停止删除服务</span><br>systemctl stop docker<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service.d<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service<br><span class="hljs-built_in">rm</span> -rf /var/lib/docker<br><span class="hljs-built_in">rm</span> -rf /var/run/docker<br><span class="hljs-built_in">rm</span> -rf /usr/local/docker<br><span class="hljs-built_in">rm</span> -rf /etc/docker<br><span class="hljs-built_in">rm</span> -rf /usr/bin/docker* /usr/bin/containerd* /usr/bin/runc /usr/bin/ctr<br></code></pre></td></tr></table></figure><p>删除之后再进行<strong>安装</strong>可能会遇到报错</p><p><img src="https://i.imgur.com/k9kZxJn.png" alt="image-20240528220125947"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看冲突的依赖包</span><br>yum list installed | grep docker<br><span class="hljs-comment"># 删除后安装其他指定版本</span><br>rpm -e docker-client.x86_64、rpm -e docker-common.x86_64<br></code></pre></td></tr></table></figure></li></ul><p>​<img src="https://i.imgur.com/6t0ZMvR.png" alt="image-20240528220350909"></p><h2 id="3-Docker的核心架构"><a href="#3-Docker的核心架构" class="headerlink" title="3. Docker的核心架构"></a>3. Docker的核心架构</h2><p><img src="https://i.imgur.com/qULQy2h.png" alt="img"></p><ul><li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li><li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li><li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li><li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li><li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li></ul><h2 id="4-Docker配置阿里云镜像加速"><a href="#4-Docker配置阿里云镜像加速" class="headerlink" title="4. Docker配置阿里云镜像加速"></a>4. Docker配置阿里云镜像加速</h2><ul><li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li><code>验证docker的镜像加速是否生效</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker info<br>..........<br>    127.0.0.0/8<br>   Registry Mirrors:<br>    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;<br>   Live Restore Enabled: false<br>   Product License: Community Engine<br></code></pre></td></tr></table></figure><hr><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><h3 id="5-1-辅助命令"><a href="#5-1-辅助命令" class="headerlink" title="5.1 辅助命令"></a>5.1 辅助命令</h3><pre><code class="hljs">    docker version--------------------------查看docker的信息    docker info--------------------------查看更详细的信息    docker --help--------------------------帮助命令</code></pre><h3 id="5-2-Images-镜像命令"><a href="#5-2-Images-镜像命令" class="headerlink" title="5.2 Images 镜像命令"></a>5.2 Images 镜像命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看本机中所有镜像</span><br>docker images--------------------------列出本地所有镜像<br>-a列出所有镜像（包含中间映像层）<br>  -q只显示镜像<span class="hljs-built_in">id</span><br><span class="hljs-comment"># 2.搜索镜像</span><br>docker search [options] 镜像名-------------------去dockerhub上查询当前镜像<br>-s 指定值列出收藏数不少于指定值的镜像<br>  --no-trunc  显示完整的镜像信息<br><span class="hljs-comment"># 3.从仓库下载镜像</span><br>docker pull 镜像名[:TAG|@DIGEST]----------------- 下载镜像<br><span class="hljs-comment"># 4.删除镜像</span><br>docker rmi 镜像名--------------------------  删除镜像<br>-f强制删除<br></code></pre></td></tr></table></figure><h3 id="5-3-Container命令"><a href="#5-3-Container命令" class="headerlink" title="5.3 Container命令"></a>5.3 Container命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.运行容器</span><br>docker run 镜像名--------------------------镜像名新建并启动容器<br>    --name 别名为容器起一个名字<br>    -d启动守护式容器（在后台启动容器）<br>    -p 映射端口号：原始端口号 指定端口号启动<br><br>例：docker run -it --name myTomcat -p 8888:8080 tomcat<br>    docker run -d --name myTomcat -P tomcat<br><br><span class="hljs-comment"># 2.查看运行的容器</span><br>docker ps--------------------------列出所有正在运行的容器<br>    -a正在运行的和历史运行过的容器<br>    -q静默模式，只显示容器编号<br><br><span class="hljs-comment"># 3.停止|关闭|重启容器</span><br>docker start   容器名字或者容器<span class="hljs-built_in">id</span>  --------------- 开启容器<br>docker restart 容器名或者容器<span class="hljs-built_in">id</span>    --------------- 重启容器<br>docker stop  容器名或者容器<span class="hljs-built_in">id</span>     ------------------ 正常停止容器运行<br>docker <span class="hljs-built_in">kill</span>  容器名或者容器<span class="hljs-built_in">id</span>      ------------------ 立即停止容器运行<br><br><span class="hljs-comment"># 4.删除容器</span><br>docker <span class="hljs-built_in">rm</span> -f 容器<span class="hljs-built_in">id</span>和容器名     <br>docker <span class="hljs-built_in">rm</span> -f $(docker ps -aq)--------------------------删除所有容器<br><br><span class="hljs-comment"># 5.查看容器内进程</span><br>docker top 容器<span class="hljs-built_in">id</span>或者容器名 ------------------ 查看容器内的进程<br><br><span class="hljs-comment"># 6.查看查看容器内部细节</span><br>docker inspect 容器<span class="hljs-built_in">id</span> ------------------ 查看容器内部细节<br><br><span class="hljs-comment"># 7.查看容器的运行日志</span><br>docker logs [OPTIONS] 容器<span class="hljs-built_in">id</span>或容器名------------------ 查看容器日志<br>    -t 加入时间戳<br>    -f 跟随最新的日志打印<br>    --<span class="hljs-built_in">tail</span>  数字显示最后多少条<br><br><span class="hljs-comment"># 8.进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> [options] 容器<span class="hljs-built_in">id</span> 容器内命令 ------------------ 进入容器执行命令<br>-i以交互模式运行容器，通常与-t一起使用<br>    -t分配一个伪终端    shell窗口   bash <br><br><span class="hljs-comment"># 9.容器和宿主机之间复制文件</span><br>docker <span class="hljs-built_in">cp</span> 文件|目录 容器<span class="hljs-built_in">id</span>:容器路径           -----------------   将宿主机复制到容器内部<br>docker <span class="hljs-built_in">cp</span> 容器<span class="hljs-built_in">id</span>:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上<br><br><span class="hljs-comment"># 10.数据卷(volum)实现与宿主机共享目录</span><br>docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名<br>注意: <br>    1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容<br>    2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中<br><br><span class="hljs-comment"># 11.打包镜像</span><br>docker save 镜像名 -o  名称.tar<br><br><span class="hljs-comment"># 12.载入镜像</span><br>docker load -i   名称.tar<br><br><span class="hljs-comment"># 13.容器打包成新的镜像</span><br>docker commit -m <span class="hljs-string">&quot;描述信息&quot;</span> -a <span class="hljs-string">&quot;作者信息&quot;</span>   （容器<span class="hljs-built_in">id</span>或者名称）打包的镜像名称:标签<br><br><span class="hljs-comment"># 14. 容器重新命名</span><br>docker tag [镜像<span class="hljs-built_in">id</span>] [新镜像名称]:[新镜像标签]<br></code></pre></td></tr></table></figure><h2 id="6-Docker镜像的原理"><a href="#6-Docker镜像的原理" class="headerlink" title="6. Docker镜像的原理"></a>6. Docker镜像的原理</h2><h3 id="6-1-镜像是什么"><a href="#6-1-镜像是什么" class="headerlink" title="6.1 镜像是什么"></a>6.1 镜像是什么</h3><blockquote><p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p></blockquote><h3 id="6-2-Docker的镜像原理"><a href="#6-2-Docker的镜像原理" class="headerlink" title="6.2 Docker的镜像原理"></a>6.2 Docker的镜像原理</h3><blockquote><p><strong>docker的镜像实际是由一层一层的文件系统组成。</strong></p></blockquote><ul><li>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux&#x2F;Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</li><li>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu&#x2F;CentOS等等。</li><li>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</li></ul><p><img src="https://i.imgur.com/mYIKz3o.png" alt="img"></p><p><code>UnionFS</code> (联合文件系统)： Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同的目录挂载到同一个虚拟机文件系统下，Union文件系统是Docker镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以用来制作各种具体的应用镜像。</p><p>特性： 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>怎么理解？当我们执行docker pull 的时候会拉取很多模块</p></blockquote><h2 id="7-Docker安装常用服务"><a href="#7-Docker安装常用服务" class="headerlink" title="7. Docker安装常用服务"></a>7. Docker安装常用服务</h2><h2 id="8-Dockerfile"><a href="#8-Dockerfile" class="headerlink" title="8. Dockerfile"></a>8. Dockerfile</h2><h3 id="8-1-什么是Dockerfile"><a href="#8-1-什么是Dockerfile" class="headerlink" title="8.1 什么是Dockerfile"></a>8.1 什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p><p><img src="https://i.imgur.com/teEfIcy.png" alt="img"></p><ul><li>通过架构图可以看出Docker file 可以直接构建镜像</li></ul><h3 id="8-2-Docker-file解析过程"><a href="#8-2-Docker-file解析过程" class="headerlink" title="8.2 Docker file解析过程"></a>8.2 Docker file解析过程</h3><p><img src="https://i.imgur.com/4y60ija.png" alt="img"></p><h3 id="8-3-Dockerfile的保留命令"><a href="#8-3-Dockerfile的保留命令" class="headerlink" title="8.3 Dockerfile的保留命令"></a>8.3 Dockerfile的保留命令</h3><p>官方说明:<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><table><thead><tr><th align="left">保留字</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left"><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td></tr><tr><td align="left">MAINTAINER</td><td align="left">镜像维护者的姓名和邮箱地址</td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left"><strong>构建镜像时需要运行的指令</strong></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left"><strong>当前容器对外暴露出的端口号</strong></td></tr><tr><td align="left"><strong>WORKDIR</strong></td><td align="left"><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left"><strong>用来在构建镜像过程中设置环境变量</strong></td></tr><tr><td align="left"><strong>ADD</strong></td><td align="left"><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left"><strong>类似于ADD，拷贝文件和目录到镜像中 将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td></tr><tr><td align="left"><strong>VOLUME</strong></td><td align="left"><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr><td align="left"><strong>CMD</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h4 id="8-3-1-FROM-命令"><a href="#8-3-1-FROM-命令" class="headerlink" title="8.3.1 FROM 命令"></a>8.3.1 FROM 命令</h4><ul><li><p>基于哪个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span>  &lt;image&gt;<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[@&lt;digest&gt;]  使用摘要<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-2-MAINTAINER-命令"><a href="#8-3-2-MAINTAINER-命令" class="headerlink" title="8.3.2 MAINTAINER 命令"></a>8.3.2 MAINTAINER 命令</h4><ul><li><p>镜像维护者的姓名和邮箱地址[废弃]</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-3-RUN-命令"><a href="#8-3-3-RUN-命令" class="headerlink" title="8.3.3 RUN 命令"></a>8.3.3 RUN 命令</h4><ul><li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt; (shell form, the <span class="hljs-built_in">command</span> is run <span class="hljs-keyword">in</span> a shell, <span class="hljs-built_in">which</span> by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> hello</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo hello&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-4-EXPOSE-命令"><a href="#8-3-4-EXPOSE-命令" class="headerlink" title="8.3.4 EXPOSE 命令"></a>8.3.4 EXPOSE 命令</h4><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/udp<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-5-CMD-命令"><a href="#8-3-5-CMD-命令" class="headerlink" title="8.3.5 CMD 命令"></a>8.3.5 CMD 命令</h4><ul><li><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li><li><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form, this is the preferred form)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (as default parameters to ENTRYPOINT)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2 (shell form)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-6-WORKDIR-命令"><a href="#8-3-6-WORKDIR-命令" class="headerlink" title="8.3.6 WORKDIR 命令"></a>8.3.6 WORKDIR 命令</h4><ul><li><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br>`注意:<span class="hljs-keyword">WORKDIR</span><span class="language-bash">指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-7-ENV-命令"><a href="#8-3-7-ENV-命令" class="headerlink" title="8.3.7 ENV 命令"></a>8.3.7 ENV 命令</h4><ul><li><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-8-ADD-命令"><a href="#8-3-8-ADD-命令" class="headerlink" title="8.3.8 ADD 命令"></a>8.3.8 ADD 命令</h4><ul><li><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> url </span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-9-COPY-命令"><a href="#8-3-9-COPY-命令" class="headerlink" title="8.3.9 COPY 命令"></a>8.3.9 COPY 命令</h4><ul><li><p>用来将context目录中指定文件复制到镜像的指定目录中</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-10-VOLUME-命令"><a href="#8-3-10-VOLUME-命令" class="headerlink" title="8.3.10 VOLUME 命令"></a>8.3.10 VOLUME 命令</h4><ul><li><p>用来定义容器运行时可以挂在到宿主机的目录</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-11-ENTRYPOINT-命令"><a href="#8-3-11-ENTRYPOINT-命令" class="headerlink" title="8.3.11 ENTRYPOINT 命令"></a>8.3.11 ENTRYPOINT 命令</h4><ul><li><p>用来指定容器启动时执行命令和CMD类似</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]<br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="8-4-Dockerfile构建SpringBoot应用"><a href="#8-4-Dockerfile构建SpringBoot应用" class="headerlink" title="8.4 Dockerfile构建SpringBoot应用"></a>8.4 Dockerfile构建SpringBoot应用</h3><ol><li><p>创建Spring Boot应用</p></li><li><p>执行打包命令</p></li><li><p>创建Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-spring-boot-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-spring-boot-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-springboot-demo .<br></code></pre></td></tr></table></figure></li><li><p>运行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8081:8080 docker-springboot-demo<br></code></pre></td></tr></table></figure></li><li><p>访问项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --location <span class="hljs-string">&#x27;http://localhost:8081/index&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="9-Docker网络"><a href="#9-Docker网络" class="headerlink" title="9. Docker网络"></a>9. Docker网络</h2><p>当项目大规模使用 Docker 时，容器通信的问题也就产生了。要解决容器通信问题，必须先了解很多关于网络的知识。Docker 作为目前最火的轻量级容器技术，有很多令人称道的功能，如 Docker 的镜像管理。然而，Docker 同样有着很多不完善的地方，网络方面就是 Docker 比较薄弱的部分。因此，我们有必要深入了解 Docker 的网络知识，以满足更高的网络需求。</p><p>我们在启动docker的时候，主机会有增加一个docker0的网络</p><p><img src="https://i.imgur.com/nZMAhP9.png" alt="image-20240513221855243"></p><blockquote><p>默认网络</p></blockquote><p>安装 Docker 以后，会默认创建三种网络，可以通过 <code>docker network ls</code> 查看。</p><p><img src="https://i.imgur.com/HNAdhQ7.png" alt="image-20240513222000607"></p><ul><li><p>bridge 网络模式</p><p>在该模式中，Docker 守护进程创建了一个虚拟以太网桥 <code>docker0</code>，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包，并为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code></p><p>虚拟网桥，默认为该模式</p></li><li><p>host 网络模式</p><p>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</p></li><li><p>none 网络模式</p><p>容器具有独立的Network namespace, 但并没有对其进行任何网络设置，如分配veth part和网桥连接，IP等</p></li><li><p>container 网络模式</p><p>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等</p></li></ul><h3 id="9-1-Docker-网络常用命令"><a href="#9-1-Docker-网络常用命令" class="headerlink" title="9.1 Docker 网络常用命令"></a>9.1 Docker 网络常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network --<span class="hljs-built_in">help</span><br><br>Usage:  docker network COMMAND<br><br>Manage networks<br><br>Commands:<br>  connect     Connect a container to a network<br>  create      Create a network<br>  disconnect  Disconnect a container from a network<br>  inspect     Display detailed information on one or more networks<br>  <span class="hljs-built_in">ls</span>          List networks<br>  prune       Remove all unused networks<br>  <span class="hljs-built_in">rm</span>          Remove one or more networks<br><br>Run <span class="hljs-string">&#x27;docker network COMMAND --help&#x27;</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h3 id="9-2-Docker-网络能干嘛"><a href="#9-2-Docker-网络能干嘛" class="headerlink" title="9.2 Docker 网络能干嘛"></a>9.2 Docker 网络能干嘛</h3><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不收到任何影响</li></ul><h3 id="9-3-Docker-容器之间内部的通信"><a href="#9-3-Docker-容器之间内部的通信" class="headerlink" title="9.3 Docker 容器之间内部的通信"></a>9.3 Docker 容器之间内部的通信</h3><blockquote><p>Tips 通过自建网络实现</p></blockquote><ol><li><p>准备所需要环境</p><p>笔者使用ubuntu镜像实现，需要先拉取对应镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull ubuntu<br>docker images<br></code></pre></td></tr></table></figure><blockquote><p>如果出现docker search 可以使用，docker pull 失败的问题可以尝试看看是否是DNS的问题 &#x2F;etc</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/6BhHiZO.png" alt="image-20240514184217779"></p></li><li><p>创建网络</p><p>如果不清楚docker network命令可以使用<code>docker network --help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create test-network<br></code></pre></td></tr></table></figure><p>创建网络之后执行<code>docker network ls</code>看看是否执行成功</p></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动两个docker容器</span><br>docker run -it --name u1 --network test-network --network-alias ubuntu1  ubuntu bash<br>docker run -it --name u2 --network test-network --network-alias ubuntu2  ubuntu bash<br>   <br></code></pre></td></tr></table></figure><ul><li>–network 指定网络</li><li>–network-alias 指定网络名称（类似于主机名称，后续可以直接通过<code>ping</code>这个主机）</li></ul></li><li><p>安装容器环境</p><p>启动的容器是没有<code>ifconfig</code>,<code>ping</code>这些命令的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update &amp;&amp; apt install -y net-tools &amp;&amp; apt install -y iputils-ping<br><br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>分别启动两个容器，并进入<code>shell</code>，进入容器命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it [container_id] bash<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://i.imgur.com/C9PS4pG.jpeg" alt="image-20240514184129680"></p></li></ol><h2 id="9-Docker-Compose"><a href="#9-Docker-Compose" class="headerlink" title="9. Docker Compose"></a>9. Docker Compose</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p><h3 id="9-2-docker-compose-安装"><a href="#9-2-docker-compose-安装" class="headerlink" title="9.2 docker-compose 安装"></a>9.2 docker-compose 安装</h3><blockquote><p>官网： <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>下载地址：<a href="https://docs.docker.com/compose/install">https://docs.docker.com/compose/install</a></p></blockquote><h3 id="9-3-docker-compose"><a href="#9-3-docker-compose" class="headerlink" title="9.3 docker compose"></a>9.3 docker compose</h3><ol><li><p>To download and install Compose standalone, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Apply executable permissions to the standalone binary in the target path for the installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Test and execute compose commands using <code>docker-compose</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose --version<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/CxmN9fd.png" alt="image-20240514212055991"></p></li></ol><h3 id="9-4-docker-compose常用命令"><a href="#9-4-docker-compose常用命令" class="headerlink" title="9.4 docker-compose常用命令"></a>9.4 docker-compose常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -h <span class="hljs-comment"># 查看帮助</span><br>docker-compose up <span class="hljs-comment"># 启动所有服务</span><br>docker-compose up -d <span class="hljs-comment"># 启动所有docker-compose服务并后台运行</span><br>docker-compose down <span class="hljs-comment"># 停止并删除容器、网络、卷、镜像</span><br>docker-compose <span class="hljs-built_in">exec</span> [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 进入容器实例内部</span><br>docker-compose ps <span class="hljs-comment"># 展示当前docker-compose编排过的运行的容器</span><br>docker-compose top <span class="hljs-comment"># 展示当前docker-compose编排过的容器进程</span><br><br>docker-compose logs [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 查看容器输出日志</span><br>docker-compose config <span class="hljs-comment"># 检查配置</span><br>docker-compose config -q <span class="hljs-comment"># 检查配置，有问题才输出</span><br>docker-compose restart <span class="hljs-comment"># 重启服务</span><br>docker-compose start <span class="hljs-comment"># 启动服务</span><br>docker-compose stop <span class="hljs-comment"># 停止服务</span><br></code></pre></td></tr></table></figure><h3 id="9-5-docker-compose-使用"><a href="#9-5-docker-compose-使用" class="headerlink" title="9.5 docker-compose 使用"></a>9.5 docker-compose 使用</h3><ol><li><p>构建镜像（基于Spring Boot）</p><ol><li><p>编写代码</p></li><li><p>配置文件修改</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">docker-compose</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc://mysql:13306/compose?useUnicode=true&amp;useSSL=false</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure></li><li><p>编写Dockerfile、docker-compose.yml</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-compose-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-compose-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">composeService:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker-compose:1.6</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">dc1.6</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6001:6001&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/java-demo:/java-demo</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="hljs-string">&quot;no&quot;</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">&quot;compose&quot;</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">&quot;root&quot;</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">&quot;root&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/db:/var/lib/mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/conf/my.cnf:/etc/my.cnf</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/init:/docker-entrypoint-initdb.d</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span> <span class="hljs-comment"># 解决外部无法访问</span><br><span class="hljs-attr">networks:</span><br>    <span class="hljs-attr">compose_net:</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>上传镜像和相关文件</p></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-compose:1.6 .<br></code></pre></td></tr></table></figure></li><li><p>执行核心操作</p><ul><li>docker-compose up -d</li></ul></li></ol><blockquote><p>总结 尽量不要使用docker-compose 不好用</p></blockquote><h2 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10. 异常处理"></a>10. 异常处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># docker search mysql 或者 docker pull 这些命令无法使用</span><br>Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid<br></code></pre></td></tr></table></figure><blockquote><p>这个错误的原因是因为系统的时间和docker hub时间不一致，需要做系统时间与网络时间同步</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装时间同步</span><br>sudo yum -y install ntp ntpdate<br><span class="hljs-comment"># 2.同步时间</span><br>sudo ntpdate cn.pool.ntp.org<br><span class="hljs-comment"># 3.查看本机时间</span><br><span class="hljs-built_in">date</span><br><span class="hljs-comment"># 4.重新测试</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-grpc</title>
    <link href="/2024/04/20/grpc/"/>
    <url>/2024/04/20/grpc/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-grpc"><a href="#Go-grpc" class="headerlink" title="Go-grpc"></a>Go-grpc</h1><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><h3 id="1-1-安装-protoc"><a href="#1-1-安装-protoc" class="headerlink" title="1.1 安装 protoc"></a>1.1 安装 protoc</h3><p>安装protocol buffers <a href="https://github.com/protocolbuffers/protobuf/releases">protocol</a></p><ul><li><p>Protocol buffers, 通常称为Protobuf，是Google开发的一种协议，用于允许结构体数据进行序列化和反序列化。他开发程序以通过网络相互通信或存储数据时很有用。谷歌开发它的目的是提供一种比XML更好的方式来通信。</p></li><li><p>我们将找到所有操作系统的zip文件。基于目前的操作系统。下载特定的即可。笔者使用的debian</p></li><li><p><img src="https://i.imgur.com/mJXMPVe.png" alt="image-20240424211235999"></p></li><li><p>配置环境变量，笔者使用的shell是zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.zshrc<br><span class="hljs-built_in">export</span> PATH=~/env/protoc/bin/:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li><li><p>检查是否有效，在终端中输入 protoc 命令</p></li></ul><h3 id="1-2-初始化go项目并安装grpc"><a href="#1-2-初始化go项目并安装grpc" class="headerlink" title="1.2 初始化go项目并安装grpc"></a>1.2 初始化go项目并安装grpc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init github.com/hailong-bot/h-grpc<br>go get google.golang.org/grpc<br></code></pre></td></tr></table></figure><h3 id="1-3-安装代码生成工具"><a href="#1-3-安装代码生成工具" class="headerlink" title="1.3 安装代码生成工具"></a>1.3 安装代码生成工具</h3><p>上面安装的是protoc编译器。他可以各种语言的代码。因此除了这个编译器，我们还需要配合各个语言的代码生成工具。对于Golang来说，称为<strong>protoc-gen-go</strong>。不过在这有点小坑，<strong>github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</strong>和<strong>google.golang.org&#x2F;protobuf&#x2F;cmd&#x2F;proto-gen-go</strong>是不同的。区别在于前者是旧版本，后者是google接手后的版本，他们之间API是不同的，也就是用于生成的命令，以及生成的文件是不同的。因为目前gRPC-go源码中的example采用的是后者的方式，为了与时俱进，我们也采取最新的方式。你需要安装两个库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest<br>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest<br></code></pre></td></tr></table></figure><p>因为这些文件在安装<strong>grpc</strong>的时候已经下载下来了，因此使用<strong>install</strong>命令就可以了，而不需要使用<strong>get</strong></p><p>然后$GOPATH&#x2F;bin下会出现两个文件</p><h2 id="2-proto文件编写"><a href="#2-proto文件编写" class="headerlink" title="2. proto文件编写"></a>2. proto文件编写</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 说明我们在使用proto3语法 </span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span><br><br><span class="hljs-comment">// 这部分的内容是关于最后生成的go文件在哪个目录哪个包里面，.代表当前目录, service代表生成的go文件的包名是service </span><br><span class="hljs-keyword">option</span> go_package =<span class="hljs-string">&quot;.;service&quot;</span><br><br><span class="hljs-comment">// 定义一个服务一个方法 这个方法接受一个参数并返回一个响应</span><br><span class="hljs-comment">// 这个方法会发送一个HelloRequest，然后返回一个HelloResponse</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">SayHello</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// message关键字 可以理解为定义结构体</span><br><span class="hljs-comment">// 这里面比较特殊 后面的赋值是表明变量在这个message中的位置</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> requestName = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> responseMsg = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写完上面的文件，在proto文件同级目录执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --go_out=. hello.proto<br>protoc --go-grpc_out=. hello.proto<br></code></pre></td></tr></table></figure><p>最后会生成两个go代码，更改具体方法即可</p><h3 id="2-1-proto文件介绍"><a href="#2-1-proto文件介绍" class="headerlink" title="2.1 proto文件介绍"></a>2.1 proto文件介绍</h3><blockquote><p>message</p></blockquote><p>messgae: protobug中定义一个消息类型式是通过message字段制定的。消息就是需要传输的数据格式的定义</p><p>message关键字类似于c++中的class, java中的class, go中的struct</p><blockquote><p>字段规则</p></blockquote><p>required: 消息中必填字段，不设置会导致编码异常。在protobuf3中被删去</p><p>optional: 消息中设置可选字段，protobuf3中被删除</p><p>repeated: 消息体中可重复字段，重复的值的顺序会被保留在go中重复的会被定义为切片</p><blockquote><p>消息号</p></blockquote><p>在消息体的定义中，<strong>每个字段都必须要有唯一一个标识号</strong>，标识号是[1, 2^29-1]的<strong>一个整数</strong></p><blockquote><p>嵌套消息</p></blockquote><p>可以在其他消息类型中定义、使用消息类型，在下面的例子中,Person消息就定义在PersonInfo消息内</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">PersonInfo</span>&#123;<br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br><span class="hljs-type">int32</span> height = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">repeated</span> <span class="hljs-type">int32</span> weight = <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">repeated</span> Person info = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要在它的父消息类型的外部重用这个消息类型，需要PersonInfo.Person形式使用，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">PersonMessage</span> &#123;<br>PersonInfo.Person info = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>服务定义</p></blockquote><p>如果想要将消息类型用在RPC系统中，可以在.proto文件中定义一个rpc服务接口，protocol buffer编译器将会根据所选择的语言生成服务接口代码</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>上述代表，定义了一个RPC服务，该方法接受SearchRequest返回SearchResponse</p><h2 id="3-服务端编写"><a href="#3-服务端编写" class="headerlink" title="3. 服务端编写"></a>3. 服务端编写</h2><ul><li><p>创建gRPC Server对象，可以理解为它是Server端的抽象对象</p></li><li><p>将server(其中包含需要被调用的服务端接口) 注册到gRPC Server的内部注册中心，这样可以在接受到请求的时候，通过内部服务发现，发现该服务端接口并转发进行逻辑处理</p></li><li><p>创建Listen，监听TCP端口</p></li><li><p>gRPC Server 开始lis.Accept，直到Stop</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 服务端</span><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span> &#123;<br>pb.UnimplementedSayHelloServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> &amp;pb.HelloResponse&#123;<br>ResponseMsg: <span class="hljs-string">&quot;HelloWord&quot;</span> + req.RequestName,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:9090&quot;</span>)<br>grpcServer := grpc.NewServer()<br>pb.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;)<br>fmt.Println(<span class="hljs-string">&quot;启动成功&quot;</span>)<br>err := grpcServer.Serve(listen)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;启动失败&quot;</span>)<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-客户端编写"><a href="#4-客户端编写" class="headerlink" title="4. 客户端编写"></a>4. 客户端编写</h2><ul><li><p>创建与给定目标（服务端）的连接交互</p></li><li><p>创建Server的客户端对象</p></li><li><p>发送RPC请求，等待同步响应，得到回调后返回响应结果</p></li><li><p>输出响应结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:9090&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;did not connect: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>client := pb.NewSayHelloClient(conn)<br>helloResponse, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;RequestName: <span class="hljs-string">&quot;phoenix&quot;</span>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;失败&quot;</span>)<br>&#125;<br>fmt.Println(helloResponse)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口幂等性</title>
    <link href="/2024/02/28/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2024/02/28/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h1><h1 id="1-什么是幂等性"><a href="#1-什么是幂等性" class="headerlink" title="1. 什么是幂等性"></a>1. 什么是幂等性</h1><p>接口幂等性就是用户对于同一操作发起的一次请求或则多次请求的结果是一致的，不回因为多次点击而产生了副作用。比如说支付场景，用户购买了商品支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条．．．,这就没有保证接口的幂等性</p><h1 id="2-哪些情况需要防止"><a href="#2-哪些情况需要防止" class="headerlink" title="2. 哪些情况需要防止"></a>2. 哪些情况需要防止</h1><p>用户多次点击按钮</p><p>用户页面回退再次提交</p><p>微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制（或代码中的重试机制）</p><p>其他业务情况</p><h1 id="3-什么情况下需要幂等"><a href="#3-什么情况下需要幂等" class="headerlink" title="3. 什么情况下需要幂等"></a>3. 什么情况下需要幂等</h1><p>以 SQL 为例，有些操作是天然幂等的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> WHER id<span class="hljs-operator">=</span>? #无论执行多少次都不会改变状态，是天然的幂等<br><span class="hljs-keyword">UPDATE</span> tab1 <span class="hljs-keyword">SET</span> col1<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> col2<span class="hljs-operator">=</span><span class="hljs-number">2</span> #无论执行成功多少次状态都是一致的，也是幂等操作<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid<span class="hljs-operator">=</span><span class="hljs-number">1</span> #多次操作，结果一样，具备幂等性<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(userid,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>) # 如 userid 为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<br><br><br><span class="hljs-keyword">UPDATE</span> tab1 <span class="hljs-keyword">SET</span> col1<span class="hljs-operator">=</span>col1<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> col2<span class="hljs-operator">=</span><span class="hljs-number">2</span> # 每次执行的结果都会发生变化，不是幂等的<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(userid,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>) #) 如 userid 不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性<br></code></pre></td></tr></table></figure><h1 id="4-幂等解决方案"><a href="#4-幂等解决方案" class="headerlink" title="4. 幂等解决方案"></a>4. 幂等解决方案</h1><h2 id="4-1-token实现接口幂等性"><a href="#4-1-token实现接口幂等性" class="headerlink" title="4.1 token实现接口幂等性"></a>4.1 token实现接口幂等性</h2><ol><li><p>实现思路</p><p>为需要保证幂等性的每一次请求创建一个唯一标识token, 先获取token, 并将此token存入redis, 请求接口时, 将此token放到header或者作为请求参数请求接口, 后端接口判断redis中是否存在此token: 如果存在, 正常处理业务逻辑, 并从redis中删除此token, 那么, 如果是重复请求, 由于token已被删除, 则不能通过校验, 返回请勿重复操作提示， 如果不存在, 说明参数不合法或者是重复请求, 返回提示即可。</p></li><li><p>Java版实现逻辑</p><blockquote><p>pom.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>RedisUtil</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisUtil</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(RedisUtil.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;set key:&#123;&#125; value:&#123;&#125;&quot;</span>, key, value);<br>        stringRedisTemplate.opsForValue().set(key,value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 过期时间, 单位: s</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String value, <span class="hljs-type">int</span> expireTime)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;set key:&#123;&#125; value:&#123;&#125; expireTime:&#123;&#125;&quot;</span>, key, value, expireTime);<br>        stringRedisTemplate.opsForValue().set(key,value, expireTime,TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;get key:&#123;&#125;&quot;</span>, key);<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">del</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (exists(key)) &#123;<br>            <span class="hljs-keyword">return</span> stringRedisTemplate.delete(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.error(<span class="hljs-string">&quot;del key:&#123;&#125;&quot;</span>, key+<span class="hljs-string">&quot; 不存在&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断key是否存在</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">exists</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> stringRedisTemplate.hasKey(key);<br>        logger.info(<span class="hljs-string">&quot;exists key:&#123;&#125; hasKey:&#123;&#125;&quot;</span>, key, exists);<br>        <span class="hljs-keyword">return</span> exists;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自定义注解 @ApiIdempotent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.smartMap.media.common.apiIdempotent.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ApiIdempotent &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>响应状态码 ResponseCode</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ResponseCode</span> &#123;<br><br>    ILLEGAL_ARGUMENT(<span class="hljs-number">10000</span>, <span class="hljs-string">&quot;参数不合法&quot;</span>),<br>    REPETITIVE_OPERATION(<span class="hljs-number">10001</span>, <span class="hljs-string">&quot;请勿重复操作&quot;</span>),<br>    ;<br><br>    ResponseCode(Integer code, String msg) &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Integer code;<br><br>    <span class="hljs-keyword">private</span> String msg;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(Integer code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMsg</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>常量 Constant</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constant</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Redis</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">OK</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_MINUTE</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<span class="hljs-comment">// 过期时间, 60s, 一分钟</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_FIVE_MINUTE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span> * <span class="hljs-number">60</span>;<span class="hljs-comment">// 过期时间, 60s, 一分钟</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_HOUR</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<span class="hljs-comment">// 过期时间, 一小时</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_DAY</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>;<span class="hljs-comment">// 过期时间, 一天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">TOKEN_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;API_IDEMPOTENT_TOKEN:&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>token接口 ApiIdempotentTokenService</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.R;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiIdempotentTokenService</span> &#123;<br><br>    R <span class="hljs-title function_">createToken</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkToken</span><span class="hljs-params">(HttpServletRequest request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>token接口实现类 ApiIdempotentTokenServiceImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.smartMap.media.common.apiIdempotent.service.impl;<br><br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.common.Constant;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.common.ResponseCode;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.service.ApiIdempotentTokenService;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.utils.RedisUtil;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.exception.RRException;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.R;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.UuidUtils;<br><span class="hljs-keyword">import</span> org.apache.commons.lang.text.StrBuilder;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service(&quot;apiIdempotentTokenService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiIdempotentTokenServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApiIdempotentTokenService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">API_IDEMPOTENT_TOKEN_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apiIdempotentToken&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">createToken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> UuidUtils.randomUUID();<br>        <span class="hljs-type">StrBuilder</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrBuilder</span>();<br>        token.append(Constant.Redis.TOKEN_PREFIX).append(str);<br>        redisUtil.set(token.toString(), token.toString(), Constant.Redis.EXPIRE_TIME_FIVE_MINUTE);<br>        <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">&quot;token&quot;</span>,token.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkToken</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(API_IDEMPOTENT_TOKEN_NAME);<br>        <span class="hljs-comment">// header中不存在token</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>            token = request.getParameter(API_IDEMPOTENT_TOKEN_NAME);<br>            <span class="hljs-comment">// parameter中也不存在token</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RRException</span>(ResponseCode.ILLEGAL_ARGUMENT.getMsg(),ResponseCode.ILLEGAL_ARGUMENT.getCode());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!redisUtil.exists(token)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RRException</span>(ResponseCode.REPETITIVE_OPERATION.getMsg(),ResponseCode.REPETITIVE_OPERATION.getCode());<br>        &#125;<br><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">del</span> <span class="hljs-operator">=</span> redisUtil.del(token);<br>        <span class="hljs-keyword">if</span> (!del) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RRException</span>(ResponseCode.REPETITIVE_OPERATION.getMsg(),ResponseCode.REPETITIVE_OPERATION.getCode());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>拦截器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.annotation.ApiIdempotent;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.service.ApiIdempotentTokenService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiIdempotentInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandlerInterceptorAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApiIdempotentTokenService apiIdempotentTokenService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> handlerMethod.getMethod();<br><br>        <span class="hljs-type">ApiIdempotent</span> <span class="hljs-variable">methodAnnotation</span> <span class="hljs-operator">=</span> method.getAnnotation(ApiIdempotent.class);<br>        <span class="hljs-keyword">if</span> (methodAnnotation != <span class="hljs-literal">null</span>) &#123;<br>            check(request);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        apiIdempotentTokenService.checkToken(request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>拦截器注册WebConfig</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.interceptor.ApiIdempotentInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApiIdempotentInterceptor apiIdempotentInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(apiIdempotentInterceptor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试验证 controller</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.annotation.ApiIdempotent;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.service.ApiIdempotentTokenService;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.R;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/mobile/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApiIdempotentTokenService apiIdempotentTokenService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;getToken&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> apiIdempotentTokenService.createToken();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试接口幂等性, 在需要幂等性校验的方法上声明此注解即可</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiIdempotent</span><br>    <span class="hljs-meta">@RequestMapping(&quot;testIdempotence&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">testIdempotence</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> R.ok(<span class="hljs-string">&quot;测试接口幂等性&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>流程</p></blockquote><p>前端获取接口token -&gt; 请求幂等性接口时请求头带上token </p><blockquote><p>tips</p></blockquote><p>删除token时校验下，没有使用分布式锁，不能保证原子性，删除token时那个操作对于redis来说具有原子性，因此必须校验。</p><p>弊端：此操作每次都要去请求token。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>如果要保证获取token、判断、删除具有原子性可以采取上面的措施</p></li></ol><h2 id="4-2-各种锁机制"><a href="#4-2-各种锁机制" class="headerlink" title="4.2 各种锁机制"></a>4.2 各种锁机制</h2><h3 id="4-2-1-数据库悲观锁"><a href="#4-2-1-数据库悲观锁" class="headerlink" title="4.2.1 数据库悲观锁"></a>4.2.1 数据库悲观锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xxxx <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。<strong>不推荐使用</strong></p><blockquote><p>Java示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;MyEntity&gt; &#123;<br><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM my_entity WHERE request_id = #&#123;requestId&#125; FOR UPDATE&quot;)</span><br>    MyEntity <span class="hljs-title function_">lockByRequestId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;requestId&quot;)</span> String requestId)</span>;<br>&#125;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyMapper myMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(MyMapper myMapper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myMapper = myMapper;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(String requestId)</span> &#123;<br>        <span class="hljs-type">MyEntity</span> <span class="hljs-variable">existingRecord</span> <span class="hljs-operator">=</span> myMapper.selectById(requestId);<br><br>        <span class="hljs-keyword">if</span> (existingRecord != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">MyEntity</span> <span class="hljs-variable">lockedEntity</span> <span class="hljs-operator">=</span> myMapper.lockByRequestId(requestId);<br><br>            <span class="hljs-comment">// 由于设置了行锁 同一个请求ID 进来 这一行进行了行锁</span><br>            <span class="hljs-comment">// 执行业务逻辑，处理请求</span><br>        handleOrderProcessing(lockedOrder);<br>            <span class="hljs-comment">// ...</span><br><br>            <span class="hljs-comment">// 锁会在事务提交时自动释放</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 未找到记录，可能需要创建新的记录</span><br>            <br>            <span class="hljs-type">MyEntity</span> <span class="hljs-variable">newRecord</span> <span class="hljs-operator">=</span> createNewRecord(requestId);<br>            myMapper.insert(newRecord);<br><br>            <span class="hljs-comment">// 执行业务逻辑，处理请求</span><br>            handleRequestProcessing(newRecord);<br>            <span class="hljs-comment">// 锁会在事务提交时自动释放</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码使用了Spring的<code>@Transactional</code>注解，确保整个方法在一个数据库事务中运行。<code>myRepository.lockByRequestId(requestId)</code>表示使用悲观锁锁定具有给定请求标识符的数据库行。如果已经存在具有相同请求标识符的记录，则直接返回之前的处理结果，否则执行实际的业务逻辑并将结果保存到数据库。这确保了在悲观锁的保护下，对相同请求的多次处理仅执行一次实际的业务逻辑。</p><p><strong>锁在事务提交时自动释放的意思时：在事务中获取的悲观锁（例如，在 <code>lockByOrderId</code> 方法中的 <code>SELECT ... FOR UPDATE</code> 查询）会一直持续到事务提交。一旦事务成功提交，数据库会自动释放这个锁，使得其他事务可以访问相应的资源。</strong></p><p>实体中  requestId 需要要设置唯一索引</p><h3 id="4-2-2-数据库乐观锁"><a href="#4-2-2-数据库乐观锁" class="headerlink" title="4.2.2 数据库乐观锁"></a>4.2.2 数据库乐观锁</h3><p>数据库乐观锁通常用于解决多个事务同时访问相同数据时可能引发的并发问题。在数据库乐观锁的场景中，接口幂等性的实现通常是通过版本号（或者称为修改时间戳）来保证的。以下是一个简单的示例，演示如何使用乐观锁和版本号来实现接口幂等性：</p><ol><li><p>数据表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_entity (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    request_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    data <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>    version <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span><br>);<br></code></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;my_entity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEntity</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String data;<br>    <span class="hljs-keyword">private</span> Integer version;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Update;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;MyEntity&gt; &#123;<br><br>    <span class="hljs-meta">@Update(&quot;UPDATE my_entity SET data = #&#123;data&#125;, version = version + 1 WHERE request_id = #&#123;requestId&#125; AND version = #&#123;version&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateDataByVersion</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;requestId&quot;)</span> String requestId, <span class="hljs-meta">@Param(&quot;data&quot;)</span> String data, <span class="hljs-meta">@Param(&quot;version&quot;)</span> <span class="hljs-type">int</span> version)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>updateDataByVersion</code> 方法使用了 MyBatis Plus 的 <code>@Update</code> 注解，执行了一个带有版本号检查的更新操作。更新时，会检查传入的版本号是否与数据库中的版本号一致，如果一致才执行更新操作。</p></li><li><p>核心逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyMapper myMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(MyMapper myMapper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myMapper = myMapper;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(String requestId, String newData)</span> &#123;<br>        <span class="hljs-comment">// 根据请求ID查询记录</span><br>        <span class="hljs-type">MyEntity</span> <span class="hljs-variable">existingRecord</span> <span class="hljs-operator">=</span> myMapper.selectById(requestId);<br><br>        <span class="hljs-keyword">if</span> (existingRecord != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新数据（带版本号检查）</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">updatedRows</span> <span class="hljs-operator">=</span> myMapper.updateDataByVersion(requestId, newData, existingRecord.getVersion());<br><br>            <span class="hljs-keyword">if</span> (updatedRows &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 更新成功，执行业务逻辑</span><br>                handleRequestProcessing(requestId, newData);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 更新失败，可能是版本号不匹配</span><br>                <span class="hljs-comment">// 可以根据实际情况进行处理，比如抛出异常</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 未找到记录，创建新的记录</span><br>            <span class="hljs-type">MyEntity</span> <span class="hljs-variable">newRecord</span> <span class="hljs-operator">=</span> createNewRecord(requestId, newData);<br>            myMapper.insert(newRecord);<br><br>            <span class="hljs-comment">// 执行业务逻辑，处理请求</span><br>            handleRequestProcessing(requestId, newData);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequestProcessing</span><span class="hljs-params">(String requestId, String newData)</span> &#123;<br>        <span class="hljs-comment">// 具体的业务逻辑，例如记录日志等</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> MyEntity <span class="hljs-title function_">createNewRecord</span><span class="hljs-params">(String requestId, String newData)</span> &#123;<br>        <span class="hljs-comment">// 创建新的记录</span><br>        <span class="hljs-type">MyEntity</span> <span class="hljs-variable">newRecord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEntity</span>();<br>        newRecord.setRequestId(requestId);<br>        newRecord.setData(newData);<br>        newRecord.setVersion(<span class="hljs-number">0</span>); <span class="hljs-comment">// 初始版本号</span><br>        <span class="hljs-keyword">return</span> newRecord;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>笔者强烈推荐使用悲观锁实现，特别是Java开发人员，如果是使用Mybatis Plus可以使用插件来完成这一系列的操作 ，来避免重复操作，后续代码笔者会给出 github 地址。</strong></p></li></ol><h2 id="4-3-各种唯一索引"><a href="#4-3-各种唯一索引" class="headerlink" title="4.3 各种唯一索引"></a>4.3 各种唯一索引</h2><h3 id="4-3-1-数据库唯一索引"><a href="#4-3-1-数据库唯一索引" class="headerlink" title="4.3.1 数据库唯一索引"></a>4.3.1 数据库唯一索引</h3><p>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。<strong>不推荐 比较难以控制</strong></p><h3 id="4-3-2-redis-set防重"><a href="#4-3-2-redis-set防重" class="headerlink" title="4.3.2 redis set防重"></a>4.3.2 redis set防重</h3><p>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的 set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理。</p><h2 id="4-4-防重表"><a href="#4-4-防重表" class="headerlink" title="4.4 防重表"></a>4.4 防重表</h2><p>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。之前说的 redis 防重也算</p><h2 id="4-5-全局请求唯一ID"><a href="#4-5-全局请求唯一ID" class="headerlink" title="4.5 全局请求唯一ID"></a>4.5 全局请求唯一ID</h2><p>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。可以使用 nginx 设置每一个请求的唯一 id；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">proxy_set_header X-Request-Id $request_id;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>方法论</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mongo</title>
    <link href="/2024/02/28/Mongo/"/>
    <url>/2024/02/28/Mongo/</url>
    
    <content type="html"><![CDATA[<h1 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</p><p>在高负载的情况下，添加更多的节点，可以保证服务器性能。</p><p>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><h2 id="1-1-主要特点"><a href="#1-1-主要特点" class="headerlink" title="1.1 主要特点"></a>1.1 主要特点</h2><ul><li>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</li><li>你可以在MongoDB记录中设置任何属性的索引 (如：FirstName&#x3D;”Sameer”,Address&#x3D;”8 Gandhi Road”)来实现更快的排序。</li><li>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li><li>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li><li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li><li>Mongodb中的Map&#x2F;reduce主要是用来对数据进行批量处理和聚合操作。</li><li>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</li><li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</li><li>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</li><li>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li><li>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li><li>MongoDB安装简单</li></ul><h2 id="1-2-MongoDB概念解析"><a href="#1-2-MongoDB概念解析" class="headerlink" title="1.2  MongoDB概念解析"></a>1.2  MongoDB概念解析</h2><p>不管我们学习什么数据库都应该学习其中的基础概念，在mongodb中基本的概念是文档、集合、数据库，下面我们挨个介绍。</p><p>下表将帮助您更容易理解Mongo中的一些概念：</p><table><thead><tr><th>SQL术语&#x2F;概念</th><th>MongoDB术语概念</th><th>解释&#x2F;说明</th></tr></thead><tbody><tr><td>database</td><td>databse</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表&#x2F;集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行&#x2F;文档</td></tr><tr><td>column</td><td>field</td><td>数据库字段&#x2F;域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接， MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键，MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p>通过下图实例，我们也可以更直观的了解Mongo中的一些概念：</p><p><img src="https://i.imgur.com/m7H6Ewr.png" alt="img"></p><h1 id="2-MongoDB-连接"><a href="#2-MongoDB-连接" class="headerlink" title="2. MongoDB 连接"></a>2. MongoDB 连接</h1><blockquote><p>本文建议使用mongo命令进行连接</p></blockquote><p><img src="https://i.imgur.com/KIwvBx0.png" alt="3be8fe49ad683912270fcd513242793"></p><p>连接示例： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongo --host localhsot --username admin --passwod admin123 --port 27017<br></code></pre></td></tr></table></figure><p>由于mongo安装比较简单，推荐使用docker安装，目前我是直接向docker里面起了一个mongo容器，进入容器后使用的mongo，windows安装mongo后可能没有这个命令。</p><h1 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h1><h2 id="3-1-查询数据库"><a href="#3-1-查询数据库" class="headerlink" title="3.1 查询数据库"></a>3.1 查询数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show databases<br>show dbs<br></code></pre></td></tr></table></figure><h2 id="3-2-删除数据库"><a href="#3-2-删除数据库" class="headerlink" title="3.2 删除数据库"></a>3.2 删除数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.dropDatabase()<br></code></pre></td></tr></table></figure><h2 id="3-3-创建集合"><a href="#3-3-创建集合" class="headerlink" title="3.3 创建集合"></a>3.3 创建集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.createCollectction(<span class="hljs-string">&quot;phoenix&quot;</span>)<br></code></pre></td></tr></table></figure><p>当在集合不存在的情况下，直接插入文档，MongoDB会自动创建文档</p><h2 id="3-4-查询集合"><a href="#3-4-查询集合" class="headerlink" title="3.4 查询集合"></a>3.4 查询集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show tables<br>show collections<br></code></pre></td></tr></table></figure><h2 id="3-5-删除集合"><a href="#3-5-删除集合" class="headerlink" title="3.5 删除集合"></a>3.5 删除集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.phoenix.drop()<br></code></pre></td></tr></table></figure><h2 id="3-6-插入文档"><a href="#3-6-插入文档" class="headerlink" title="3.6 插入文档"></a>3.6 插入文档</h2><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.COLLECTION_NAME.insert(document)<br>或<br>db.COLLECTION_NAME.save(document)<br></code></pre></td></tr></table></figure><ul><li>save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。</li><li>insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。</li></ul><p>**3.2 版本之后新增了 db.collection.insertOne() 和 db.collection.insertMany()**。</p><p>db.collection.insertOne() 用于向集合插入一个新文档，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.insertOne(<br>   &lt;document&gt;,<br>   &#123;<br>      writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>db.collection.insertMany() 用于向集合插入一个多个文档，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.insertMany(<br>   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],<br>   &#123;<br>      writeConcern: &lt;document&gt;,<br>      ordered: &lt;boolean&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>document：要写入的文档。</li><li>writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。</li><li>ordered：指定是否按顺序写入，默认 true，按顺序写入。</li></ul><blockquote><p>例子</p></blockquote><p>以下文档可以存储在 MongoDB 的 phoenix 数据库 的 demo集合中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">use phoenix<br>db.demo.insertOne(<span class="hljs-punctuation">&#123;</span><br>desc<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;demo&quot;</span><span class="hljs-punctuation">,</span><br>    by<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;phoenix&quot;</span><span class="hljs-punctuation">,</span><br>    tags<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;demo&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;learn&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;MongoDB&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span>)<br></code></pre></td></tr></table></figure><p>以上实例中 col 是我们的集合名，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。</p><h2 id="3-7-更新文档"><a href="#3-7-更新文档" class="headerlink" title="3.7 更新文档"></a>3.7 更新文档</h2><p>MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。</p><p><strong>update() 方法</strong><br>update() 方法用于更新已存在的文档。语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.update(<br>   &lt;query&gt;,<br>   &lt;update&gt;,<br>   &#123;<br>     upsert: &lt;boolean&gt;,<br>     multi: &lt;boolean&gt;,<br>     writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query : update的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\</li><li>writeConcern :可选，抛出异常的级别。</li></ul><p>更新开始插入phoenix中的数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">db.demo.update(<br>    <span class="hljs-punctuation">&#123;</span>&#x27;desc&#x27;<span class="hljs-punctuation">:</span> &#x27;demo&#x27;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-punctuation">&#123;</span>$set<span class="hljs-punctuation">:</span><br>     <span class="hljs-punctuation">&#123;</span>&#x27;desc&#x27;<span class="hljs-punctuation">:</span>&#x27;MognoDB&#x27;<span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>updateOne、updateMany方法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.collection.updateOne(<br><span class="hljs-operator">&lt;</span>query<span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-operator">&lt;</span><span class="hljs-keyword">update</span><span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-operator">&lt;</span>option<span class="hljs-operator">&gt;</span><br>)<br></code></pre></td></tr></table></figure><p>实际开发过程中可能updateOne和updateMany使用的比较多</p><p>举个例子：可能会遇到字段中包含数组对象的情况，arrayFilter选项可以选择具体是哪个元素（根据条件）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.form.updateMany(<br>&#123;<br>&quot;fieldGroupList.name&quot;: &quot;相对方信息&quot;,<br>&quot;fieldGroupList.fieldList.id&quot;: &#123;<br>            &quot;$eq&quot;: &quot;counterpartyGroup_group&quot;,<br>        &#125;,<br>&#125;,<br>&#123;<br>&quot;$set&quot; : &#123;<br>&quot;fieldGroupList.$[elem].fieldList.$[e]&quot;: &#123;<br>&quot;id&quot;:         &quot;counterpartyGroup_chabaidao&quot;,<br>&quot;name&quot;:       &quot;相对方组&quot;,<br>&quot;type&quot;:       <span class="hljs-number">-32</span>,<br>&quot;isRequired&quot;: <span class="hljs-literal">false</span>,<br>&quot;isFixed&quot;:    <span class="hljs-literal">true</span>,<br>&#125;<br>&#125;<br>&#125;,<br>&#123;<br>&quot;arrayFilters&quot;: [<br>&#123;<br>&quot;elem.name&quot;: &quot;相对方信息&quot;<br>&#125;,<br>&#123;<br>&quot;e.id&quot;: &quot;counterpartyGroup_chabaidao&quot;<br>&#125;<br>]<br>&#125;<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.contract_chabaidao.updateOne(<br>&#123;<br>&quot;contractType.formFields.name&quot;: &quot;相对方信息&quot;,<br>&quot;contractType.formFields.fieldList.name&quot;: &#123;<br>&quot;$in&quot;: [&quot;外部相对方&quot;,&quot;内部相对方&quot;]<br>&#125;,<br>&quot;_id&quot;: ObjectId(&quot;650fd2e1f6c3e755d4d3fca6&quot;)<br>&#125;,<br>&#123;<br>&quot;$pull&quot;: &#123;<br>&quot;contractType.formFields.$[counter].fieldList&quot;: &#123;<br>&quot;name&quot;: &#123;<br>&quot;$in&quot;: [&quot;内部相对方&quot;,&quot;外部相对方&quot;]<br>&#125;<br>&#125;<br>&#125;<br>&#125;,<br>&#123;<br>&quot;arrayFilters&quot;: [&#123;&quot;counter.name&quot;: &quot;相对方信息&quot;&#125;]<br>&#125;<br>)<br></code></pre></td></tr></table></figure><p><strong>save() 方法</strong></p><p>save() 方法通过传入的文档来替换已有文档，_id 主键存在就更新，不存在就插入。语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.save(<br>   &lt;document&gt;,<br>   &#123;<br>     writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>document : 文档数据。</li><li>writeConcern :可选，抛出异常的级别。</li></ul><blockquote><p>例子</p></blockquote><p>以下实例中我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;db.col.save(&#123;<br>    <span class="hljs-string">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;56064f89ade2f21f36b03136&quot;</span>),<br>    <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB&quot;</span>,<br>    <span class="hljs-string">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>,<br>    <span class="hljs-string">&quot;by&quot;</span> : <span class="hljs-string">&quot;Runoob&quot;</span>,<br>    <span class="hljs-string">&quot;tags&quot;</span> : [<br>            <span class="hljs-string">&quot;mongodb&quot;</span>,<br>            <span class="hljs-string">&quot;NoSQL&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;likes&quot;</span> : 110<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-8-删除文档"><a href="#3-8-删除文档" class="headerlink" title="3.8 删除文档"></a>3.8 删除文档</h2><p>MongoDB remove() 函数是用来移除集合中的数据。</p><p>MongoDB 数据更新可以使用 update() 函数。在执行 remove() 函数前先执行 find() 命令来判断执行的条件是否正确，这是一个比较好的习惯。</p><p><strong>语法</strong></p><p>remove() 方法的基本语法格式如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.remove(<br>   &lt;query&gt;,<br>   &lt;justOne&gt;<br>)<br></code></pre></td></tr></table></figure><p>如果你的 MongoDB 是 2.6 版本以后的，语法格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.remove(<br>   &lt;query&gt;,<br>   &#123;<br>     justOne: &lt;boolean&gt;,<br>     writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><p><strong>例子</strong></p><p>以下文档我们执行两次插入操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;db.col.insertOne(&#123;title: <span class="hljs-string">&#x27;MongoDB 教程&#x27;</span>, <br>    description: <span class="hljs-string">&#x27;MongoDB 是一个 Nosql 数据库&#x27;</span>,<br>    tags: [<span class="hljs-string">&#x27;mongodb&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;NoSQL&#x27;</span>],<br>    likes: 100<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用 find() 函数查询数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; db.col.<span class="hljs-function"><span class="hljs-title">find</span></span>()<br>&#123; <span class="hljs-string">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;56066169ade2f21f36b03137&quot;</span>), <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB 教程&quot;</span>, <span class="hljs-string">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>, <span class="hljs-string">&quot;tags&quot;</span> : [ <span class="hljs-string">&quot;mongodb&quot;</span>, <span class="hljs-string">&quot;database&quot;</span>, <span class="hljs-string">&quot;NoSQL&quot;</span> ], <span class="hljs-string">&quot;likes&quot;</span> : 100 &#125;<br>&#123; <span class="hljs-string">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;5606616dade2f21f36b03138&quot;</span>), <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB 教程&quot;</span>, <span class="hljs-string">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>, <span class="hljs-string">&quot;tags&quot;</span> : [ <span class="hljs-string">&quot;mongodb&quot;</span>, <span class="hljs-string">&quot;database&quot;</span>, <span class="hljs-string">&quot;NoSQL&quot;</span> ], <span class="hljs-string">&quot;likes&quot;</span> : 100 &#125;<br></code></pre></td></tr></table></figure><p>移除 title 为 ‘MongoDB 教程’ 的文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;db.col.remove(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB 教程&#x27;</span>&#125;)<br>WriteResult(&#123; <span class="hljs-string">&quot;nRemoved&quot;</span> : 2 &#125;)           <span class="hljs-comment"># 删除了两条数据</span><br>&gt;db.col.find()<br>……                                        <span class="hljs-comment"># 没有数据</span><br></code></pre></td></tr></table></figure><p>如果向删除所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">&gt;db.col.remove(&#123;&#125;)<br></code></pre></td></tr></table></figure><h1 id="4-DSL语句"><a href="#4-DSL语句" class="headerlink" title="4. DSL语句"></a>4. DSL语句</h1><blockquote><p>常用的就那些</p></blockquote><h1 id="5-聚合查询"><a href="#5-聚合查询" class="headerlink" title="5. 聚合查询"></a>5. 聚合查询</h1><p>MongoDB  中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。</p><p>有点类似 <strong>SQL</strong> 语句中的 **count(*)**。</p><h2 id="5-1-aggregate-方法"><a href="#5-1-aggregate-方法" class="headerlink" title="5.1 aggregate 方法"></a>5.1 aggregate 方法</h2><p>MongoDB 中聚合的方法使用aggregate()。</p><p>aggregate() 方法的基本语法格式如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)<br></code></pre></td></tr></table></figure><p>AGGREGATE_OPERATION 详解</p><blockquote><p>示例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.orders.aggregate([<br>  &#123;<br>    $<span class="hljs-keyword">group</span>: &#123;<br>      _id: &quot;$category&quot;,<br>      totalOrders: &#123; $sum: <span class="hljs-number">1</span> &#125;,<br>      averagePrice: &#123; $avg: &quot;$price&quot; &#125;<br>    &#125;<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><p><strong>用法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;<br>  $<span class="hljs-keyword">group</span>: &#123;<br>    _id: <span class="hljs-operator">&lt;</span>expression<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 用于指定分组的依据，可以是字段名或者表达式<br>    field1: &#123; <span class="hljs-operator">&lt;</span>accumulator1<span class="hljs-operator">&gt;</span> : <span class="hljs-operator">&lt;</span>expression1<span class="hljs-operator">&gt;</span> &#125;, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对应于要计算的字段<span class="hljs-number">1</span>的累加器和表达式<br>    field2: &#123; <span class="hljs-operator">&lt;</span>accumulator2<span class="hljs-operator">&gt;</span> : <span class="hljs-operator">&lt;</span>expression2<span class="hljs-operator">&gt;</span> &#125;, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对应于要计算的字段<span class="hljs-number">2</span>的累加器和表达式<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细用法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.orders.aggregate([<br>  &#123;<br>    $<span class="hljs-keyword">match</span>: &#123;<br>      category: &quot;food&quot; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 过滤category字段为&quot;food&quot;的文档<br>    &#125;<br>  &#125;,<br>  &#123;<br>    $<span class="hljs-keyword">group</span>: &#123;<br>      _id: &quot;$category&quot;,<br>      totalOrders: &#123; $sum: <span class="hljs-number">1</span> &#125;,<br>      averagePrice: &#123; $avg: &quot;$price&quot; &#125;<br>    &#125;<br>  &#125;,<br>  &#123;<br>    $sort: &#123; averagePrice: <span class="hljs-number">-1</span> &#125; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 按照平均价格降序排序<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><h3 id="5-1-1-accumulator"><a href="#5-1-1-accumulator" class="headerlink" title="5.1.1 accumulator"></a>5.1.1 accumulator</h3><p>在MongoDB的聚合管道中，累加器（accumulator）是用于对文档进行聚合计算的操作符。累加器操作符允许您在聚合过程中对文档的字段进行累加、平均、最小值、最大值、首个值、最后一个值等操作。以下是一些常用的累加器操作符以及它们的用途：</p><ol><li><p><code>$sum</code>: 对指定字段的值进行求和计算。</p><ul><li>用途：计算某个字段的总和，例如订单金额的总和等。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.locations.aggregate([<br>  &#123;<br>    $<span class="hljs-keyword">group</span>: &#123;<br>      _id: <span class="hljs-keyword">null</span>, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 由于我们希望对整个集合中的文档进行聚合，因此将 _id 设置为 <span class="hljs-keyword">null</span><br>      totalDistance: &#123; $sum: &quot;$distance&quot; &#125;,<br>   count: &#123;$sum: <span class="hljs-number">1</span>&#125;, <span class="hljs-comment">-- 文档数量</span><br>    &#125;<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><p>后续大同小异，类似与Group By</p></li><li><p><code>$avg</code>: 对指定字段的值进行平均计算。</p><ul><li>用途：计算某个字段的平均值，例如订单价格的平均值等。</li></ul></li><li><p><code>$min</code>: 获取指定字段的最小值。</p><ul><li>用途：获取某个字段的最小值，例如订单中的最低价格等。</li></ul></li><li><p><code>$max</code>: 获取指定字段的最大值。</p><ul><li>用途：获取某个字段的最大值，例如订单中的最高价格等。</li></ul></li><li><p><code>$first</code>: 获取每个分组中指定字段的首个值。</p><ul><li>用途：获取每个分组中某个字段的首个值，例如获取每个用户的首次购买时间等。</li></ul></li><li><p><code>$last</code>: 获取每个分组中指定字段的最后一个值。</p><ul><li>用途：获取每个分组中某个字段的最后一个值，例如获取每个用户的最后一次购买时间等。</li></ul></li></ol><h1 id="6-关键字"><a href="#6-关键字" class="headerlink" title="6. 关键字"></a>6. 关键字</h1><h1 id="7-排序"><a href="#7-排序" class="headerlink" title="7. 排序"></a>7. 排序</h1><h1 id="8-索引"><a href="#8-索引" class="headerlink" title="8. 索引"></a>8. 索引</h1><h1 id="9-聚合"><a href="#9-聚合" class="headerlink" title="9. 聚合"></a>9. 聚合</h1><h1 id="10-监控、备份、恢复、分片"><a href="#10-监控、备份、恢复、分片" class="headerlink" title="10. 监控、备份、恢复、分片"></a>10. 监控、备份、恢复、分片</h1>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异步编程</title>
    <link href="/2024/02/24/Java%E5%BC%82%E6%AD%A5/"/>
    <url>/2024/02/24/Java%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java异步"><a href="#Java异步" class="headerlink" title="Java异步"></a>Java异步</h1><h2 id="1-CompletableFuture"><a href="#1-CompletableFuture" class="headerlink" title="1. CompletableFuture"></a>1. CompletableFuture</h2><h3 id="1-1-什么是CompletableFuture"><a href="#1-1-什么是CompletableFuture" class="headerlink" title="1.1 什么是CompletableFuture"></a>1.1 什么是CompletableFuture</h3><p>在Java 8中, 新增加了一个包含50个方法左右的类: CompletableFuture，结合了Future的优点，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p><p>CompletableFuture被设计在Java中进行异步编程。异步编程意味着在主线程之外创建一个独立的线程，与主线程分隔开，并在上面运行一个非阻塞的任务，然后通知主线程进展，成功或者失败。</p><p>通过这种方式，你的主线程不用为了任务的完成而阻塞&#x2F;等待，你可以用主线程去并行执行其他的任务。 使用这种并行方式，极大地提升了程序的表现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mark">当一个Future可能需要显示地完成时，使用CompletionStage接口去支持完成时触发的函数和操作。<br>当2个以上线程同时尝试完成、异常完成、取消一个CompletableFuture时，只有一个能成功。<br><br>CompletableFuture实现了CompletionStage接口的如下策略：<br><br>1.为了完成当前的CompletableFuture接口或者其他完成方法的回调函数的线程，提供了非异步的完成操作。<br><br>2.没有显式入参Executor的所有async方法都使用ForkJoinPool.commonPool()为了简化监视、调试和跟踪，<br>    所有生成的异步任务都是标记接口AsynchronousCompletionTask的实例。<br><br>3.所有的CompletionStage方法都是独立于其他共有方法实现的，因此一个方法的行为不会受到子类中其他<br>    方法的覆盖。<br><br>CompletableFuture实现了Futurre接口的如下策略：<br><br>1.CompletableFuture无法直接控制完成，所以cancel操作被视为是另一种异常完成形式。<br>    方法isCompletedExceptionally可以用来确定一个CompletableFuture是否以任何异常的方式完成。<br><br>2.以一个CompletionException为例，方法get()和get(long,TimeUnit)抛出一个ExecutionException，<br>    对应CompletionException。为了在大多数上下文中简化用法，这个类还定义了方法join()和getNow，<br>    而不是直接在这些情况中直接抛出CompletionException。<br></code></pre></td></tr></table></figure><h3 id="1-2-CompletableFuture-API"><a href="#1-2-CompletableFuture-API" class="headerlink" title="1.2 CompletableFuture API"></a>1.2 CompletableFuture API</h3><h4 id="1-2-1-实例化CompletableFuture"><a href="#1-2-1-实例化CompletableFuture" class="headerlink" title="1.2.1 实例化CompletableFuture"></a>1.2.1 实例化CompletableFuture</h4><p>实例化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span>;<br></code></pre></td></tr></table></figure><p>有两种格式，一种是supply开头的方法，一种是run开头的方法</p><ul><li>supply开头：这种方法，可以返回异步线程执行之后的结果</li><li>run开头：这种不会返回结果，就只是执行线程任务</li></ul><p>或者可以通过一个简单的无参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; completableFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>tips</p></blockquote><p>我们注意到，在实例化方法中，我们是可以指定Executor参数的，当我们不指定的话，我们所开的并行线程使用的是默认系统及公共线程池ForkJoinPool，而且这些线程都是守护线程。我们在编程的时候需要谨慎使用守护线程，如果将我们普通的用户线程设置成守护线程，当我们的程序主线程结束，JVM中不存在其余用户线程，那么CompletableFuture的守护线程会直接退出，造成任务无法完成的问题，其余的包括守护线程阻塞问题我就不在本篇赘述。</p><p>Java8实战：</p><p>其中supplyAsync用于有返回值的任务，runAsync则用于没有返回值的任务。Executor参数可以手动指定线程池，否则默认ForkJoinPool.commonPool()系统级公共线程池，注意：这些线程都是Daemon线程，主线程结束Daemon线程不结束，只有JVM关闭时，生命周期终止</p><h3 id="1-3-获取结果"><a href="#1-3-获取结果" class="headerlink" title="1.3 获取结果"></a>1.3 获取结果</h3><p>同步获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">get</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">getNow</span><span class="hljs-params">(T valueIfAbsent)</span><br><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">join</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">CompletableFuture&lt;Integer&gt; future = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> future.get();<br></code></pre></td></tr></table></figure><p><strong>get()</strong> 方法同样会阻塞直到任务完成，上面的代码，主线程会一直阻塞，因为这种方式创建的future从未完成。有兴趣的小伙伴可以打个断点看看，状态会一直是not completed</p><p>前两个方法比较通俗易懂，认真看完上面Future部分的小伙伴肯定知道什么意思。 getNow() 则有所区别，参数valueIfAbsent的意思是当计算结果不存在或者Now时刻没有完成任务，给定一个确定的值。</p><p>join() 与get() 区别在于join() 返回计算的结果或者抛出一个unchecked异常(CompletionException)，而get() 返回一个具体的异常.</p><h3 id="1-4-计算完成后序操作1-complete"><a href="#1-4-计算完成后序操作1-complete" class="headerlink" title="1.4 计算完成后序操作1-complete"></a>1.4 计算完成后序操作1-complete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">whenComplete</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> Throwable&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> Throwable&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> Throwable&gt; action, Executor executor)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">exceptionally</span><span class="hljs-params">(Function&lt;Throwable,? extends T&gt; fn)</span><br></code></pre></td></tr></table></figure><p>方法1和2的区别在于是否使用异步处理，2和3的区别在于是否使用自定义的线程池，前三个方法都会提供一个返回结果和可抛出异常，我们可以使用lambda表达式的来接收这两个参数，然后自己处理。 方法4，接收一个可抛出的异常，且必须return一个返回值，类型与钻石表达式中的类型一样，详见下文的exceptionally() 部分，更详细</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(<br>    () -&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10086</span>;<br>    &#125;);<br>future.whenComplete(<br>    (result, error) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;拨打&quot;</span>+result);<br>        error.printStackTrace();<br>     &#125;);<br></code></pre></td></tr></table></figure><h3 id="1-5-计算完成后序操作2-handle"><a href="#1-5-计算完成后序操作2-handle" class="headerlink" title="1.5 计算完成后序操作2-handle"></a>1.5 计算完成后序操作2-handle</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
