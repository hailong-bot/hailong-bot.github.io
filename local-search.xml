<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>k8s</title>
    <link href="/2025/03/03/k8s/"/>
    <url>/2025/03/03/k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node 节点上可以运行多个 Pod</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>一个Node节点上可以运行多个pod，pod是k8s中最小的调度单元，一个pod就是一个应用或则多个应用的容器的组合。<strong>在pod中容器可以共享资源</strong>。</p><p>一般一个pod只会存放一个容器，除非容器之间存在高度耦合的情况。比如 SideCar</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><blockquote><p>在 Kubernetes 中，<strong>Service</strong> 是一个抽象层，用于定义一组 Pod 的访问策略和网络端点。Service 的主要目的是为 Pod 提供稳定的网络地址（IP 和 DNS 名称），并实现负载均衡，使得客户端可以通过 Service 访问后端的 Pod，而不需要直接与 Pod 交互。简称svc</p></blockquote><h5 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h5><ol><li><strong>稳定的网络端点</strong>:<ul><li>Service 为 Pod 提供一个稳定的 IP 地址和 DNS 名称，即使 Pod 的 IP 地址发生变化（例如 Pod 重启或重新调度），Service 的 IP 和 DNS 名称仍然保持不变。</li></ul></li><li><strong>负载均衡</strong>:<ul><li>Service 可以将流量均匀地分发到后端的多个 Pod 上，从而实现负载均衡。</li></ul></li><li><strong>服务发现</strong>:<ul><li>Service 通过 DNS 名称提供服务发现功能，其他应用可以通过 Service 的名称访问后端 Pod。</li></ul></li><li><strong>支持多种访问模式</strong>:<ul><li>Service 支持多种访问模式，如集群内部访问（ClusterIP）、外部访问（NodePort、LoadBalancer）等。</li></ul></li></ol><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>Kubernetes 提供了多种类型的 Service，以满足不同的使用场景：</p><ol><li><strong>ClusterIP</strong>（默认类型）:<ul><li>为 Service 分配一个集群内部的 IP 地址，只能在集群内部访问。</li><li>适用于集群内部的服务通信。</li></ul></li><li><strong>NodePort</strong>:<ul><li>在 ClusterIP 的基础上，为每个节点（Node）分配一个静态端口（NodePort），外部客户端可以通过 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 访问 Service。</li><li>NodePort 的范围默认是 30000-32767。</li></ul></li><li><strong>LoadBalancer</strong>:<ul><li>在 NodePort 的基础上，通过云服务提供商（如 AWS、GCP、Azure）创建一个外部负载均衡器，并将流量转发到 Service。</li><li>适用于需要从外部访问的场景。</li></ul></li><li><strong>ExternalName</strong>:<ul><li>将 Service 映射到一个外部 DNS 名称（例如外部数据库或服务），而不是集群内部的 Pod。</li><li>适用于将集群内部服务与外部服务集成。</li></ul></li></ol><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>在 Kubernetes 中，<strong>Ingress</strong> 是一种用于管理外部访问集群内服务的 API 对象。它主要提供 HTTP&#x2F;HTTPS 路由功能，允许将外部流量路由到集群内部的服务（Service）。与 Service 不同，Ingress 工作在应用层（L7），支持基于主机名（host）和路径（path）的路由规则</p><h4 id="Ingress-的核心功能"><a href="#Ingress-的核心功能" class="headerlink" title="Ingress 的核心功能"></a>Ingress 的核心功能</h4><ol><li><strong>HTTP&#x2F;HTTPS 路由</strong>:<ul><li>根据请求的主机名和路径将流量路由到不同的后端服务。</li></ul></li><li><strong>负载均衡</strong>:<ul><li>提供应用层的负载均衡功能，将流量分发到多个后端 Pod。</li></ul></li><li><strong>TLS 终止</strong>:<ul><li>支持 HTTPS 流量，并可以在 Ingress 层面终止 TLS&#x2F;SSL 连接。</li></ul></li><li><strong>基于名称的虚拟主机</strong>:<ul><li>支持基于主机名的路由，允许多个域名共享同一个 IP 地址。</li></ul></li></ol><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><h3 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h3><h3 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h3><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><h2 id="k8s-架构"><a href="#k8s-架构" class="headerlink" title="k8s 架构"></a>k8s 架构</h2><h3 id="Master-组件"><a href="#Master-组件" class="headerlink" title="Master 组件"></a>Master 组件</h3><p>Master 组件负责集群的全局决策（如调度）以及检测和响应集群事件。</p><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a><strong>kube-apiserver</strong></h4><p>Kubernetes API 服务器，是集群的前端接口，所有组件都通过它与集群进行通信, 提供 RESTful API，用于与集群进行交互。相当于网关。</p><p>在提供api服务接口之外，apiserver还负责对所有资源对象的增、删、改、查等操作进行认证、授权和访问控制。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a><strong>etcd</strong></h4><p>会存放集群中各种对象的状态</p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a><strong>kube-scheduler</strong></h4><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a><strong>kube-controller-manager</strong></h4><p>监控集群中各种资源对象的状态，根据状态来进行相应，会根据etcd来进行判断</p><h4 id="cloud-controller-manager-可选"><a href="#cloud-controller-manager-可选" class="headerlink" title="cloud-controller-manager (可选)"></a><strong>cloud-controller-manager</strong> (可选)</h4><h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h3><h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h2><p>直接与api-server 进行交互</p><h2 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h2><p>在本地搭建一个简易的环境</p><h2 id="k3s"><a href="#k3s" class="headerlink" title="k3s"></a>k3s</h2>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚手架</title>
    <link href="/2025/02/10/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <url>/2025/02/10/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h1><p>在我们的现实生活中，脚手架最常用的使用场景是在工地，它是为了保证施工顺利的、方便的进行而搭建的，在工地上搭建的脚手架可以帮助工人们高校的去完成工作，同时在大楼建设完成后，拆除脚手架并不会有任何的影响。</p><p>在我们的 React 项目中，脚手架的作用与之有异曲同工之妙</p><p>React 脚手架其实是一个工具帮我们快速的生成项目的工程化结构，每个项目的结构其实大致都是相同的，所以 React 给我提前的搭建好了，这也是脚手架强大之处之一，也是用 React 创建 SPA 应用的最佳方式</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><p>首先确保安装了 <code>npm</code> 和<code>Node</code>，版本不要太古老，具体是多少不大清楚，建议还是用 <code>npm update</code> 更新一下（笔者使用node 18.3）</p><p>然后打开命令行工具，全局安装 <code>create-react-app</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i create-react-app -g<br></code></pre></td></tr></table></figure><p>然后可以<strong>新建</strong>一个文件夹用于存放项目</p><p>在当前的文件夹下执行<strong>快速搭建项目</strong></p><p>再在生成好的 <code>hello-react</code> 文件夹中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">create-react-app hello-react<br></code></pre></td></tr></table></figure><p><strong>快速搭建项目</strong></p><p>再在生成好的 <code>hello-react</code> 文件夹中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm start<br></code></pre></td></tr></table></figure><p><strong>启动项目</strong></p><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">hello-react<br>├─ <span class="hljs-selector-class">.gitignore</span>               // 自动创建本地仓库<br>├─ package<span class="hljs-selector-class">.json</span>             // 相关配置文件<br>├─ public                   // 公共资源<br>│  ├─ favicon<span class="hljs-selector-class">.ico</span>           // 浏览器顶部的<span class="hljs-attribute">icon</span>图标<br>│  ├─ index<span class="hljs-selector-class">.html</span>            // 应用的 index<span class="hljs-selector-class">.html</span>入口<br>│  ├─ logo192<span class="hljs-selector-class">.png</span>           // 在 manifest 中使用的logo图<br>│  ├─ logo512<span class="hljs-selector-class">.png</span>           // 同上<br>│  ├─ manifest<span class="hljs-selector-class">.json</span>         // 应用加壳的配置文件<br>│  └─ robots<span class="hljs-selector-class">.txt</span>            // 爬虫给协议文件<br>├─ <span class="hljs-attribute">src</span>                      // 源码文件夹<br>│  ├─ App<span class="hljs-selector-class">.css</span>               // App组件的样式<br>│  ├─ App<span class="hljs-selector-class">.js</span>                // App组件<br>│  ├─ App<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.js</span>           // 用于给APP做测试<br>│  ├─ index<span class="hljs-selector-class">.css</span>             // 样式<br>│  ├─ index<span class="hljs-selector-class">.js</span>              // 入口文件<br>│  ├─ logo<span class="hljs-selector-class">.svg</span>              // logo图<br>│  ├─ reportWebVitals<span class="hljs-selector-class">.js</span>    // 页面性能分析文件<br>│  └─ setupTests<span class="hljs-selector-class">.js</span>         // 组件单元测试文件<br>└─ yarn<span class="hljs-selector-class">.lock</span><br></code></pre></td></tr></table></figure><h3 id="第一个脚手架应用"><a href="#第一个脚手架应用" class="headerlink" title="第一个脚手架应用"></a>第一个脚手架应用</h3><ol><li><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br><br></code></pre></td></tr></table></figure></li><li><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>))<br><br>root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="推荐层级结构"><a href="#推荐层级结构" class="headerlink" title="推荐层级结构"></a>推荐层级结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── README.md<br>├── package.json<br>├── public<br>│   ├── favicon.ico<br>│   ├── index.html<br>│   ├── logo192.png<br>│   ├── logo512.png<br>│   ├── manifest.json<br>│   └── robots.txt<br>├── src<br>│   ├── App.js<br>│   ├── components<br>│   │   ├── Hello<br>│   │   │   ├── index.js<br>│   │   │   └── index.module.css<br>│   │   └── Welcome<br>│   │       ├── index.css<br>│   │       └── index.js<br>│   └── index.js<br>└── yarn.lock<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态提升</title>
    <link href="/2025/02/10/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/"/>
    <url>/2025/02/10/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><p>所谓 <strong>状态提升</strong> 就是将各个子组件的 公共state 提升到它们的父组件进行统一存储、处理（这就是所谓的”单一数据源“），负责<code>setState</code>的函数传到下边的子级组件，然后再将父组件处理后的数据或函数props到各子组件中。</p><p>那么如果子组件 要 修改父组件的state该怎么办呢？我们的做法就是 将父组件中负责setState的函数，以props的形式传给子组件，然后子组件在需要改变state时调用即可。</p><p><strong>实现方式</strong></p><p>实现方式是 利用最近的共同的父级组件中，用props的方式传过去到两个子组件，props中传的是一个setState的方法，通过子组件触发props传过去的方法，进而调用父级组件的setState的方法，改变了父级组件的state，调用父级组件的render方法，进而同时改变了两个子级组件的render。</p><p>这是 两个有关连的同级组件的传值，因为react的单项数据流，所以不在两个组件中进行传值，而是提升到 最近的共同的父级组件中，改变父级的state,进而影响了两个子级组件的render。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先写一个温度输入组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">temperature</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;;<br>    handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            temperature : e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>        &#125;)<br>    &#125;;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>输入&#123;scaleNames[this.props.scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.temperature&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &lt;/<span class="hljs-attr">fieldset</span>&gt;</span></span><br><span class="language-xml">        )</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>这个组件就是一个普通的<strong>受控组件</strong>，有<code>state</code>和<code>props</code>以及处理函数。</p><p>我们在写另一个组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    render () &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&#x27;c&#x27;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&#x27;f&#x27;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个组件现在没有什么存在的价值，我们仅仅是给两个温度输入组件提供一个父组件，以便我们进行后续的<strong>状态提升</strong>。</p><p>现在我们看看网页的样子：</p><p><img src="https://i.imgur.com/hPlkbKQ.png" alt="image-20250210233240377"></p><p>我们可以输入摄氏度和华氏度，但是我们现在想要让这两个温度保持一致，就是我们如果输入摄氏度，那么下面的华氏度可以自动算出来，如果我们输入华氏度，那么摄氏度就可以自动算出来。</p><p>那么我们按照现在这种结构的话，是非常难以实现的，因为我们知道这两个组件之间没有任何关系，它们之间是不知道对方的存在，所以我们需要把它们的状态进行提升，提升到它们的父组件当中。</p><p>那我们看看如何做修改，首先把子组件（温度输入组件）的状态（state）全部删除，看看是什么样子:</p><p>最终通过<code>非控组件</code>实现的样子就是</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 摄氏度转华氏度</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toFahrenheit</span>(<span class="hljs-params">celsius</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">parseFloat</span>(celsius) * <span class="hljs-number">9</span> / <span class="hljs-number">5</span>) + <span class="hljs-number">32</span>;<br>&#125;<br><br><span class="hljs-comment">// 华氏度转摄氏度</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toCelsius</span>(<span class="hljs-params">fahrenheit</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">parseFloat</span>(fahrenheit) - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>;<br>&#125;<br><br><span class="hljs-comment">// tryConvert函数：用于处理转换逻辑</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tryConvert</span>(<span class="hljs-params">value, convert</span>) &#123;<br>    <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">parseFloat</span>(value);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(input)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">convert</span>(input).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 保留两位小数</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> scaleNames = &#123;<br>            <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;摄氏度&#x27;</span>,<br>            <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-string">&#x27;华氏度&#x27;</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>输入&#123;scaleNames[this.props.scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.props.temperature&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;/</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">onTemperatureChange</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">celsius</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">fahrenheit</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;;<br><br>    onCelsiusChange = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">celsius</span>: value,<br>            <span class="hljs-attr">fahrenheit</span>: <span class="hljs-title function_">tryConvert</span>(value, toFahrenheit)<br>        &#125;);<br>    &#125;;<br><br>    onFahrenheitChange = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">celsius</span>: <span class="hljs-title function_">tryConvert</span>(value, toCelsius),<br>            <span class="hljs-attr">fahrenheit</span>: value<br>        &#125;);<br>    &#125;;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-attr">temperature</span>=<span class="hljs-string">&#123;this.state.celsius&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                                  <span class="hljs-attr">onTemperatureChange</span>=<span class="hljs-string">&#123;this.onCelsiusChange&#125;/</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-attr">temperature</span>=<span class="hljs-string">&#123;this.state.fahrenheit&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                                  <span class="hljs-attr">onTemperatureChange</span>=<span class="hljs-string">&#123;this.onFahrenheitChange&#125;/</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Calculator</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生命周期</title>
    <link href="/2025/01/28/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2025/01/28/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>组件从创建到死亡，会经过一些特定的阶段</p><p>React组件中包含一系列钩子函数{生命周期回调函数}，会在特定的时刻调用</p><p>我们在定义组件的时候，会在特定的声明周期回调函数中，做特定的工作</p><p>在 React 中为我们提供了一些生命周期钩子函数，让我们能在 React 执行的重要阶段，在钩子函数中做一些事情。那么在 React 的生命周期中，有哪些钩子函数呢，我们来总结一下</p><p><strong>react生命周期(旧)</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">1.</span> 初始化阶段: 由ReactDOM.render()触发---初次渲染<br><span class="hljs-bullet">                    1.</span>constructor()<br><span class="hljs-bullet">                    2.</span>componentWillMount()<br><span class="hljs-bullet">                    3.</span>render()<br><span class="hljs-bullet">                    4.</span>componentDidMount() =====&gt; 常用<br><span class="hljs-code">                        一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span><br><span class="hljs-code">2. 更新阶段: 由组件内部this.setSate()或父组件render触发</span><br><span class="hljs-code">                    1.shouldComponentUpdate()</span><br><span class="hljs-code">                    2.componentWillUpdate()</span><br><span class="hljs-code">                    3.render() =====&gt; 必须使用的一个</span><br><span class="hljs-code">                    4.componentDidUpdate()</span><br><span class="hljs-code">3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发</span><br><span class="hljs-code">                    1.componentWillUnmount()  =====&gt; 常用</span><br><span class="hljs-code">                        一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/hfGPjX5.png" alt="image-20250128150711851"></p><p>在最新的react版本中，有些生命周期钩子被抛弃了，具体函数如下：</p><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li></ul><p>这些生命周期方法经常被误解和滥用；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。）</p><p>由此可见，新版本中并不推荐持有这三个函数，取而代之的是带有UNSAFE_ 前缀的三个函数，比如: UNSAFE_ componentWillMount。即便如此，其实React官方还是不推荐大家去使用，在以后版本中有可能会去除这几个函数。</p><p><strong>react生命周期(新)</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">1.</span> 初始化阶段: 由ReactDOM.render()触发---初次渲染<br><span class="hljs-bullet">                1.</span>constructor()<br><span class="hljs-bullet">                2.</span>getDerivedStateFromProps <br><span class="hljs-bullet">                3.</span>render()<br><span class="hljs-bullet">                4.</span>componentDidMount() =====&gt; 常用<br><span class="hljs-code">                一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span><br><span class="hljs-code">2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发</span><br><span class="hljs-code">                1.getDerivedStateFromProps</span><br><span class="hljs-code">                2.shouldComponentUpdate()</span><br><span class="hljs-code">                3.render()</span><br><span class="hljs-code">                4.getSnapshotBeforeUpdate</span><br><span class="hljs-code">                5.componentDidUpdate()</span><br><span class="hljs-code">3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发</span><br><span class="hljs-code">                1.componentWillUnmount()  =====&gt; 常用</span><br><span class="hljs-code">                一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/YUr6LbP.png" alt="image-20250128151159128"></p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><strong>在组件实例被创建并插入到dom中时，生命周期调用顺序如下</strong></p><p><strong>旧生命周期：</strong></p><ol><li>constructor（props）</li><li>componentWillMount（）————-可以用但是不建议使用</li><li>render（）</li><li>componentDidMount（）</li></ol><p><strong>新生命周期：</strong></p><ol><li>constructor（props）</li><li><code>static getDerivedStateFromProps（props，state）</code>–替代了<code>componentWillReceiveProps</code></li><li>render（）</li><li>componentDidMount（）</li></ol><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p><strong>数据的初始化。</strong></p><p>接收props和context，当想在函数内使用这两个参数需要在super传入参数，当使用constructor时必须使用super，否则可能会有this的指向问题，如果不初始化state或者不进行方法绑定，则可以不为组件实现构造函数；</p><p>避免将 props 的值复制给 state！这是一个常见的错误：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br> <span class="hljs-variable language_">super</span>(props);<br> <span class="hljs-comment">// 不要这样做</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">color</span>: props.<span class="hljs-property">color</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如此做毫无必要（可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A&#x27;</span><br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;this.state.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">B</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&#123;this.state.name&#125;/</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fnChangeName&#125;</span>&gt;</span>修改名称<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    fnChangeName = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击成功&quot;</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Change A&#x27;</span><br>        &#125;))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">name</span>: props.<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>B&#x27;s name:&#123;this.state.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">A</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>现在我们通常不会使用 <code>constructor</code> 属性，而是改用类加箭头函数的方法，来替代 <code>constructor</code></p><p>例如，我们可以这样初始化 <code>state</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">state = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><del>componentWillMount</del></h3><blockquote><p>将要被删除</p></blockquote><p><strong>该方法只在挂载的时候调用一次，表示组件将要被挂载，并且在 <code>render</code> 方法之前调用。</strong></p><p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code></p><p> 在服务端渲染唯一会调用的函数，代表已经初始化数据但是没有渲染dom，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。</p><p><strong>这个方法在 React 18版本中将要被废弃，官方解释是在 React 异步机制下，如果滥用这个钩子可能会有 Bug</strong></p><h3 id="static-getDerivedStateFromProps-–-新钩子"><a href="#static-getDerivedStateFromProps-–-新钩子" class="headerlink" title="static getDerivedStateFromProps – 新钩子"></a>static getDerivedStateFromProps – 新钩子</h3><blockquote><p> <strong>从props获取state。</strong></p><p>注意：<code>state</code> 的值在任何时候都取决于传入的 <code>props</code> ，不会再改变</p></blockquote><p>替代了<code>componentWillReceiveProps，</code>此方法适用于<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state">罕见的用例</a>，即 state 的值在任何时候都取决于 props。</p><p>这个是 React 新版本中新增的2个钩子之一，据说很少用。</p><ol><li>首先，该函数会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用；</li><li>该函数必须是静态的；</li><li>给组件传递的数据（props）以及组件状态（state），会作为参数到这个函数中；</li><li>该函数也必须有返回值，返回一个Null或者state对象。因为初始化和后续更新都会执行这个方法，因此在这个方法返回state对象，就相当于将原来的state进行了覆盖，所以倒是修改状态不起作用。</li></ol><p>如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Count</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&quot;109&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.test&#x27;</span>))<br></code></pre></td></tr></table></figure><p><code>count</code> 的值不会改变，一直是 109</p><p><a href="https://www.jianshu.com/p/b331d0e4b398">React的生命周期 - 简书</a></p><p>老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。</p><p>这两者最大的不同就是: 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。</p><ol><li>在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。</li><li>而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。</li></ol><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><blockquote><p><strong>class组件中唯一必须实现的方法。</strong></p><p>避免在 <code>render</code> 中使用 <code>setState</code> ，否则会死循环</p></blockquote><p>当render被调用时，他会检查this.props.和this.state的变化并返回以下类型之一：</p><ol><li>通过jsx创建的react元素</li><li>数组或者fragments：使得render可以返回多个元素</li><li>Portals:可以渲染子节点到不同的dom树上</li><li>字符串或数值类型：他们在dom中会被渲染为文本节点</li><li>布尔类型或者null：什么都不渲染</li></ol><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p><strong>在组件挂在后（插入到dom树中）后立即调用</strong></p><p><code>componentDidMount</code> 的执行意味着初始化挂载操作已经基本完成，它主要用于组件挂载完成后做某些操作</p><p>这个挂载完成指的是：组件插入 DOM tree</p><p> 可以在这里调用Ajax请求，返回的数据可以通过setState使组件重新渲染，或者添加订阅，但是要在conponentWillUnmount中取消订阅</p><h3 id="初始化阶段总结"><a href="#初始化阶段总结" class="headerlink" title="初始化阶段总结"></a>初始化阶段总结</h3><p>执行顺序 <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> 或者 <code>componentWillMount</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code></p><p><img src="https://i.imgur.com/d4DzWbw.png" alt="image-20221023223048451"></p><h2 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h2><p><strong>当组件的 props 或 state 发生变化时会触发更新。</strong></p><p><strong>旧生命周期：</strong></p><ol><li>componentWillReceiveProps (nextProps)——————可以用但是不建议使用</li><li>shouldComponentUpdate（nextProps,nextState）</li><li>componetnWillUpdate（nextProps,nextState）—————-可以用但是不建议使用</li><li>render（）</li><li>componentDidUpdate（prevProps,precState,snapshot）</li></ol><p><strong>新生命周期：</strong></p><ol><li>static getDerivedStateFromProps（nextProps, prevState）</li><li>shouldComponentUpdate（nextProps,nextState）</li><li>render（）</li><li>getSnapshotBeforeUpdate（prevProps,prevState）</li><li>componentDidUpdate（prevProps,precState,snapshot）</li></ol><h3 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><del>componentWillReceiveProps</del></h3><p><strong>在已挂载的组件接收新的props之前调用。</strong></p><p>通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件，可以在此方法中使用this.setState改变state。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">componentWillReceiveProps (nextProps) &#123;<br>    nextProps.<span class="hljs-property">openNotice</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">openNotice</span>&amp;&amp;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">openNotice</span>:nextProps.<span class="hljs-property">openNotice</span><br>    &#125;，() =&gt; &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">openNotice</span>:nextProps)<br>      <span class="hljs-comment">//将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。</p><p>React 不会针对初始 props 调用 UNSAFE_componentWillReceiveProps()。组件只会在组件的 props 更新时调用此方法。调用 this.setState() 通常不会触发该生命周期。</p></blockquote><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>在渲染之前被调用，默认返回为true。</p><p> 返回值是判断组件的输出是否受当前state或props更改的影响，默认每次state发生变化都重新渲染，首次渲染或使用forceUpdate(使用<code>this.forceUpdate()</code>)时不被调用。</p><blockquote><p>他主要用于性能优化，会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。不建议深层比较，会影响性能。如果返回false，则不会调用componentWillUpdate、render和componentDidUpdate</p></blockquote><ul><li>唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新，但是不建议，建议使用 PureComponent</li><li>因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li></ul><h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><del>componentWillUpdate</del></h3><p><strong>当组件接收到新的props和state会在渲染前调用，初始渲染不会调用该方法。</strong></p><p> shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate，不能在这使用setState，在函数返回之前不能执行任何其他更新组件的操作</p><blockquote><p>此方法可以替换为 <code>componentDidUpdate()</code>。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 <code>getSnapshotBeforeUpdate()</code> 中。</p></blockquote><h3 id="getSnapshotBeforeUpdate-–-新钩子"><a href="#getSnapshotBeforeUpdate-–-新钩子" class="headerlink" title="getSnapshotBeforeUpdate – 新钩子"></a>getSnapshotBeforeUpdate – 新钩子</h3><p><strong>在最近一次的渲染输出之前被提交之前调用，也就是即将挂载时调用，替换componetnWillUpdate。</strong></p><p>相当于淘宝购物的快照，会保留下单前的商品内容，在 React 中就相当于是 即将更新前的状态</p><p>它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 <code>componentDidUpdate()</code>。如不需要传递任何值，那么请返回 null</p><blockquote><p>和componentWillUpdate的区别</p><ul><li>在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。</li><li>getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。</li></ul></blockquote><p> 使用场景</p><p>在一个区域内，定时的输出以行话，如果内容大小超过了区域大小，就出现滚动条，但是内容不进行移动</p><p><img src="https://i.imgur.com/DZg2yZx.gif" alt="BeforeGender"></p><p>上面的动图：区域内部的内容展现没有变化，但是可以看见滚动条在变化，也就是说上面依旧有内容在输出，只不过不在这个区域内部展现。</p><ol start="2"><li>接下来就是控制滚动条了</li></ol><p>​我们在组件渲染到DOM之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p><ol><li><p>首先我们先实现定时输出内容</p><p>我们可以使用state状态，改变新闻后面的值，但是为了同时显示这些内容，我们应该为state的属性定义一个数组。并在创建组件之后开启一个定时器，不断的进行更新state。更新渲染组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">New</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>   <br>       state = &#123;<span class="hljs-attr">num</span>:[]&#125;;<br>   <br>       <span class="hljs-comment">//在组件创建之后,开启一个定时任务</span><br>       <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>               <span class="hljs-keyword">let</span> &#123;num&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>               <span class="hljs-keyword">const</span> news = (num.<span class="hljs-property">length</span>+<span class="hljs-number">1</span>);<br>               <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">num</span>:[news,...num]&#125;);<br>           &#125;,<span class="hljs-number">2000</span>);<br>       &#125;<br>   <br>       <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">return</span> (<br>               <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">className</span> = <span class="hljs-string">&quot;list&quot;</span>&gt;</span>&#123;</span><br><span class="language-xml">                   this.state.num.map((n,index)=&gt;&#123;</span><br><span class="language-xml">                   return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;news&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> &gt;</span>新闻&#123;n&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                   &#125;)</span><br><span class="language-xml">               &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>           )<br>       &#125;<br> &#125;<br> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">New</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>接下来就是控制滚动条了</p><p>我们在组件渲染到DOM之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span>;<br>&#125;<br><br><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">preProps,preState,height</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollTop</span> += (<span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span> - height);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><p><strong>组件在更新完毕后会立即被调用，首次渲染不会调用</strong></p><p>可以在该方法调用setState，但是要包含在条件语句中，否则一直更新会造成死循环。</p><p>当组件更新后，可以在此处对 DOM 进行操作。如果对更新前后的props进行了比较，可以进行网络请求。（当 props 未发生变化时，则不会执行网络请求）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">componentDidUpdate(prevProps,prevState,snapshotValue) &#123;<br>  <span class="hljs-comment">// 典型用法（不要忘记比较 props）：</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.userID !== prevProps.userID) &#123;<br>    <span class="hljs-keyword">this</span>.fetchData(<span class="hljs-keyword">this</span>.props.userID);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果组件实现了 <code>getSnapshotBeforeUpdate()</code> 生命周期（不常用），则它的返回值将作为 <code>componentDidUpdate()</code> 的第三个参数 “snapshotValue” 参数传递。否则此参数将为 undefined。如果返回false就不会调用这个函数。</p></blockquote><p>这样就实现了这个功能。</p><h2 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h2><p><strong>当组件从 DOM中移除时会调用如下方法</strong></p><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p><strong>在组件卸载和销毁之前调用</strong></p><blockquote><p>使用这样的方式去卸载<code>ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))</code></p></blockquote><p> 在这执行必要的清理操作，例如，清除timer（setTimeout,setInterval），取消网络请求，或者取消在componentDidMount的订阅，移除所有监听</p><p>有时候我们会碰到这个warning:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Can only update a mounted<span class="hljs-built_in"> or </span>mounting component. This usually means you called setState() on an unmounted component. This is a   no-op. Please<span class="hljs-built_in"> check </span>the code for the undefined component.<br></code></pre></td></tr></table></figure><p>原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning</p><p>解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isMount</span> === <span class="hljs-literal">true</span><br>    axios.<span class="hljs-title function_">post</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isMount</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;   <span class="hljs-comment">// 增加条件ismount为true时</span><br>      <span class="hljs-attr">aaa</span>:res<br>    &#125;)<br>&#125;)<br>&#125;<br><span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isMount</span> === <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件处理</title>
    <link href="/2025/01/27/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E4%BA%8B%E4%BB%B6/"/>
    <url>/2025/01/27/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><blockquote><p>React的事件是通过onXxx属性指定事件处理函数</p><p>React 使用的是自定义事件，而不是原生的 DOM 事件</p><p>React 的事件是通过事件委托方式处理的（为了更加的高效）</p><p>可以通过事件的 <code>event.target</code>获取发生的 DOM 元素对象，可以尽量减少 <code>refs</code>的使用</p><p>事件中必须返回的是函数</p></blockquote><h2 id="React-事件"><a href="#React-事件" class="headerlink" title="React 事件"></a>React 事件</h2><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li><li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li></ul><p>例如，传统的 HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;activateLasers()&quot;</span>&gt;</span><br>  Activate Lasers<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 React 中略微不同：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;activateLasers&#125;&gt;  <br>   <span class="hljs-title class_">Activate</span> <span class="hljs-title class_">Lasers</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式地使用 <code>preventDefault</code>。例如，传统的 HTML 中阻止表单的默认提交行为，你可以这样写：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;form onsubmit=<span class="hljs-string">&quot;console.log(&#x27;You clicked submit.&#x27;); return false&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>在 React 中，可能是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;You clicked submit.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>e</code> 是一个合成事件。React 根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。如果想了解更多，请查看 <a href="https://zh-hans.reactjs.org/docs/events.html"><code>SyntheticEvent</code></a> 参考指南。</p><p>使用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。</p><h3 id="类式组件绑定事件"><a href="#类式组件绑定事件" class="headerlink" title="类式组件绑定事件"></a>类式组件绑定事件</h3><p>当你使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">isToggleOn</span>: <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">                &#123;this.state.isToggleOn?&#x27;ON&#x27;: &#x27;OFF&#x27;&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>            <span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>                <span class="hljs-attr">isToggleOn</span>: !state.<span class="hljs-property">isToggleOn</span><br>            &#125;)<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toggle</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br><br></code></pre></td></tr></table></figure><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteRow</span>(id, e)&#125;&gt;<span class="hljs-title class_">Delete</span> <span class="hljs-title class_">Row</span>&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteRow.bind(this,</span> <span class="hljs-attr">id</span>)&#125;&gt;</span>Delete Row<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p><p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p><h2 id="受控组件和非控组件"><a href="#受控组件和非控组件" class="headerlink" title="受控组件和非控组件"></a>受控组件和非控组件</h2><p>先来说说受控组件：</p><p>使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx">saveName = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">name</span>:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>&#125;<br><br>savePwd = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">pwd</span>:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>&#125;<br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.login&#125;</span>&gt;</span></span><br><span class="language-xml">            用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.name&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.saveName&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">            密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.pwd&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.savePwd&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;password&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>onchange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p><p>对于受控组件来说，输入的值始终由 React 的 state 驱动。</p><p><strong>非受控组件：</strong></p><p>非受控组件其实就是表单元素的值不会更新state。输入数据都是现用现取的。</p><p>如下：下面并没有使用state来控制属性，使用的是事件来控制表单的属性值。</p><blockquote><p>表单提交同样需要通过事件来处理，提交表单的事件通过form标签的onSubmit事件来绑定，处理表单的方式因情况而已，但是一定要注意，必须要取消默认行为，否则会触发表单的默认提交行为：</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br><br>    login = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span>&#123;<br>        event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">//阻止表单默认事件</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-property">value</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pwd</span>.<span class="hljs-property">value</span>);<br>        &#125;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> (<br>                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.login&#125;</span>&gt;</span></span><br><span class="language-xml">                用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;e</span> =&gt;</span> this.name =e &#125; type = &quot;text&quot; name =&quot;username&quot;/&gt;</span><br><span class="language-xml">                密码：  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;e</span> =&gt;</span> this.pwd =e &#125; type = &quot;password&quot; name =&quot;password&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>            )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h2><p><strong>高级函数</strong></p><ol><li>如果函数的参数是函数</li><li>如果函数返回一个函数</li></ol><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p><p>如下，我们将上面的案例简化，创建高级函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    state = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">pwd</span>:<span class="hljs-string">&quot;&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//返回一个函数</span><br>    saveType = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;[type]:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span> = <span class="hljs-string">&#123;this.saveType(</span>&#x27;<span class="hljs-attr">name</span>&#x27;)&#125; <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure><p>不使用函数柯里化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    state = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">pwd</span>:<span class="hljs-string">&quot;&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//返回一个函数</span><br>    saveType = <span class="hljs-function">(<span class="hljs-params">type,event</span>) =&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;[type]:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>    &#125;<br><br>    <span class="hljs-comment">//因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span> = <span class="hljs-string">&#123;event</span> =&gt;</span> this.saveType(&#x27;name&#x27;,event)&#125; type = &quot;text&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向组件</title>
    <link href="/2025/01/23/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6/"/>
    <url>/2025/01/23/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="面向组件"><a href="#面向组件" class="headerlink" title="面向组件"></a>面向组件</h1><h2 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h2><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p><p>只有两种方式的组件</p><ul><li>函数组件</li><li>类式组件</li></ul><p><strong>注意：</strong></p><ol><li>组件名必须是首字母大写（React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt; div &#x2F;&gt;<code>代表 HTML 的 div 标签，而</code>&lt; Weclome &#x2F;&gt; 则代表一个组件，并且需在作用域内使用 <code>Welcome</code>）</li><li>虚拟DOM元素只能有一个根元素</li><li>虚拟DOM元素必须有结束标签 <code>&lt; /&gt;</code></li></ol><p><strong>渲染类组件标签的基本流程</strong></p><ol><li>React 内部会创建组件实例对象</li><li>调用<code>render()</code>得到虚拟 DOM ,并解析为真实 DOM</li><li>插入到指定的页面元素内部</li></ol><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>定义组件最简单的方式就是编写 JavaScript 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建函数式组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//此处的this是undefined，因为babel编译后开启了严格模式</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用函数定义的组件(适用于【简单组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">//2.渲染组件到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><p>让我们来回顾一下这个例子中发生了什么：</p><ol><li>React解析组件标签，找到了MyComponent组件。</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</li></ol><p><strong>注意：</strong> <strong>组件名称必须以大写字母开头。</strong></p><p>React 会将以小写字母开头的组件视为原生 DOM 标签。例如，<code>&lt;div /&gt;</code> 代表 HTML 的 div 标签，而 <code>&lt;Welcome /&gt;</code> 则代表一个组件，并且需在作用域内使用 <code>Welcome</code>。</p><p>你可以在<a href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized">深入 JSX</a> 中了解更多关于此规范的原因。</p><h3 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h3><blockquote><p><strong>将函数组件转换成 class 组件</strong></p><p>通过以下五步将 <code>Clock</code> 的函数组件转成 class 组件：</p><ol><li>创建一个同名的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a>，并且继承于 <code>React.Component</code>。</li><li>添加一个空的 <code>render()</code> 方法。</li><li>将函数体移动到 <code>render()</code> 方法之中。</li><li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</li><li>删除剩余的空函数声明。</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render中的this:&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>          <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用类定义的组件(适用于【复杂组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>        &#125;<br>      &#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>每次组件更新时 <code>render</code> 方法都会被调用，但只要在相同的 DOM 节点中渲染 <code>&lt;MyComponent/&gt;</code> ，就仅有一个 <code>MyComponent</code> 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。</p><p><strong>执行过程：</strong></p><ol><li>React解析组件标签，找到相应的组件</li><li>发现组件是类定义的，随后new出来的类的实例，并通过该实例调用到原型上的render方法</li><li>将render返回的虚拟DOM转化为真实的DOM,随后呈现在页面中</li></ol><h3 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h3><p>组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。</p><p>例如，我们可以创建一个可以多次渲染 <code>Welcome</code> 组件的 <code>App</code> 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> (</span><br><span class="language-javascript">            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Cahal&quot;</span> /&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Edite&quot;</span> /&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-javascript">        );</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>常来说，每个新的 React 应用程序的顶层组件都是 <code>App</code> 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 <code>Button</code> 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。</p><h3 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h3><p>将组件拆分为更小的组件。</p><p>例如，参考如下 <code>Comment</code> 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">date</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> date.<span class="hljs-title function_">toLocaleString</span>()</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> (</span><br><span class="language-javascript">            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Commment&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.author.avatarUrl&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;width:</span> &#x27;<span class="hljs-attr">200px</span>&#x27;, <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">100px</span>&#x27;&#125;&#125;/&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.author.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-javascript">        )</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> comment = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),</span><br><span class="language-javascript">        <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;I hope you enjoy learning React!&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">author</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Hello Kitty&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">avatarUrl</span>: <span class="hljs-string">&#x27;https://t7.baidu.com/it/u=1819248061,230866778&amp;fm=193&amp;f=GIF&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comment</span> <span class="hljs-attr">date</span>=<span class="hljs-string">&#123;comment.date&#125;</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&#123;comment.text&#125;</span> <span class="hljs-attr">author</span>=<span class="hljs-string">&#123;comment.author&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该组件用于描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。</p><p><img src="https://i.imgur.com/7zZWlCv.png" alt="image-20250123155253964"></p><p>该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。</p><p>首先，我们将提取 <code>Avatar</code> 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span>      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span>      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span>    /&gt;</span></span>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Avatar</code> 不需知道它在 <code>Comment</code> 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：<code>user</code>，而不是 <code>author</code>。</p><p>我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。</p><p>我们现在针对 <code>Comment</code> 做些微小调整：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.author.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们将提取 <code>UserInfo</code> 组件，该组件在用户名旁渲染 <code>Avatar</code> 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.user.name&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步简化 <code>Comment</code> 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组件实例的三大属性-state-props-refs"><a href="#组件实例的三大属性-state-props-refs" class="headerlink" title="组件实例的三大属性 state props refs"></a>组件实例的三大属性 state props refs</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><blockquote><p>我们都说React是一个状态机，体现是什么地方呢，就是体现在state上，通过与用户的交互，实现不同的状态，然后去渲染UI,这样就让用户的数据和界面保持一致了。state是组件的私有属性。</p><p>在React中，更新组件的state，结果就会重新渲染用户界面(不需要操作DOM),一句话就是说，用户的界面会随着状态的改变而改变。</p><p>state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合）</p><p>简单的说就是组件的状态，也就是该组件所存储的数据</p></blockquote><p>案例：</p><p>需求：页面显示【今天天气很炎热】，鼠标点击文字的时候，页面更改为【今天天气很凉爽】</p><p>核心代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">super</span>(props);</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span>&#125;</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">changeWeather</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">changeWeather</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeWeather&#125;</span>&gt;</span>天气&#123;this.state.isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">changeWeather</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 由于changWeather 是作为onClick的调用 并不是通过实例调用的 此时方法中this是 undefined</span></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> isHot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isHot</span>: !isHot&#125;)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isHot)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Weather</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<strong>类式组件</strong>的函数中，直接修改<code>state</code>值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><blockquote><p>页面的渲染靠的是<code>render</code>函数</p></blockquote><p>这时候会发现页面内容不会改变，原因是 React 中不建议 <code>state</code>不允许直接修改，而是通过类的原型对象上的方法 <code>setState()</code></p><p><strong>注意：</strong></p><ol><li>组件的构造函数，必须要传递一个props参数</li><li>特别关注this【重点】，类中所有的方法局部都开启了严格模式，如果直接进行调用，this就是undefined</li><li>想要改变state,需要使用setState进行修改，如果只是修改state的部分属性，则不会影响其他的属性，这个只是合并并不是覆盖。</li></ol><p><strong>在优化过程中遇到的问题</strong></p><ol><li>组件中的 render 方法中的 this 为组件实例对象</li><li>组件自定义方法中由于开启了严格模式，this 指向<code>undefined</code>如何解决<ol><li>通过 bind 改变 this 指向</li><li>推荐采用箭头函数，箭头函数的 <code>this</code> 指向</li></ol></li><li>state 数据不能直接修改或者更新</li></ol><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>this.State()，该方法接收两种参数：对象或函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(partialState, [callback]);<br></code></pre></td></tr></table></figure><ul><li>partialState: 需要跟新状态的部分对象，可以是<code>function</code></li><li>callback: 更新完状态后的回调函数</li></ul><p><strong>有两种写法:</strong></p><ol><li>对象：即要修改的state</li><li>函数：接收两个函数，第一个函数接受两个参数，第一个是当前state，第二个是当前props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的state；第二个函数参数是state参数</li></ol><h4 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h4><ol><li><p>state 的赋值可以不在构造函数中进行</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields">公有类字段</a></p></li><li><p>使用了箭头函数，将this进行改变</p><blockquote><p> 箭头函数中的this会指向调用此箭头函数的外层</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;</span><br><span class="language-javascript">        state = &#123;<span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span>&#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">super</span>(props);</span><br><span class="language-javascript">            <span class="hljs-comment">// this.changeWeather = this.changeWeather.bind(this)</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeWeather&#125;</span>&gt;</span>天气&#123;this.state.isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 箭头函数</span></span><br><span class="language-javascript">        changeWeather = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 由于changWeather 是作为onClick的调用 并不是通过实例调用的 此时方法中this是 undefined</span></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> isHot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isHot</span>: !isHot&#125;)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isHot)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Weather</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="state-的更新可能是异步的"><a href="#state-的更新可能是异步的" class="headerlink" title="state 的更新可能是异步的"></a>state 的更新可能是异步的</h4><p><strong>React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout&#x2F;setInterval等</strong>。</p><blockquote><p>  18版本中测试setTimeout回调函数中也是异步更新的</p></blockquote><p><strong>大部分开发中用到的都是React封装的事件，比如onChange、onClick、onTouchMove等，这些事件处理程序中的setState都是异步处理的。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        count : <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addCount&#125;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>            &#123;<br>                <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>            &#125;<br>        )<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>上面的案例中预期setState使得count变成了11，输出也应该是11。然而在控制台打印的却是10，也就是并没有对其进行更新。这是因为异步的进行了处理，在输出的时候还没有对其进行处理。</p><p><strong>React怎么调用同步或者异步的呢？</strong></p><p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p><p><strong>如果是同步更新，每一个setState对调用一个render，并且如果多次调用setState会以最后调用的为准，前面的将会作废；如果是异步更新，多个setSate会统一调用一次render</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx">dem = <span class="hljs-function">() =&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">isHot</span>:  <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">cont</span>:<span class="hljs-number">444</span><br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">isHot</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span> + <span class="hljs-number">1</span><br><br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">isHot</span>:  <span class="hljs-number">888</span>,<br>        <span class="hljs-attr">cont</span>:<span class="hljs-number">888</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的最后会输出：isHot是888，cont是888</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>count</code>初始值为1，当执行addCount后值变成2，也就是前面两部的setState并没有执行</p><p>**注意！！这是异步更新才有的，如果同步更新，每一次都会调用render，这样每一次更新都会 **</p><h4 id="异步更新解决方案"><a href="#异步更新解决方案" class="headerlink" title="异步更新解决方案"></a>异步更新解决方案</h4><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p><p>例如，此代码可能会无法更新计数器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Wrong</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">increment</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br> addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>    &#125;))<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>    &#125;))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，不过使用普通的函数也同样可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">state, props</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h4><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p><p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">FormattedDate</span> date=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">date</span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p><code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FormattedDate</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p><p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p><p>为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 <code>Clock</code> 的 <code>App</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>    </span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>Clock</code> 组件都会单独设置它自己的计时器并且更新它。</p><p>在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><blockquote><p>只读</p></blockquote><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>与<code>state</code>不同，<code>state</code>是组件自身的状态，而<code>props</code>则是外部传入的数据</p><p>基本使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">const</span> &#123; name, age, sex &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>      )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//传递数据</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tom&quot;</span> <span class="hljs-attr">age</span> = <span class="hljs-string">&#123;41&#125;</span> <span class="hljs-attr">sex</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>如果传递的数据是一个对象，可以更加简便的使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> &#123;<span class="hljs-attr">...p</span>&#125;/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>… 这个符号恐怕都不陌生，这个是一个展开运算符，主要用来展开数组，如下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr1 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>arr2 = [...arr,...arr1];  <span class="hljs-comment">//arr2 = [1,2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><p>但是他还有其他的用法：</p><p>1.复制一个对象给另一个对象{…对象名}。此时这两个对象并没有什么联系了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-keyword">const</span> p2 = &#123;...p1&#125;;<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;sss&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">//&#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>2.在复制的时候，合并其中的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-keyword">const</span> p2 = &#123;...p1,name : <span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-attr">hua</span>:<span class="hljs-string">&quot;ss&quot;</span>&#125;;<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;sss&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">//&#123;name: &quot;111&quot;, age: &quot;18&quot;, sex: &quot;女&quot;,hua:&quot;ss&quot;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>注意！！</strong> <strong>{…P}并不能展开一个对象</strong></p><p><strong>props传递一个对象，是因为babel+react使得{..p}可以展开对象，但是只有在标签中才能使用</strong></p><h4 id="props-限制"><a href="#props-限制" class="headerlink" title="props 限制"></a>props 限制</h4><blockquote><p>注意：</p><p>自 React v15.5 起，<code>React.PropTypes</code> 已移入另一个包中。请使用 <a href="https://www.npmjs.com/package/prop-types"><code>prop-types</code> 库</a> 代替。</p><p>我们提供了一个 <a href="https://zh-hans.reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes">codemod 脚本</a>来做自动转换。</p></blockquote><p>随着你的应用程序不断增长，你可以通过类型检查捕获大量错误。对于某些应用程序来说，你可以使用 <a href="https://flow.org/">Flow</a> 或 <a href="https://www.typescriptlang.org/">TypeScript</a> 等 JavaScript 扩展来对整个应用程序做类型检查。但即使你不使用这些扩展，React 也内置了一些类型检查的功能。要在组件的 props 上进行类型检查，你只需配置特定的 <code>propTypes</code> 属性：</p><p>react对此提供了相应的解决方法：</p><ul><li>propTypes:类型检查，还可以限制不能为空</li><li>defaultProps：默认值</li></ul><blockquote><p>从 ES2022 开始，你也可以在 React 类组件中将 <code>defaultProps</code> 声明为静态属性。欲了解更多信息，请参阅 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields#public_static_fields">class public static fields</a>。这种现代语法需要添加额外的编译步骤才能在老版浏览器中工作。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//对标签属性进行类型、必要性的限制</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">propTypes</span> = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span><br>    <span class="hljs-attr">sex</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<span class="hljs-comment">//限制sex为字符串</span><br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<span class="hljs-comment">//限制age为数值</span><br>    <span class="hljs-attr">speak</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>,<span class="hljs-comment">//限制speak为函数</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-comment">//指定默认标签属性值</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">defaultProps</span> = &#123;<br>    <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-comment">//sex默认值为男</span><br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span> <span class="hljs-comment">//age默认值为18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当传入的 <code>prop</code> 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，<code>propTypes</code> 仅在开发模式下进行检查。</p><p><code>defaultProps</code> 用于确保 <code>this.props.sex</code> 在父组件没有指定其值时，有一个默认值。<code>propTypes</code> 类型检查发生在 <code>defaultProps</code> 赋值后，所以类型检查也适用于 <code>defaultProps</code>。</p><h5 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h5><p>以下提供了使用不同验证器的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-title class_">MyComponent</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span><br>  <span class="hljs-comment">// 这些属性都是可选的。</span><br>  <span class="hljs-attr">optionalArray</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">array</span>,<br>  <span class="hljs-attr">optionalBool</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">bool</span>,<br>  <span class="hljs-attr">optionalFunc</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>,<br>  <span class="hljs-attr">optionalNumber</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<br>  <span class="hljs-attr">optionalObject</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">object</span>,<br>  <span class="hljs-attr">optionalString</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>  <span class="hljs-attr">optionalSymbol</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">symbol</span>,<br><br>  <span class="hljs-comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span><br>  <span class="hljs-comment">// (或 Fragment) 也包含这些类型。</span><br>  <span class="hljs-attr">optionalNode</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">node</span>,<br><br>  <span class="hljs-comment">// 一个 React 元素。</span><br>  <span class="hljs-attr">optionalElement</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">element</span>,<br><br>  <span class="hljs-comment">// 一个 React 元素类型（即，MyComponent）。</span><br>  <span class="hljs-attr">optionalElementType</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">elementType</span>,<br><br>  <span class="hljs-comment">// 你也可以声明 prop 为类的实例，这里使用</span><br>  <span class="hljs-comment">// JS 的 instanceof 操作符。</span><br>  <span class="hljs-attr">optionalMessage</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">instanceOf</span>(<span class="hljs-title class_">Message</span>),<br><br>  <span class="hljs-comment">// 你可以让你的 prop 只能是特定的值，指定它为</span><br>  <span class="hljs-comment">// 枚举类型。</span><br>  <span class="hljs-attr">optionalEnum</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">oneOf</span>([<span class="hljs-string">&#x27;News&#x27;</span>, <span class="hljs-string">&#x27;Photos&#x27;</span>]),<br><br>  <span class="hljs-comment">// 一个对象可以是几种类型中的任意一个类型</span><br>  <span class="hljs-attr">optionalUnion</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">oneOfType</span>([<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">instanceOf</span>(<span class="hljs-title class_">Message</span>)<br>  ]),<br><br>  <span class="hljs-comment">// 可以指定一个数组由某一类型的元素组成</span><br>  <span class="hljs-attr">optionalArrayOf</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">arrayOf</span>(<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>),<br><br>  <span class="hljs-comment">// 可以指定一个对象由某一类型的值组成</span><br>  <span class="hljs-attr">optionalObjectOf</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">objectOf</span>(<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>),<br><br>  <span class="hljs-comment">// 可以指定一个对象由特定的类型值组成</span><br>  <span class="hljs-attr">optionalObjectWithShape</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">shape</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span><br>  &#125;),<br><br>  <span class="hljs-comment">// 具有额外属性警告的对象</span><br>  <span class="hljs-attr">optionalObjectWithStrictShape</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">exact</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-attr">quantity</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span><br>  &#125;),<br><br>  <span class="hljs-comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span><br>  <span class="hljs-comment">// 这个 prop 没有被提供时，会打印警告信息。</span><br>  <span class="hljs-attr">requiredFunc</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>.<span class="hljs-property">isRequired</span>,<br><br>  <span class="hljs-comment">// 任意类型的必需数据</span><br>  <span class="hljs-attr">requiredAny</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">any</span>.<span class="hljs-property">isRequired</span>,<br><br>  <span class="hljs-comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span><br>  <span class="hljs-comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `oneOfType` 中不会起作用。</span><br>  <span class="hljs-attr">customProp</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">props, propName, componentName</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.<span class="hljs-title function_">test</span>(props[propName])) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;Invalid prop `&#x27;</span> + propName + <span class="hljs-string">&#x27;` supplied to&#x27;</span> +<br>        <span class="hljs-string">&#x27; `&#x27;</span> + componentName + <span class="hljs-string">&#x27;`. Validation failed.&#x27;</span><br>      );<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span><br>  <span class="hljs-comment">// 它应该在验证失败时返回一个 Error 对象。</span><br>  <span class="hljs-comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span><br>  <span class="hljs-comment">// 第一个是数组或对象本身</span><br>  <span class="hljs-comment">// 第二个是他们当前的键。</span><br>  <span class="hljs-attr">customArrayProp</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">arrayOf</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">propValue, key, componentName, location, propFullName</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.<span class="hljs-title function_">test</span>(propValue[key])) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;Invalid prop `&#x27;</span> + propFullName + <span class="hljs-string">&#x27;` supplied to&#x27;</span> +<br>        <span class="hljs-string">&#x27; `&#x27;</span> + componentName + <span class="hljs-string">&#x27;`. Validation failed.&#x27;</span><br>      );<br>    &#125;<br>  &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="限制单个元素"><a href="#限制单个元素" class="headerlink" title="限制单个元素"></a>限制单个元素</h5><p>你可以通过 <code>PropTypes.element</code> 来确保传递给组件的 children 中只包含一个元素。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 这必须只有一个元素，否则控制台会打印警告。</span><br>    <span class="hljs-keyword">const</span> children = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyComponent</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-attr">children</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">element</span>.<span class="hljs-property">isRequired</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!-- 准备好一个“容器” --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//创建组件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// console.log(props);</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">super</span>(props)</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;constructor&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//对标签属性进行类型、必要性的限制</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">static</span> propTypes = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">name</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">sex</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<span class="hljs-comment">//限制sex为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">age</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<span class="hljs-comment">//限制age为数值</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//指定默认标签属性值</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">static</span> defaultProps = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-comment">//sex默认值为男</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">age</span>:<span class="hljs-number">18</span> <span class="hljs-comment">//age默认值为18</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// console.log(this);</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">const</span> &#123;name,age,sex&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//props是只读的</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//this.props.name = &#x27;jack&#x27; //此行代码会报错，因为props是只读的</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> (</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">            )</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//渲染组件到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jerry&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test1&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在使用的时候可以通过 <code>this.props</code>来获取值 类式组件的 <code>props</code>:</p><ol><li>通过在组件标签上传递值，在组件中就可以获取到所传递的值</li><li>在构造器里的<code>props</code>参数里可以获取到 <code>props</code></li><li>可以分别设置 <code>propTypes</code> 和 <code>defaultProps</code> 两个属性来分别操作 <code>props</code>的规范和默认值，两者都是直接添加在类式组件的<strong>原型对象</strong>上的（所以需要添加 <code>static</code>）</li><li>同时可以通过<code>...</code>运算符来简化</li></ol><h4 id="函数式组件的使用"><a href="#函数式组件的使用" class="headerlink" title="函数式组件的使用"></a>函数式组件的使用</h4><blockquote><p>函数在使用props的时候，是作为参数进行使用的(props)</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>对props进行限制<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 准备好一个“容器” --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//创建组件</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> &#123; name, age, sex &#125; = props</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> (</span><br><span class="language-javascript">          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span><br><span class="language-javascript">        )</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-title class_">Person</span>.<span class="hljs-property">propTypes</span> = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span></span><br><span class="language-javascript">        <span class="hljs-attr">sex</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>, <span class="hljs-comment">//限制sex为字符串</span></span><br><span class="language-javascript">        <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>, <span class="hljs-comment">//限制age为数值</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//指定默认标签属性值</span></span><br><span class="language-javascript">      <span class="hljs-title class_">Person</span>.<span class="hljs-property">defaultProps</span> = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-comment">//sex默认值为男</span></span><br><span class="language-javascript">        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">//age默认值为18</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-comment">//渲染组件到页面</span></span><br><span class="language-javascript">      <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jerry&quot;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test1&#x27;</span>))</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>函数组件的 <code>props</code>定义:</p><ol><li>在组件标签中传递 <code>props</code>的值</li><li>组件函数的参数为 <code>props</code></li><li>对 <code>props</code>的限制和默认值同样设置在原型对象上</li></ol><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p><p>在典型的 React 数据流中，<a href="https://zh-hans.reactjs.org/docs/components-and-props.html">props</a> 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p><blockquote><p>在我们正常的操作节点时，需要采用DOM API 来查找元素，但是这样违背了 React 的理念，因此有了<code>refs</code></p></blockquote><p><strong>何时使用 Refs</strong></p><p>下面是几个适合使用 refs 的情况：</p><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p><p><strong>有三种操作<code>refs</code>的方法，分别为：</strong></p><ul><li>字符串形式</li><li>回调形式</li><li><code>createRef</code>形式</li></ul><p><strong>勿过度使用 Refs</strong></p><p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 <a href="https://zh-hans.reactjs.org/docs/lifting-state-up.html">状态提升</a> 以获取更多有关示例。</p><h4 id="字符串形式"><a href="#字符串形式" class="headerlink" title="字符串形式"></a>字符串形式</h4><p>在想要获取到一个DOM节点，可以直接在这个节点上添加ref属性。利用该属性进行获取该节点的值。</p><p>案例：给需要的节点添加ref属性，此时该实例对象的refs上就会有这个值。就可以利用实例对象的refs获取已经添加节点的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">ref</span> = <span class="hljs-string">&quot;input1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;失去焦点提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">input1</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>不建议使用它，因为 string 类型的 refs 存在 <a href="https://github.com/facebook/react/pull/8333#issuecomment-271648615">一些问题</a>。它已过时并可能会在未来的版本被移除。</p><p>如果你目前还在使用 <code>this.refs.textInput</code> 这种方式访问 refs ，我们建议用<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#callback-refs">回调函数</a>或 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#creating-refs"><code>createRef</code> API</a> 的方式代替。</p><h4 id="回调方式"><a href="#回调方式" class="headerlink" title="回调方式"></a>回调方式</h4><p>React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。</p><p>这种方式会将该DOM作为参数传递过去。</p><p>组件实例的<code>ref</code>属性传递一个回调函数<code>c =&gt; this.input1 = c </code>（箭头函数简写），这样会在实例的属性中存储对DOM节点的引用，使用时可通过<code>this.input1</code>来使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><p><code>current</code>会接收到当前节点作为参数，然后将当前节点赋值给<code>input1</code>实例属性上</p><p><strong>关于回调 refs 的说明</strong></p><p>如果 <code>ref</code> 回调函数是以<code>内联函数</code>的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。<strong>通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的</strong>。</p><p><code>class的绑定函数</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span><br>    &#125;<br><br>    saveInput = <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;@&#x27;</span>, c)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = c<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123;isHot&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今天天气很&#123;isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                &#123;/*<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current; console.log(&#x27;@&#x27;, current)</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;*/&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;this.saveInput&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-variable language_">this</span>)<br>        <span class="hljs-keyword">const</span> &#123;<br>            isHot<br>        &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">isHot</span>: !isHot<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>tips: 其实就相当于是匿名函数对于react来说，每次的函数都是不一样的，基于类绑定的方式，使用的是一个固定的实例函数，因此对于他来说没必要有清空之前绑定的这一步</p></blockquote><h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h4><blockquote><p>React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    myRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>    state = &#123;<br>        <span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><br>        <span class="hljs-keyword">const</span> &#123;isHot&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今天天气很&#123;isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                &#123;/*<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current; console.log(&#x27;@&#x27;, current)</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;*/&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;this.myRef&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeWeather&#125;</span>&gt;</span>修改天气<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    changeWeather = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-variable language_">this</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@ ref&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span>.<span class="hljs-property">current</span>)<br>        <span class="hljs-keyword">const</span> &#123;<br>            isHot<br>        &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">isHot</span>: !isHot<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>逻辑：最开始创建一个实例的ref，后续通过ref关键字，react发现ref是通过<code>React.crateRef</code>创建的，然后他会把当前的节点赋值给myRef，如果有多个节点的话，他就需要创建多个ref</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li><p>Refs与函数组件</p><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyFunctionComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">textInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// This will *not* work!</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyFunctionComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.textInput&#125;</span> /&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html"><code>forwardRef</code></a>（可与 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a> 结合使用），或者可以将该组件转化为 class 组件。</p><p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomTextInput</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">// 这里必须声明 textInput，这样 ref 才可以引用它</span><br>  <span class="hljs-keyword">const</span> textInput = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    textInput.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;textInput&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Focus the text input&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flag</title>
    <link href="/2025/01/16/Go%E7%B3%BB%E5%88%97/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/flag/"/>
    <url>/2025/01/16/Go%E7%B3%BB%E5%88%97/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/flag/</url>
    
    <content type="html"><![CDATA[<p>flag</p>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>每日一库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 入门</title>
    <link href="/2025/01/15/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E5%85%A5%E9%97%A8/"/>
    <url>/2025/01/15/%E5%A4%A7%E5%89%8D%E7%AB%AF/React/%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="React入门"><a href="#React入门" class="headerlink" title="React入门"></a>React入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>React</strong> 是一个用于构建用户界面的 JavaScript 库。</p><ul><li>是一个将数据渲染为 HTML 视图的开源 JS 库</li><li>它遵循基于组件的方法，有助于构建可重用的 UI 组件</li><li>它用于开发复杂的交互式的 web 和移动 UI</li></ul><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>首先需要引入几个 react 包</p><ul><li>React 核心库、操作 DOM 的 react 扩展库、将 jsx 转为 js 的 babel 库</li></ul><p>【先引入react.development.js，后引入react-dom.development.js】</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">react.development.js</span><br></code></pre></td></tr></table></figure><ul><li>react 是react核心库，只要使用react就必须要引入</li><li>下载地址：<a href="https://unpkg.com/react@18.0.0/umd/react.development.js">https://unpkg.com/react@18.0.0/umd/react.development.js</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">react-dom.development.js</span><br></code></pre></td></tr></table></figure><ul><li>react-dom 是react的dom包，使用react开发web应用时必须引入</li><li>下载地址：<a href="https://unpkg.com/react-dom@18.0.0/umd/react-dom.development.js">https://unpkg.com/react-dom@18.0.0/umd/react-dom.development.js</a></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;babel<span class="hljs-selector-class">.min</span><span class="hljs-selector-class">.js</span> <br></code></pre></td></tr></table></figure><p>由于JSX最终需要转换为JS代码执行，所以浏览器并不能正常识别JSX，所以当我们在浏览器中直接使用JSX时，还必须引入babel来完成对代码的编译。<br>babel下载地址：<a href="https://unpkg.com/babel-standalone@6/babel.min.js">https://unpkg.com/babel-standalone@6/babel.min.js</a></p></blockquote><p><img src="https://i.imgur.com/AXsszEN.png" alt="image-20250115112416889"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hello_react<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 准备好一个“容器” --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 引入react核心库 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入babel，用于将jsx转为js --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">/* 此处一定要写babel */</span></span><br><span class="language-javascript">      <span class="hljs-comment">//1.创建虚拟DOM</span></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> <span class="hljs-comment">/* 此处一定不要写引号，因为不是字符串 */</span></span><br><span class="language-javascript">      <span class="hljs-comment">//2.渲染虚拟DOM到页面</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#test&#x27;</span>));</span><br><span class="language-javascript">      root.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.title</span> &#123;</span><br><span class="language-css">           <span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css">           <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; </span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> myId = <span class="hljs-string">&quot;buMai&quot;</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> myData = <span class="hljs-string">&quot;hello, REACT&quot;</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (</span><br><span class="language-javascript">            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;myId.toLocaleLowerCase()&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span> &#x27;<span class="hljs-attr">white</span>&#x27;, <span class="hljs-attr">fontSize:</span> &#x27;<span class="hljs-attr">29px</span>&#x27;&#125;&#125;&gt;</span>&#123;myData.toLocaleLowerCase()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-javascript">        )</span><br><span class="language-javascript">        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="jsx语法规则"><a href="#jsx语法规则" class="headerlink" title="jsx语法规则"></a>jsx语法规则</h2><p>JSX 是 JavaScript 的语法扩展，JSX 使得我们可以以类似于 HTML 的形式去使用 JS。JSX便是React中声明式编程的体现方式。声明式编程，简单理解就是以结果为导向的编程。使用JSX将我们所期望的网页结构编写出来，然后React再根据JSX自动生成JS代码。所以我们所编写的JSX代码，最终都会转换为以调用<code>React.createElement()</code>创建元素的代码。</p><ol><li>定义虚拟DOM，JSX不是字符串，不要加引号</li><li>标签中混入<code>JS表达式</code>的时候使用{}</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">id</span> <span class="hljs-operator">=</span> &#123;myId.toUpperCase()&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>样式的类名指定不能使用class，使用<code>className</code></p></li><li><p>内敛样式要使用<code>&#123;&#123;&#125;&#125;</code>包裹</p></li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">style=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">color:</span><span class="hljs-string">&#x27;skyblue&#x27;</span>,fontSize:<span class="hljs-string">&#x27;24px&#x27;</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><ol start="5"><li><p>不能有多个根标签，只能有一个根标签</p></li><li><p>JSX的标签必须正确结束（自结束标签必须写&#x2F;）</p></li><li><p>JSX中html标签应该小写，React组件应该大写开头。如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错；如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错</p></li><li><p>如果表达式是空值、布尔值、undefined，将不会显示</p></li></ol><blockquote><p>关于JS表达式和JS语句：</p><ul><li>JS表达式：返回一个值，可以放在任何一个需要值的地方 a a+b demo(a) arr.map() function text(){}</li><li>JS语句：if(){} for(){} while(){} swith(){} 不会返回一个值</li></ul></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p>注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写在花括号里面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>小丞<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    &#123;/*注释...*/&#125;</span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure></li><li><p><code>class</code>需要使用<code>className</code>代替</p></li><li><p><code>style</code>中必须使用对象设置<code> style=&#123;&#123;background:'red'&#125;&#125;</code></p></li><li><p>数组</p><blockquote><p>JSX 允许在模版中插入数据，数据自动展开全部成员</p><p>{} 只能用来放js表达式，而不能放语句（if for） 在语句中是可以去操作JSX</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>小丞<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>同学<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>,<br>];<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;arr&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 模拟数据</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;Angular&#x27;</span>, <span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Vue&#x27;</span>]</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (</span><br><span class="language-javascript">        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>前端js框架列表<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                &#123;</span></span><br><span class="language-xml"><span class="language-javascript">                    data.map((item, index) =&gt; &#123;</span></span><br><span class="language-xml"><span class="language-javascript">                        return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">                    &#125;)</span></span><br><span class="language-xml"><span class="language-javascript">                &#125;</span></span><br><span class="language-xml"><span class="language-javascript">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-javascript">    )</span><br><span class="language-javascript">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ul><li>React.createElement()<ul><li><code>React.createElement(type, [props], [...children])</code></li><li>用来创建React元素</li><li>React元素无法修改</li></ul></li><li>ReactDOM.createRoot()<ul><li><code>createRoot(container[, options])</code></li><li>用来创建React的根容器，容器用来放置React元素</li></ul></li><li>ReactDOM.render()<ul><li><code>root.render(element)</code></li><li>用来将React元素渲染到根元素中</li><li>根元素中所有的内容都会被删除，被React元素所替换</li><li>当重复调用render()时，React会将两次的渲染结果进行比较，</li><li>它会确保只修改那些发生变化的元素，对DOM做最少的修改</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC</title>
    <link href="/2024/12/01/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/gRPC/"/>
    <url>/2024/12/01/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/gRPC/</url>
    
    <content type="html"><![CDATA[<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="gRPC-介绍"><a href="#gRPC-介绍" class="headerlink" title="gRPC 介绍"></a>gRPC 介绍</h2><p>gPRC 官网（<a href="https://grpc.io/%EF%BC%89%E4%B8%8A%E7%9A%84">https://grpc.io/）上的</a> Slogan 是：A high performance, open source universal RPC framework。就是：一个高性能、开源的通用 RPC 框架。</p><p>支持多数主流语言：C#、C++、Dart、<strong>Go</strong>、Java、Kotlin、Node、Objective-C、PHP、Python、Ruby。其中 Go 支持 Windows, Linux, Mac 上的 Go 1.13+ 版本。</p><p>gRPC 是一个 Google 开源的高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一步，将设备、移动应用程序和浏览器与后端服务接。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过 <code>goctl</code> 可以一键安装 <code>protoc</code>，<code>protoc-gen-go</code>，<code>protoc-gen-go-grpc</code> 相关组件，你可以执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bsh">goctl env check --install --verbose --force<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h3><p>默认情况下，gRPC 使用 Protocol Buffers，这是 Google 用于序列化结构化数据的成熟开源机制（尽管它可以与 JSON 等其他数据格式一起使用）。</p><blockquote><p>Protocol Buffers 的文档：<a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a></p></blockquote><p>使用 Protocol Buffers 的基本步骤是</p><ol><li>使用 protocol buffers 语法定义消息，消息是用于传递的数据</li><li>使用 protocol buffers 语法定义服务，服务是 RPC 方法的集合，来使用消息</li><li>使用 Protocol Buffer编 译工具 <code>protoc</code> 来编译，生成对应语言的代码，例如 Go 的代码</li></ol><p>使用 Protocol Buffers 的第一步是在 <code>.proto</code> 文件中定义序列化的数据的结构，.proto 文件是普通的文本文件。Protocol Buffers 数据被结构化为消息，其中每条消息都是一个小的信息逻辑记录，包含一系列称为字段的 name-value 对。</p><p>除了核心内容外，<code>.proto</code> 文件还需要指定语法版本，目前主流的也是最新的 proto3 版本。在 <code>.proto</code> 文件的开头指定。</p><p>一个简单的产品信息示例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> user; <span class="hljs-comment">// 默认包名</span><br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./user&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserReq</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserResp</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">string</span> phone = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> GetUser(GetUserReq) <span class="hljs-keyword">returns</span> (GetUserResp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>protoc</code> 工具将 <code>.proto</code> 定义的消息和包含 rpc 方法的服务编译为目标语言的代码，我们选择 Go 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --go-grpc_out=. --go_out=. ./user.proto<br><span class="hljs-comment"># --go_out *.pb.go 目录</span><br><span class="hljs-comment"># --go-grpc_out *_grpc.pb.go 目录</span><br></code></pre></td></tr></table></figure><h4 id="消息类型的定义"><a href="#消息类型的定义" class="headerlink" title="消息类型的定义"></a>消息类型的定义</h4><p>以一个简单的请求消息为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先指定版本 proto3，否则编译器默认为 proto2。版本指定为文件的第一非空白、非注释行。</p><p>message 关键字用于定义消息，需要指定消息类型的名称。</p><p>消息由多个名称&#x2F;值对组成，称为字段，每个字段要指定名字和类型。string、int32 是典型的标量类型，除了标量类型 protobuf 还支持构造类型，例如枚举或其他消息类型。</p><p>应该为每个字段分配唯一的字段序号，用于在二进制编码中标识该字段。序号范围1-15会消耗1个字节的存储，16-2047 会消耗2个字节。因此应该将常用的字段分配1-15字段序号。编号全部的范围是1到2^29-1，其中19000到19999是 proto编译器保留序号，不要使用。</p><p>消息的字段分为单一和重复两种规则：</p><ul><li><p>单一 Singular，proto3 中字段的默认规则。一个消息中仅可以包含0或1个该字段，就是字段不能重复。</p></li><li><p>重复的 repeated，该规则说明此字段可以重复多次（包含0次）。重复值的顺序是保留的。</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> keywords = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>.proto</code> 文件支持 C&#x2F;C++ 风格的注释 <code>//</code> 和 <code>/* ... */</code></p><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>标量消息字段可以具有以下类型之一。该表显示了 .proto 文件中指定的类型，以及自动生成的类中的相应类型：</p><table><thead><tr><th align="left">.proto Type</th><th>说明</th><th align="left">Go Type</th></tr></thead><tbody><tr><td align="left">double</td><td></td><td align="left">float64</td></tr><tr><td align="left">float</td><td></td><td align="left">float32</td></tr><tr><td align="left">int32</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint32</td><td align="left">int32</td></tr><tr><td align="left">int64</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint64</td><td align="left">int64</td></tr><tr><td align="left">uint32</td><td>变长编码</td><td align="left">uint32</td></tr><tr><td align="left">uint64</td><td>变长编码</td><td align="left">uint64</td></tr><tr><td align="left">sint32</td><td>变长编码，带符号的 int 值。这些比常规 int32 更有效地编码负数</td><td align="left">int32</td></tr><tr><td align="left">sint64</td><td>变长编码，带符号的 int 值。这些比常规 int64 更有效地编码负数</td><td align="left">int64</td></tr><tr><td align="left">fixed32</td><td>固定4个字节，如果值通常大于 2^28，则比 uint32 更有效</td><td align="left">uint32</td></tr><tr><td align="left">fixed64</td><td>固定8个字节，如果值通常大于 2^56，则比 uint64 更有效</td><td align="left">uint64</td></tr><tr><td align="left">sfixed32</td><td>固定4个字节</td><td align="left">int32</td></tr><tr><td align="left">sfixed64</td><td>固定8个字节</td><td align="left">int64</td></tr><tr><td align="left">bool</td><td></td><td align="left">bool</td></tr><tr><td align="left">string</td><td>始终包含 UTF-8 编码或 7 位 ASCII 文本，并且长度不能超过 2^32</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td>可以包含不超过 2^32 的任意字节序列</td><td align="left">[]byte</td></tr></tbody></table><p>解析消息时，如果编码的消息不包含特定元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是基于类型的：</p><ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于布尔值，默认值为 false。</li><li>对于数字类型，默认值为零。</li><li>对于枚举，默认值是第一个定义的枚举值，必须为 0。</li><li>对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息，请参阅生成的代码指南。</li><li>重复字段的默认值为空（通常是相应语言的空列表）。</li></ul><h5 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h5><p>在定义消息类型时，您可能希望其字段之一仅具有预定义的值列表之一。例如，假设您要为每个 SearchRequest 添加一个 <code>corpus</code> 字段，其中值可以是 UNIVERSAL、WEB、IMAGES、LOCAL、NEWS、PRODUCTS 或 VIDEO。您可以通过在消息定义中添加一个枚举来非常简单地做到这一点，每个可能的值都有一个常量。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Corpus</span> &#123;<br>    UNIVERSAL = <span class="hljs-number">0</span>;<br>    WEB = <span class="hljs-number">1</span>;<br>    IMAGES = <span class="hljs-number">2</span>;<br>    LOCAL = <span class="hljs-number">3</span>;<br>    NEWS = <span class="hljs-number">4</span>;<br>    PRODUCTS = <span class="hljs-number">5</span>;<br>    VIDEO = <span class="hljs-number">6</span>;<br>  &#125;<br>  Corpus corpus = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举值列表的第一常量值必须为0，这样可以更好的处理默认值。（也为了向下兼容）</p><p>也可以为同一个枚举值分配不同的常量，称为别名。需要使用选项 <code>option allow_alias = true</code> 来启用别名设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">MyMessage1</span> &#123;<br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">EnumAllowingAlias</span> &#123;<br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    UNKNOWN = <span class="hljs-number">0</span>;<br>    STARTED = <span class="hljs-number">1</span>;<br>    RUNNING = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="保留值"><a href="#保留值" class="headerlink" title="保留值"></a>保留值</h5><p>当某些字段不再使用时，例如更新消息类型时移除了某些字段，为了防止其他人重新使用了之前的字段名或字段序号而导致逻辑混乱的问题，可以把这些不用的字段设置为保留字段，关键字 <code>reserved</code> 用来设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Foo</span> &#123;<br>  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>, <span class="hljs-number">40</span> to max;<br>  reserved <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;BAR&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，以上的序号和字段名就不能后续使用了，避免了逻辑混乱。</p><h5 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h5><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;<br>  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>  <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将不同类型的消息定义在不同的 .proto 文件中，需要时导入进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">import &quot;myproject/other_protos.proto&quot;;<br></code></pre></td></tr></table></figure><h5 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h5><p>未知字段是格式良好的 Protocol Buffer 序列化数据，表示解析器无法识别的字段。例如，当旧二进制文件用新字段解析新二进制文件发送的数据时，这些新字段将成为旧二进制文件中的未知字段。</p><p>最初，proto3 消息在解析过程中总是丢弃未知字段，但在 3.5 版本中，我们重新引入了保留未知字段以匹配 proto2 行为。在 3.5 及更高版本中，未知字段在解析期间保留并包含在序列化输出中。</p><h5 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h5><p>Any 消息类型允许您将消息用作嵌入类型，而无需定义它们的 .proto。 Any 包含作为 <code>Bytes</code> 的任意序列化消息，以及充当全局唯一标识符并解析为该消息类型的 URL。要使用 Any 类型，您需要导入 google&#x2F;protobuf&#x2F;any.proto。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/any.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ErrorStatus</span> &#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">repeated</span> google.protobuf.Any details = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Onef"><a href="#Onef" class="headerlink" title="Onef"></a>Onef</h5><p>如果您有一条包含多个字段的消息，并且最多同时设置一个字段，您可以强制执行此行为并使用 <code>oneof</code> 功能节省内存。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SampleMessage</span> &#123;<br>  <span class="hljs-keyword">oneof</span> test_oneof &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">4</span>;<br>    SubMessage sub_message = <span class="hljs-number">9</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>如果您想创建关联映射作为数据定义的一部分，protocol buffers 提供了一种方便的快捷语法：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;key_type, value_type&gt; map_field = N;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;<span class="hljs-type">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="语法指导"><a href="#语法指导" class="headerlink" title="语法指导"></a>语法指导</h4><h5 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h5><p>您可以将可选的 <code>package</code> 说明符添加到 .proto 文件中，以防止协议消息类型之间的名称冲突。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">package</span> foo.bar;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Open</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>在 GO 中，该软件包被用作 GO 软件包名称，除非您在 .proto 文件中明确提供 <code>option go_package</code>。</p><h5 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h5><p>如果您想在 RPC（远程过程调用）系统中使用您的消息类型，您可以在 .proto 文件中定义一个 RPC 服务接口，并且协议缓冲区编译器将以您选择的语言生成服务接口代码和存根。因此，例如，如果您想使用获取 SearchRequest 并返回 SearchResponse 的方法定义 RPC 服务，您可以在 .proto 文件中定义它，如下所示：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 Proto Buffers 一起使用的最直接的 RPC 系统是 gRPC：由 Google 开发的一种语言和平台中立的开源 RPC 系统。 gRPC 特别适用于协议缓冲区，并允许您使用特殊的协议缓冲区编译器插件直接从 .proto 文件生成相关的 RPC 代码。</p><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><p>.proto 文件中支持定义选项。全部的选项定义在 <code>google/protobuf/descriptor.proto</code> 中。</p><p>例如我们使用 option go_package 选项来控制生成的 go 代码所在的 package。</p><h3 id="gRPC-支持四种定义服务的方法"><a href="#gRPC-支持四种定义服务的方法" class="headerlink" title="gRPC 支持四种定义服务的方法"></a>gRPC 支持四种定义服务的方法</h3><h4 id="一元-RPC"><a href="#一元-RPC" class="headerlink" title="一元 RPC"></a>一元 RPC</h4><p>首先考虑最简单的 RPC 类型，其中客户端发送单个请求并返回单个响应。</p><ol><li>一旦客户端调用了一个存根方法，服务器就会被通知该 RPC 已被调用，其中包含该调用的客户端元数据、方法名称和指定的截止日期（如果适用）。</li><li>然后，服务器可以立即发回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。</li><li>一旦服务器收到客户端的请求消息，它就会执行任何必要的工作来创建和填充响应。然后将响应连同状态详细信息（状态代码和可选状态消息）和可选尾随元数据一起返回（如果成功）给客户端。</li><li>如果响应状态为 OK，则客户端得到响应，从而完成客户端的调用。</li></ol><blockquote><p>一元  RPC，其中客户端向服务器发送单个请求并获得单个响应，就像正常的函数调用一样</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="服务器流式-RPC"><a href="#服务器流式-RPC" class="headerlink" title="服务器流式 RPC"></a>服务器流式 RPC</h4><p>服务器流式 RPC 类似于一元 RPC，除了服务器返回消息流以响应客户端的请求。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端在拥有所有服务器消息后完成。</p><blockquote><p>服务器流式 RPC，其中客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。 gRPC 保证单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h4><p>客户端流式 RPC 类似于一元 RPC，不同之处在于客户端向服务器发送消息流而不是单个消息。服务器响应一条消息（连同其状态详细信息和可选的尾随元数据），通常但不一定是在它收到所有客户端的消息之后</p><blockquote><p>客户端流式 RPC，其中客户端写入一系列消息并将它们发送到服务器，再次使用提供的流。一旦客户端完成了消息的写入，它就会等待服务器读取它们并返回它的响应。 gRPC 再次保证了单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h4><p>在双向流式 RPC 中，调用由调用方法的客户端和接收客户端元数据、方法名称和截止日期的服务器发起。服务器可以选择发回其初始元数据或等待客户端开始流式传输消息。</p><p>客户端和服务器端流处理是特定于应用程序的。<strong>由于这两个流是独立的，客户端和服务器可以以任意顺序读写消息</strong>。例如，服务器可以等到它收到客户端的所有消息后再写入它的消息，或者服务器和客户端可以玩 “ping-pong”——服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。</p><blockquote><p>双向流式 RPC，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。保留每个流中消息的顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> BidiHello(stream HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span><br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期指的是 gRPC 客户端调用 gRPC 服务端方法的过程。区别于不同的4种服务定义，过程如下：</p><h4 id="截止日期-超时"><a href="#截止日期-超时" class="headerlink" title="截止日期&#x2F;超时"></a>截止日期&#x2F;超时</h4><p>gRPC 允许客户端指定在 RPC 因 DEADLINE_EXCEEDED 错误而终止之前，他们愿意等待 RPC 完成多长时间。在服务器端，服务器可以查询特定的 RPC 是否已超时，或者还剩多少时间来完成 RPC。指定期限或超时是特定于语言的：一些语言 API 根据超时（持续时间）工作，而一些语言 API 根据期限（固定时间点）工作，可能有也可能没有默认期限。</p><h4 id="RPC-终止"><a href="#RPC-终止" class="headerlink" title="RPC 终止"></a>RPC 终止</h4><p>在 gRPC 中，客户端和服务器都对调用是否成功做出独立的本地判断，并且它们的结论可能不匹配。这意味着，例如，您可能有一个 RPC 在服务器端成功完成（“我已经发送了所有响应！”）但在客户端失败（“响应在我的截止日期之后到达！”）。服务器也可以在客户端发送所有请求之前决定完成。</p><h4 id="取消-RPC"><a href="#取消-RPC" class="headerlink" title="取消 RPC"></a>取消 RPC</h4><p>客户端或服务器都可以随时取消 RPC。取消会立即终止 RPC，以便不再进行任何工作。</p><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><blockquote><p> http2 是 gRPC 中的关键协议</p></blockquote><h3 id="HTTP1-存在的问题"><a href="#HTTP1-存在的问题" class="headerlink" title="HTTP1 存在的问题"></a>HTTP1 存在的问题</h3><ul><li>低效的 TCP 利用<ul><li>连接是一次性的，不能重复使用</li></ul></li><li>臃肿的消息首部<ul><li>请求行（url、请求头、版本）</li><li>首部行</li><li>空行</li><li>实体主体</li></ul></li><li>明文传输<ul><li>可以通过加 SSL 证书，将请求转成 HTTPS</li></ul></li><li>传输效率低</li></ul><h3 id="HTP2-改进的地方"><a href="#HTP2-改进的地方" class="headerlink" title="HTP2 改进的地方"></a>HTP2 改进的地方</h3><ul><li><p>传输的改进</p><ul><li>HTTP1 中一次处理一个请求，并且不能停止解析</li><li>HTTP1 中对于服务端来说无法预判使用多少内存</li><li>HTTP1 冗余过多的 LF 分隔符</li><li>HTTP2 中tcp连接之后不会断掉<ul><li>会将一次请求分成一定数量的帧，给关键帧打上标识，然后客户端会根据这些标识组装数据</li></ul></li></ul></li><li><p>请求头优化</p><ul><li><p>HTTP1 是属于无状态的，每次都需要将所有请求头发送到服务方（ http2 在将请求头帧发送到服务后，后续的帧只会发送不同的东西）</p><p><img src="https://i.imgur.com/qqbaMCU.png" alt="image-20241031212104738"></p></li><li><p>多路复用</p><ul><li>HTTP1 连接是一次性的，打开一个网页会发起多次请求，每个请求完之后就会关闭</li><li>HTTP2 在请求过程中只会建立一次连接，后续的请求都可以通过这个连接进行发送</li></ul></li><li><p>服务端可推送</p><ul><li><p>HTTP1 不支持</p></li><li><p>HTTP2 服务端与客户端会保持长连接</p></li></ul></li></ul></li></ul><h2 id="gRPC-实战"><a href="#gRPC-实战" class="headerlink" title="gRPC 实战"></a>gRPC 实战</h2><h3 id="gRPC-的服务端连接调度实现原理分析"><a href="#gRPC-的服务端连接调度实现原理分析" class="headerlink" title="gRPC 的服务端连接调度实现原理分析"></a>gRPC 的服务端连接调度实现原理分析</h3><h4 id="自定义服务加载"><a href="#自定义服务加载" class="headerlink" title="自定义服务加载"></a>自定义服务加载</h4><p><img src="https://i.imgur.com/DW8LO8s.png" alt="image-20241031212647536"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User_ServiceDesc is the grpc.ServiceDesc for User service.</span><br><span class="hljs-comment">// It&#x27;s only intended for direct use with grpc.RegisterService,</span><br><span class="hljs-comment">// and not to be introspected or modified (even as a copy)</span><br><span class="hljs-keyword">var</span> User_ServiceDesc = grpc.ServiceDesc&#123;<br>    ServiceName: <span class="hljs-string">&quot;user.User&quot;</span>,<br>    HandlerType: (*UserServer)(<span class="hljs-literal">nil</span>),<br>    Methods: []grpc.MethodDesc&#123;<br>       &#123;<br>          MethodName: <span class="hljs-string">&quot;GetUser&quot;</span>,<br>          Handler:    _User_GetUser_Handler,<br>       &#125;,<br>    &#125;,<br>    Streams:  []grpc.StreamDesc&#123;&#125;,<br>    Metadata: <span class="hljs-string">&quot;user.proto&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">User_GetUser_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    in := <span class="hljs-built_in">new</span>(GetUserReq)<br>    <span class="hljs-keyword">if</span> err := dec(in); err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">if</span> interceptor == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, in)<br>    &#125;<br>    info := &amp;grpc.UnaryServerInfo&#123;<br>       Server:     srv,<br>       FullMethod: User_GetUser_FullMethodName,<br>    &#125;<br>    handler := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, req.(*GetUserReq))<br>    &#125;<br>    <span class="hljs-keyword">return</span> interceptor(ctx, in, info, handler)<br>&#125;<br><br><span class="hljs-comment">// RegisterService registers a service and its implementation to the gRPC</span><br><span class="hljs-comment">// server. It is called from the IDL generated code. This must be called before</span><br><span class="hljs-comment">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to</span><br><span class="hljs-comment">// ensure it implements sd.HandlerType.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> RegisterService(sd *ServiceDesc, ss any) &#123;<br>    <span class="hljs-keyword">if</span> ss != <span class="hljs-literal">nil</span> &#123;<br>       ht := reflect.TypeOf(sd.HandlerType).Elem()<br>       st := reflect.TypeOf(ss)<br>       <span class="hljs-keyword">if</span> !st.Implements(ht) &#123;<br>          logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;</span>, st, ht)<br>       &#125;<br>    &#125;<br>    s.register(sd, ss)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> register(sd *ServiceDesc, ss any) &#123;<br>    s.mu.Lock()<br>    <span class="hljs-keyword">defer</span> s.mu.Unlock()<br>    s.printf(<span class="hljs-string">&quot;RegisterService(%q)&quot;</span>, sd.ServiceName)<br>    <span class="hljs-keyword">if</span> s.serve &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    <span class="hljs-keyword">if</span> _, ok := s.services[sd.ServiceName]; ok &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    info := &amp;serviceInfo&#123;<br>       serviceImpl: ss,<br>       methods:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*MethodDesc),<br>       streams:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*StreamDesc),<br>       mdata:       sd.Metadata,<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Methods &#123;<br>       d := &amp;sd.Methods[i]<br>       info.methods[d.MethodName] = d<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Streams &#123;<br>       d := &amp;sd.Streams[i]<br>       info.streams[d.StreamName] = d<br>    &#125;<br>    s.services[sd.ServiceName] = info<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务初始化"><a href="#服务初始化" class="headerlink" title="服务初始化"></a>服务初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go">s := grpc.NewServer()<br><br><br><br><span class="hljs-comment">// NewServer creates a gRPC server which has no service registered and has not</span><br><span class="hljs-comment">// started to accept requests yet.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(opt ...ServerOption)</span></span> *Server &#123;<br>    opts := defaultServerOptions<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> globalServerOptions &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opt &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    s := &amp;Server&#123;<br>       lis:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[net.Listener]<span class="hljs-type">bool</span>),<br>       opts:     opts,<br>       conns:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[transport.ServerTransport]<span class="hljs-type">bool</span>),<br>       services: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*serviceInfo),<br>       quit:     grpcsync.NewEvent(),<br>       done:     grpcsync.NewEvent(),<br>       channelz: channelz.RegisterServer(<span class="hljs-string">&quot;&quot;</span>),<br>    &#125;<br>    chainUnaryServerInterceptors(s)<br>    chainStreamServerInterceptors(s)<br>    s.cv = sync.NewCond(&amp;s.mu)<br>    <span class="hljs-keyword">if</span> EnableTracing &#123;<br>       _, file, line, _ := runtime.Caller(<span class="hljs-number">1</span>)<br>       s.events = newTraceEventLog(<span class="hljs-string">&quot;grpc.Server&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, file, line))<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> s.opts.numServerWorkers &gt; <span class="hljs-number">0</span> &#123;<br>       s.initServerWorkers()<br>    &#125;<br><br>    channelz.Info(logger, s.channelz, <span class="hljs-string">&quot;Server created&quot;</span>)<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrInterceptor</span><span class="hljs-params">(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp any, err <span class="hljs-type">error</span>) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;err begin&quot;</span>)<br>    resp, err = handler(ctx, req)<br>    fmt.Println(<span class="hljs-string">&quot;err end&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br><br>    s := grpc.NewServer(grpc.ChainUnaryInterceptor(interceptor.LogInterceptor, interceptor.ErrInterceptor))<br>    user.RegisterUserServer(s, <span class="hljs-built_in">new</span>(UserService))<br>    log.Println(<span class="hljs-string">&quot;启动成功&quot;</span>)<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="请求监听处理"><a href="#请求监听处理" class="headerlink" title="请求监听处理"></a>请求监听处理</h4><p><img src="https://i.imgur.com/ImC3Tbc.png" alt="image-20241031212849420"></p><h3 id="go-zero"><a href="#go-zero" class="headerlink" title="go-zero"></a>go-zero</h3><blockquote><p>对 go-zero的安装不做赘述</p></blockquote><h4 id="实践-go-zero-基础功能案例（api-rpc）"><a href="#实践-go-zero-基础功能案例（api-rpc）" class="headerlink" title="实践 go-zero 基础功能案例（api&#x2F;rpc）"></a>实践 go-zero 基础功能案例（api&#x2F;rpc）</h4><ol><li><p>编写.proto文件</p></li><li><p>构建 rpc 服务</p></li><li><p>编写 api 文件</p><ol><li><p>构建 api 服务</p><ol><li><p>构建 rpc 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl rpc new user<br></code></pre></td></tr></table></figure></li><li><p>构建 api 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl api new api<br></code></pre></td></tr></table></figure></li><li><p>一般情况是编写 <code>.api</code> 文件和编写 <code>.proto</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">      goctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.<br>      goctl api go -api user.api -<span class="hljs-built_in">dir</span> . -style gozero<br><br>2. 服务联调<br><br>   ```yaml<br>   <span class="hljs-comment"># api etc user.yaml</span><br>   Name: User<br>   Host: 0.0.0.0<br>   Port: 8888<br>   <br>   UserRpc:<br>     Etcd:<br>       Hosts:<br>         - 117.50.179.8:2379<br>       Key: user.rpc<br>       User: <span class="hljs-string">&quot;root&quot;</span><br>       Pass: <span class="hljs-string">&quot;fghf987....&quot;</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// internal config config.go</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>rest.RestConf<br><br>UserRpc zrpc.RpcClientConf<br>&#125;<br><br><br><span class="hljs-comment">// svc servicecontext.go</span><br><span class="hljs-keyword">type</span> ServiceContext <span class="hljs-keyword">struct</span> &#123;<br>Config     config.Config<br>UserClient userclient.User<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServiceContext</span><span class="hljs-params">(c config.Config)</span></span> *ServiceContext &#123;<br><span class="hljs-keyword">return</span> &amp;ServiceContext&#123;<br>Config:     c,<br>UserClient: userclient.NewUser(zrpc.MustNewClient(c.UserRpc)),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// logic userlogic.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *UserLogic)</span></span> User(req *types.UserReq) (resp *types.UserResp, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// todo: add your logic here and delete this line</span><br>getUserResp, err := l.svcCtx.UserClient.GetUser(l.ctx, &amp;user.GetUserReq&#123;<br>Id: req.Id,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;types.UserResp&#123;<br>Id:    getUserResp.Id,<br>Name:  getUserResp.Name,<br>Phone: getUserResp.Phone,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><ol><li><p>编写 <em>.sql</em> 文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>` (<br>                        `id` <span class="hljs-type">BIGINT</span> UNSIGNED AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;用户ID，主键&#x27;</span>,<br>                        `username` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>                        `email` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;电子邮箱&#x27;</span>,<br>                        `password` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;密码（加密存储）&#x27;</span>,<br>                        `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;手机号&#x27;</span>,<br>                        `status` TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态：1=启用，0=禁用&#x27;</span>,<br>                        `created_at` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>                        `updated_at` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>                        <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>生成 model</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl model mysql ddl --src user.sql --<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;./models/&quot;</span> -c<br></code></pre></td></tr></table></figure><p><code>-c</code>表示使用缓存</p></li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li><p>core</p><p>工具集包含数据处理、熔断器、服务发现等工具</p></li><li><p>internal</p><p>包含框架处理、请求编码、健康检测等功能</p></li><li><p>zrpc</p><p>是rpc服务端与客户端的核心代码</p></li></ul><h5 id="go-zero-如何适配grpc"><a href="#go-zero-如何适配grpc" class="headerlink" title="go-zero 如何适配grpc"></a>go-zero 如何适配grpc</h5><h5 id="服务如何初始化"><a href="#服务如何初始化" class="headerlink" title="服务如何初始化"></a>服务如何初始化</h5><h5 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h5>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码分析</title>
    <link href="/2024/10/31/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/10/31/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol><li>确定阅读目标</li><li>站在实现的思路上分析<br>如果我要去实现这个功能，应该怎么做</li><li>源码调用链分析。。。（比较难理解）</li></ol><p><img src="https://i.imgur.com/kkSIlLa.png" alt="image-20241031203815020"></p>]]></content>
    
    
    <categories>
      
      <category>醍醐灌顶</category>
      
      <category>技术篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC</title>
    <link href="/2024/10/31/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/"/>
    <url>/2024/10/31/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="golang中的-RPC"><a href="#golang中的-RPC" class="headerlink" title="golang中的 RPC"></a>golang中的 RPC</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    Id    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id,omitempty&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name,omitempty&quot;`</span><br>    Phone <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;phone&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">var</span> users = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*User&#123;<br>    <span class="hljs-string">&quot;1&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;1&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xx&quot;</span>,<br>    &#125;,<br>    <span class="hljs-string">&quot;2&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;2&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xxx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-keyword">type</span> UserServer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserServer)</span></span> GetUser(req GetUserReq, resp *GetUserResp) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> u, ok := users[req.Id]; ok &#123;<br>        *resp = GetUserResp&#123;<br>            Id:    u.Id,<br>            Name:  u.Name,<br>            Phone: u.Phone,<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;未找到用户&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    userServer := <span class="hljs-built_in">new</span>(UserServer)<br>    rpc.Register(userServer)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;监听客户端连接失败&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> rpc.ServeConn(conn)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> client.Close()<br>    <span class="hljs-keyword">var</span> (<br>        req = GetUserReq&#123;<br>            Id: <span class="hljs-string">&quot;3&quot;</span>,<br>        &#125;<br>        res GetUserResp<br>    )<br>    err = client.Call(<span class="hljs-string">&quot;UserServer.GetUser&quot;</span>, req, &amp;res)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;请求异常&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    log.Println(res)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="怎么分析这一块的源码？"><a href="#怎么分析这一块的源码？" class="headerlink" title="怎么分析这一块的源码？"></a>怎么分析这一块的源码？</h3><blockquote><p>源码分析三步</p></blockquote><ol><li><p>目的</p><ol><li>客户端为啥能直接调用服务端的方法</li><li>客户端与服务端的交互的数据格式确定</li></ol></li><li><p>构思实现：</p><ol><li><p>Rpc 之间通讯的数据格式与传输参数</p></li><li><p>Rpc 之间的的通讯数据格式与传输参数</p><p>标准库是通过 json 实现的，需要考虑其他类型转换情况</p></li><li><p>接受到请求消息之后是如何运行对应服务的</p><p>​<img src="https://i.imgur.com/PTGAkaq.png" alt="image-20241031203029336"></p></li></ol></li><li><p>直接阅读源码</p></li></ol><h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><p><img src="https://i.imgur.com/cE6mxPs.png" alt="image-20241031203127867"></p>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录认证篇</title>
    <link href="/2024/08/23/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%AF%87/"/>
    <url>/2024/08/23/%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6/%E6%8A%80%E6%9C%AF%E7%AF%87/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>Cookie</strong> 是一种在 Web 浏览器中存储数据的小文件，主要用于在用户与网站之间传递状态信息。它们使得 Web 服务器可以记住用户的状态或信息，并在后续请求中恢复这些状态。Cookies 被广泛用于各种目的，包括用户认证、会话管理、个性化设置以及跟踪用户行为等。</p><p><strong>Cookie</strong> 是由 <strong>Web</strong> 服务器通过 <strong>HTTP</strong> 响应头发送到用户浏览器的一个小的文本数据块。浏览器会将其存储在本地，当用户访问相同网站时，浏览器会将这些 <strong>Cookie</strong> 附带在请求中<code>发送回服务器</code>。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><p><strong>名称（Name）</strong>: Cookie 的标识符。</p></li><li><p><strong>值（Value）</strong>: 与名称相关联的数据。</p></li><li><p><strong>过期时间（Expires）</strong>: Cookie 的有效期，浏览器在此时间之前会保持 Cookie 的存在。如果没有设置过期时间，Cookie 是会话 Cookie，会在浏览器关闭时删除。</p></li><li><p><strong>路径（Path）</strong>: 指定 Cookie 适用的 URL 路径。</p></li><li><p><strong>域（Domain）</strong>: 指定 Cookie 可用的域名。</p></li><li><p><strong>安全标志（Secure）</strong>: 指示 Cookie 只能通过 HTTPS 协议传输。</p><ul><li><strong>HttpOnly 标志</strong>: 防止 JavaScript 访问 Cookie，以增加安全性。</li></ul></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h4><ul><li><strong>用户登录</strong>: 记录用户的登录状态，避免每次访问都要求重新登录。</li><li><strong>购物车</strong>: 在电商网站上存储购物车的内容。</li></ul><h4 id="用户个性化"><a href="#用户个性化" class="headerlink" title="用户个性化"></a>用户个性化</h4><ul><li><strong>用户设置</strong>: 记录用户的语言偏好、主题设置等个性化信息。</li><li><strong>推荐系统</strong>: 根据用户的行为历史提供个性化推荐。</li></ul><h4 id="跟踪与分析"><a href="#跟踪与分析" class="headerlink" title="跟踪与分析"></a>跟踪与分析</h4><ul><li><strong>用户行为分析</strong>: 跟踪用户在网站上的活动，以分析用户行为和网站性能。</li><li><strong>广告定向</strong>: 跟踪用户的兴趣，以展示相关的广告。</li></ul><h3 id="如何使用-Cookie"><a href="#如何使用-Cookie" class="headerlink" title="如何使用 Cookie"></a>如何使用 Cookie</h3><p>在 Go 的 <code>net/http</code> 包中，你可以通过 HTTP 请求和响应操作 Cookies。以下是一些基本操作的示例：</p><h4 id="设置-Cookie"><a href="#设置-Cookie" class="headerlink" title="设置 Cookie"></a>设置 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个新的 Cookie</span><br>    cookie := &amp;http.Cookie&#123;<br>        Name:     <span class="hljs-string">&quot;username&quot;</span>,<br>        Value:    <span class="hljs-string">&quot;john_doe&quot;</span>,<br>        Path:     <span class="hljs-string">&quot;/&quot;</span>,<br>        MaxAge:   <span class="hljs-number">3600</span>, <span class="hljs-comment">// 1 hour</span><br>        HttpOnly: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 不能被 JavaScript 访问</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置 Cookie</span><br>    http.SetCookie(w, cookie)<br><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie has been set!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/set-cookie&quot;</span>, setCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 读取 Cookie</span><br>    cookie, err := r.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err == http.ErrNoCookie &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Cookie not found&quot;</span>, http.StatusNotFound)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Error retrieving cookie&quot;</span>, http.StatusInternalServerError)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Cookie 的值</span><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie value: &quot;</span> + cookie.Value))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/read-cookie&quot;</span>, readCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个新的 Cookie，并设置过期时间</span><br>    cookie := &amp;http.Cookie&#123;<br>        Name:    <span class="hljs-string">&quot;username&quot;</span>,<br>        Value:   <span class="hljs-string">&quot;&quot;</span>,<br>        Path:    <span class="hljs-string">&quot;/&quot;</span>,<br>        Expires: time.Unix(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-comment">// 设置为过去的时间</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除 Cookie</span><br>    http.SetCookie(w, cookie)<br><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie has been deleted!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/delete-cookie&quot;</span>, deleteCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>Session（会话）</strong> 是一种在用户与 Web 应用程序之间保持状态的机制，通常用于存储和管理用户的状态信息。与 Cookie 不同，Session 数据通常存储在服务器端，而非客户端。Session 通常用来跟踪用户的会话状态、存储用户数据、处理认证和授权等</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Session 是一段时间内用户与服务器之间的交互。在用户首次访问网站时，服务器创建一个 Session，并为其分配一个唯一的标识符（通常是一个随机生成的字符串，称为 Session ID）。这个 Session ID 通常会被存储在用户的 Cookie 中，随着每次请求被发送到服务器。服务器使用这个 Session ID 来查找并检索对应的会话数据。</p><p>组成:</p><ul><li><strong>Session ID</strong>: 唯一标识用户会话的标识符。</li><li><strong>Session 数据</strong>: 与用户相关的信息，比如用户身份、偏好设置、购物车内容等。</li><li><strong>Session 存储</strong>: Session 数据的存储方式，通常可以是内存、数据库、文件系统等。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>创建 Session</strong>: 用户首次访问应用时，服务器生成一个新的 Session ID，并创建一个新的会话存储区域。</p></li><li><p><strong>存储 Session 数据</strong>: 服务器将与用户相关的数据存储在会话中。</p></li><li><p><strong>传递 Session ID</strong>: 服务器将 Session ID 发送给客户端，通常通过 Cookie。</p></li><li><p><strong>识别 Session</strong>: 客户端在后续请求中将 Session ID 发送回服务器，服务器根据 Session ID 查找相应的会话数据。</p></li><li><p><strong>更新 Session 数据</strong>: 服务器可以更新会话数据，用户的每个请求都可以修改这些数据。</p></li><li><p><strong>销毁 Session</strong>: 会话可以在用户登出、会话超时或者服务器主动清除时被销毁。</p></li></ol><h3 id="Session-的用途"><a href="#Session-的用途" class="headerlink" title="Session 的用途"></a>Session 的用途</h3><h4 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h4><ul><li><strong>登录状态管理</strong>: 记录用户的登录状态，使得用户在浏览不同页面时不需要重新登录。</li></ul><h4 id="会话数据存储"><a href="#会话数据存储" class="headerlink" title="会话数据存储"></a>会话数据存储</h4><ul><li><strong>用户设置</strong>: 存储用户的个性化设置和偏好。</li><li><strong>购物车</strong>: 在电子商务网站上存储用户的购物车内容。</li></ul><h4 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h4><ul><li><strong>表单数据</strong>: 在多步表单过程中保持用户填写的数据。</li></ul><h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h2><p>Cookie 和 Session 的关系 </p><p><strong>服务器创建和管理 Session</strong>: 服务器创建 Session，并为每个会话分配唯一的 Session ID。</p><p><strong>浏览器存储和发送 Cookie</strong>: 服务器通过 Cookie 将 Session ID 发送到浏览器，浏览器将 Cookie 随后每次请求自动发送回服务器。</p><p><strong>服务器使用 Session ID 访问 Session 数据</strong>: 服务器通过 Cookie 中的 Session ID 查找和操作对应的 Session 数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟的 session 存储 (在真实应用中，通常会使用数据库或内存缓存)</span><br><span class="hljs-keyword">var</span> sessionStore = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>    http.HandleFunc(<span class="hljs-string">&quot;/welcome&quot;</span>, welcomeHandler)<br><br>    fmt.Println(<span class="hljs-string">&quot;Server started at :8080&quot;</span>)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// 登录处理程序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 模拟用户登录并生成 Session ID</span><br>    sessionID := <span class="hljs-string">&quot;123456&quot;</span> <span class="hljs-comment">// 在真实场景下，这应该是一个随机生成的唯一 ID</span><br>    userID := <span class="hljs-string">&quot;user42&quot;</span>    <span class="hljs-comment">// 假设这是从数据库中查到的用户ID</span><br><br>    <span class="hljs-comment">// 将 Session ID 和 用户ID 存储到 sessionStore 中</span><br>    sessionStore[sessionID] = userID<br><br>    <span class="hljs-comment">// 将 Session ID 写入 Cookie</span><br>    cookie := http.Cookie&#123;<br>        Name:    <span class="hljs-string">&quot;session_id&quot;</span>,<br>        Value:   sessionID,<br>        Expires: time.Now().Add(<span class="hljs-number">24</span> * time.Hour), <span class="hljs-comment">// 设置 Cookie 有效期为24小时</span><br>    &#125;<br>    http.SetCookie(w, &amp;cookie)<br><br>    fmt.Fprintf(w, <span class="hljs-string">&quot;User logged in. Session ID set: %s\n&quot;</span>, sessionID)<br>&#125;<br><br><span class="hljs-comment">// 欢迎页面处理程序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">welcomeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 从请求中获取 Cookie</span><br>    cookie, err := r.Cookie(<span class="hljs-string">&quot;session_id&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err == http.ErrNoCookie &#123;<br>            <span class="hljs-comment">// 如果没有找到 session_id Cookie</span><br>            http.Error(w, <span class="hljs-string">&quot;Session not found&quot;</span>, http.StatusUnauthorized)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        http.Error(w, <span class="hljs-string">&quot;Internal Server Error&quot;</span>, http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Cookie 中的 Session ID 查找对应的用户</span><br>    sessionID := cookie.Value<br>    userID, exists := sessionStore[sessionID]<br>    <span class="hljs-keyword">if</span> !exists &#123;<br>        http.Error(w, <span class="hljs-string">&quot;Invalid Session ID&quot;</span>, http.StatusUnauthorized)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果 Session ID 有效，显示欢迎信息</span><br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome back, User ID: %s\n&quot;</span>, userID)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h1><blockquote><p>单点登录有多种方式，常见的形式有</p><ol><li>基于 Cookie</li><li>基于 Token</li><li>基于重定向</li><li>基于Session</li><li>LDAP</li></ol></blockquote><h2 id="基于-Cookie"><a href="#基于-Cookie" class="headerlink" title="基于 Cookie"></a>基于 Cookie</h2><p><strong>原理</strong>：同一域下的子系统<code>共享 Cookie</code>。用户在一个子系统登录后，生成的 Cookie 可以被其他子系统读取，从而实现单点登录。</p><p><strong>特点</strong>：</p><ul><li>适用于同域名的多个子域系统（如 <code>a.example.com</code> 和 <code>b.example.com</code>）。</li><li>配置简单，但无法跨域。</li></ul><p><strong>限制</strong>：Cookie 受浏览器和域限制，无法在跨域环境下直接使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 用户访问系统<br>condA=&gt;condition: 是否已登录？<br>condB=&gt;condition: 是否共享 Cookie 可用？<br>login=&gt;operation: 重定向到 SSO 登录<br>generate=&gt;operation: 生成共享 Cookie<br>redirectA=&gt;operation: 重定向回系统 A<br>accessA=&gt;operation: 系统 A 允许访问<br>accessB=&gt;operation: 系统 B 允许访问<br><br>st-&gt;condA<br>condA(no)-&gt;login<br>login-&gt;generate<br>generate-&gt;redirectA<br>redirectA-&gt;accessA<br>condA(yes)-&gt;condB<br>condB(yes)-&gt;accessB<br>condB(no)-&gt;login<br><br><br><br></code></pre></td></tr></table></figure><h3 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h3><ol><li>SSO 服务器<ul><li>负责用户认证</li><li>登录成功后生成一个共享的 Cookie（如 <code>sso_token</code>），该 Cookie 设置为 <code>Domain=.example.com</code>，以便子系统共享。</li></ul></li><li>子系统 A 和 B<ul><li>用户访问时，检查共享 Cookie 是否存在并有效</li><li>若无效，重定向用户到 SSO 服务器登录</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><blockquote><p>用 Golang 实现</p><p>​可以增加 target_url 当 SSO 服务认证完成之后跳转到原页面</p></blockquote><ol><li><p>SSO 服务端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 模拟用户登录逻辑</span><br>username := r.FormValue(<span class="hljs-string">&quot;username&quot;</span>)<br>password := r.FormValue(<span class="hljs-string">&quot;password&quot;</span>)<br><br><span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;user&quot;</span> &amp;&amp; password == <span class="hljs-string">&quot;pass&quot;</span> &#123;<br><span class="hljs-comment">// 登录成功，设置 Cookie，Domain 为 .example.com</span><br>http.SetCookie(w, &amp;http.Cookie&#123;<br>Name:     <span class="hljs-string">&quot;sso_token&quot;</span>,<br>Value:    <span class="hljs-string">&quot;random-generated-token&quot;</span>,<br>Domain:   <span class="hljs-string">&quot;.example.com&quot;</span>, <span class="hljs-comment">// 共享 Cookie 的关键</span><br>Path:     <span class="hljs-string">&quot;/&quot;</span>,<br>Expires:  time.Now().Add(<span class="hljs-number">24</span> * time.Hour),<br>HttpOnly: <span class="hljs-literal">true</span>,<br>&#125;)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Login successful!&quot;</span>))<br><span class="hljs-keyword">return</span><br>&#125;<br>http.Error(w, <span class="hljs-string">&quot;Invalid credentials&quot;</span>, http.StatusUnauthorized)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>子系统 A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">homeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 检查共享 Cookie</span><br>cookie, err := r.Cookie(<span class="hljs-string">&quot;sso_token&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 未登录，重定向到 SSO 服务器</span><br>http.Redirect(w, r, <span class="hljs-string">&quot;http://sso.example.com:8080/login&quot;</span>, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 验证 token 是否有效（此处简化，假设有效）</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome to System A! Your token: %s&quot;</span>, cookie.Value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, homeHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>子系统 B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">homeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 检查共享 Cookie</span><br>cookie, err := r.Cookie(<span class="hljs-string">&quot;sso_token&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 未登录，重定向到 SSO 服务器</span><br>http.Redirect(w, r, <span class="hljs-string">&quot;http://sso.example.com:8080/login&quot;</span>, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 验证 token 是否有效（此处简化，假设有效）</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome to System B! Your token: %s&quot;</span>, cookie.Value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, homeHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8082&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h3><ol><li><p>启动 SSO 服务（端口 8080）、子系统 A（8081）和子系统 B（8082）。</p></li><li><p>在浏览器访问 <code>http://system-a.example.com:8081/</code>：</p><ul><li>第一次访问会跳转到 <code>http://sso.example.com:8080/login</code> 登录。</li></ul></li><li><p>登录后，带有 <code>sso_token</code> 的共享 Cookie 被写入。</p></li><li><p>再访问 <code>http://system-b.example.com:8082/</code> 时，无需登录即可访问。</p></li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ol><li><strong>共享 Cookie 的域配置</strong>：<ul><li><code>Domain=.example.com</code>，确保所有子域都能访问同一 Cookie。</li></ul></li><li><strong>安全考虑</strong>：<ul><li>使用 <code>HttpOnly</code> 和 <code>Secure</code> 标志。</li><li>实际系统中应对 <code>sso_token</code> 进行加密签名，并在服务端验证。</li></ul></li><li><strong>缺陷</strong>：<ul><li>只能用于同一顶级域名及其子域，无法支持跨域。</li></ul></li></ol><h2 id="基于-Token"><a href="#基于-Token" class="headerlink" title="基于 Token"></a>基于 Token</h2><p><strong>原理</strong>：用户登录后获取一个令牌（如 JWT），此令牌在后续请求中被带上，验证用户身份。</p><p><strong>特点</strong>：</p><ul><li>无需依赖 Cookie，可通过 HTTP Header 携带 Token。</li><li>适合分布式架构，尤其是前后端分离系统。</li></ul><p><strong>典型协议</strong>：OAuth 2.0 和 OpenID Connect（OIDC）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 用户访问系统<br>checkToken=&gt;condition: 是否有 Token？<br>redirectToSSO=&gt;operation: 重定向到 SSO 登录<br>login=&gt;operation: 用户登录<br>generateToken=&gt;operation: SSO 生成 Token<br>returnToken=&gt;operation: 返回 Token 并重定向回系统<br>validateToken=&gt;operation: 系统验证 Token<br>accessGranted=&gt;operation: 允许访问<br>accessDenied=&gt;operation: 拒绝访问<br><br>st-&gt;checkToken<br>checkToken(no)-&gt;redirectToSSO<br>redirectToSSO-&gt;login<br>login-&gt;generateToken<br>generateToken-&gt;returnToken<br>returnToken-&gt;validateToken<br>checkToken(yes)-&gt;validateToken<br>validateToken(yes)-&gt;accessGranted<br>validateToken(no)-&gt;accessDenied<br><br></code></pre></td></tr></table></figure><h3 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h3><ol><li><strong>认证服务器</strong>：<ul><li>用户登录后生成一个 Token（如 JWT）。</li><li>返回 Token 给客户端。</li></ul></li><li><strong>子系统</strong>：<ul><li>客户端请求子系统时，将 Token 放在请求头中（如 <code>Authorization: Bearer &lt;token&gt;</code>）。</li><li>子系统通过解析或验证 Token 判断用户身份。</li></ul></li></ol><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><ol><li><p>认证服务器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/golang-jwt/jwt/v5&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> jwtKey = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;your-secret-key&quot;</span>)<br><br><span class="hljs-comment">// 用户登录信息结构</span><br><span class="hljs-keyword">type</span> Credentials <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// JWT Claims</span><br><span class="hljs-keyword">type</span> Claims <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>jwt.RegisteredClaims<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">var</span> creds Credentials<br>err := json.NewDecoder(r.Body).Decode(&amp;creds)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || creds.Username == <span class="hljs-string">&quot;&quot;</span> || creds.Password == <span class="hljs-string">&quot;&quot;</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Invalid request&quot;</span>, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 模拟用户验证</span><br><span class="hljs-keyword">if</span> creds.Username != <span class="hljs-string">&quot;user&quot;</span> || creds.Password != <span class="hljs-string">&quot;pass&quot;</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Unauthorized&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 创建 Token</span><br>expirationTime := time.Now().Add(<span class="hljs-number">1</span> * time.Hour)<br>claims := &amp;Claims&#123;<br>Username: creds.Username,<br>RegisteredClaims: jwt.RegisteredClaims&#123;<br>ExpiresAt: jwt.NewNumericDate(expirationTime),<br>&#125;,<br>&#125;<br>token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)<br>tokenString, err := token.SignedString(jwtKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Could not create token&quot;</span>, http.StatusInternalServerError)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 返回 Token</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;&quot;token&quot;:&quot;`</span> + tokenString + <span class="hljs-string">`&quot;&#125;`</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>子系统 A 和 B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><br><span class="hljs-string">&quot;github.com/golang-jwt/jwt/v5&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> jwtKey = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;your-secret-key&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateToken</span><span class="hljs-params">(tokenString <span class="hljs-type">string</span>)</span></span> (*Claims, <span class="hljs-type">error</span>) &#123;<br>claims := &amp;Claims&#123;&#125;<br>token, err := jwt.ParseWithClaims(tokenString, claims, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> jwtKey, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || !token.Valid &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>authHeader := r.Header.Get(<span class="hljs-string">&quot;Authorization&quot;</span>)<br><span class="hljs-keyword">if</span> !strings.HasPrefix(authHeader, <span class="hljs-string">&quot;Bearer &quot;</span>) &#123;<br>http.Error(w, <span class="hljs-string">&quot;Unauthorized&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 提取 Token</span><br>tokenString := strings.TrimPrefix(authHeader, <span class="hljs-string">&quot;Bearer &quot;</span>)<br>claims, err := validateToken(tokenString)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Unauthorized&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 返回资源</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome %s! You have accessed the resource.&quot;</span>, claims.Username)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/resource&quot;</span>, resourceHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="测试步骤-1"><a href="#测试步骤-1" class="headerlink" title="测试步骤"></a>测试步骤</h3><ol><li><p>启动认证服务器（端口 8080）和子系统 A（端口 8081）。</p></li><li><p>使用工具（如 <code>curl</code> 或 Postman）发送登录请求：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scilab">bash<br><br><br>复制代码<br>curl -X POST http:<span class="hljs-comment">//localhost:8080/login \</span><br>-H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>-d <span class="hljs-string">&#x27;&#123;&quot;</span>username<span class="hljs-string">&quot;:&quot;</span>user<span class="hljs-string">&quot;, &quot;</span>password<span class="hljs-string">&quot;:&quot;</span>pass<span class="hljs-string">&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>返回结果（示例）：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span><br><br>复制代码<br>&#123;<span class="hljs-string">&quot;token&quot;</span>:<span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用返回的 Token 访问子系统 A 的资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash<br><br><br>复制代码<br>curl http://localhost:8081/resource \<br>-H <span class="hljs-string">&quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;</span><br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">plaintext<br><br><br>复制代码<br>Welcome <span class="hljs-keyword">user</span>! You have accessed the resource.<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ol><li><strong>Token 携带方式</strong>：<ul><li>通常通过 HTTP Header（<code>Authorization: Bearer &lt;token&gt;</code>）。</li><li>也可以通过 URL 参数（不推荐）或 Cookie。</li></ul></li><li><strong>Token 有效性</strong>：<ul><li>使用 JWT 的 <code>exp</code> 字段设置过期时间。</li><li>子系统应验证 Token 是否过期或是否伪造。</li></ul></li><li><strong>安全性</strong>：<ul><li>使用 HTTPS 确保 Token 传输安全。</li><li>Token 中不要存储敏感信息。</li></ul></li><li><strong>扩展性</strong>：<ul><li>子系统也可以向认证服务器验证 Token 是否已失效（可选），子系统校验的话必须采用对称加密算法。</li><li>可为 Token 添加角色权限字段以支持更细粒度的访问控制。</li></ul></li></ol><hr><p>这种基于 Token 的 SSO 机制非常适合前后端分离或分布式系统，支持跨域，也易于扩展为微服务架构的一部分。</p><h2 id="基于-Token-2"><a href="#基于-Token-2" class="headerlink" title="基于 Token 2"></a>基于 Token 2</h2><blockquote><p>上述 基于 Token 还有一种变种 由客户端（子系统）产生 Token， 然后其他系统拿token去提供token的子系统验证。</p></blockquote><p><img src="https://i.imgur.com/72FJyDK.png" alt="image-20241128133349175"></p><p>例子(以群杰系统为例)：A 系统想要访问 B系统的接口或则页面</p><ol><li>A 产生一个 token</li><li>A 请求 B 系统的认证接口<ol><li>请求参数带上 A 系统产生的token 和 需要跳转的url(target_url：b系统的接口或则页面)</li></ol></li><li>A 基于 token 提供一个能解析 token 的请求。然后能返回用户信息</li><li>B 在 上面第二步 A 请求 B 的接口的时候，调用 A 提供的解析 token 的请求，获取到用户信息</li><li>然后 B 在经历自己的业务后，重定向到 target_url（b系统的页面）</li></ol><h2 id="基于重定向"><a href="#基于重定向" class="headerlink" title="基于重定向"></a>基于重定向</h2><h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><ol><li><strong>用户未登录时</strong>：<ul><li>用户访问 <code>System A</code> 或 <code>System B</code>。</li><li>检测无有效登录状态，重定向到认证服务器登录页面。</li></ul></li><li><strong>登录成功后</strong>：<ul><li>认证服务器生成一个登录票据（如 <code>ticket</code> 或 <code>JWT</code>）。</li><li>将用户重定向回原子系统，同时附加 <code>ticket</code>。</li></ul></li><li><strong>子系统校验票据</strong>：<ul><li>子系统将 <code>ticket</code> 发送给认证服务器验证。</li><li>验证通过后为用户创建会话并允许访问资源。</li></ul></li></ol><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><ol><li><p>SSO 服务器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> tokenStore = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 假设的令牌存储</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> r.Method == http.MethodPost &#123;<br>username := r.FormValue(<span class="hljs-string">&quot;username&quot;</span>)<br>password := r.FormValue(<span class="hljs-string">&quot;password&quot;</span>)<br><br><span class="hljs-comment">// 简单的身份验证示例</span><br><span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;user&quot;</span> &amp;&amp; password == <span class="hljs-string">&quot;pass&quot;</span> &#123;<br>token := fmt.Sprintf(<span class="hljs-string">&quot;token-%d&quot;</span>, time.Now().Unix())<br>tokenStore[username] = token<br>http.Redirect(w, r, r.FormValue(<span class="hljs-string">&quot;redirect_uri&quot;</span>)+<span class="hljs-string">&quot;?token=&quot;</span>+token, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br>http.Error(w, <span class="hljs-string">&quot;Invalid credentials&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br>http.ServeFile(w, r, <span class="hljs-string">&quot;login.html&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>子系统</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">homeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>token := r.URL.Query().Get(<span class="hljs-string">&quot;token&quot;</span>)<br><span class="hljs-keyword">if</span> token == <span class="hljs-string">&quot;&quot;</span> &#123;<br>http.Redirect(w, r, <span class="hljs-string">&quot;http://localhost:8080/login?redirect_uri=http://localhost:8081/home&quot;</span>, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 验证令牌</span><br><span class="hljs-comment">// 可以拿 Token 去 SSO 服务器验证</span><br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/home&quot;</span>, homeHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="测试步骤-2"><a href="#测试步骤-2" class="headerlink" title="测试步骤"></a>测试步骤</h3><h2 id="基于-Session"><a href="#基于-Session" class="headerlink" title="基于 Session"></a>基于 Session</h2><p>常见的分布式 session 即可</p><p>一般是集群使用</p><h2 id="LDAP-认证"><a href="#LDAP-认证" class="headerlink" title="LDAP 认证"></a>LDAP 认证</h2><h1 id="Oauth-2-0"><a href="#Oauth-2-0" class="headerlink" title="Oauth 2.0"></a>Oauth 2.0</h1><blockquote><p>着重介绍如何接入， 及授权的过程</p><p>不详细介绍安全部分</p></blockquote><h2 id="背景及使用场景"><a href="#背景及使用场景" class="headerlink" title="背景及使用场景"></a>背景及使用场景</h2><ul><li>关于授权的开放网络标准，目前的版本是2.0版</li><li><a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">https://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></li><li>Oauth2.0 主要用于授权</li><li>核心就是向第三方颁发令牌，用于访问资源</li></ul><h2 id="四种获取授权码的方式"><a href="#四种获取授权码的方式" class="headerlink" title="四种获取授权码的方式"></a>四种获取授权码的方式</h2><ul><li>授权码（authorization code）</li><li>隐藏式（implicit）</li><li>密码式（resource owner password credentials）</li><li>凭证式（client credentials）</li></ul><table><thead><tr><th>方式</th><th>适用范围</th><th>特点</th></tr></thead><tbody><tr><td>授权码</td><td>有后端的 Web 应用</td><td>最常用最安全</td></tr><tr><td>隐藏式</td><td>纯前端 Web 应用</td><td>所有步骤在浏览器完成</td></tr><tr><td>密码式</td><td>高度信任应用</td><td>直接获取到用户名和密码</td></tr><tr><td>凭证式</td><td>命令行应用</td><td></td></tr></tbody></table><h3 id="授权码-（authorization-code）"><a href="#授权码-（authorization-code）" class="headerlink" title="授权码 （authorization  code）"></a>授权码 （authorization  code）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>最常用</li><li>安全性最高</li><li>适用于那些有后端的 Web 应用</li></ul><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li><p>A网站提供一个链接，用户点击后就会跳转到 B 网站。如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">https://b.com/oauth/authorize?<br>  response<span class="hljs-emphasis">_type=code&amp;</span><br><span class="hljs-emphasis">  client_</span>id=CLIENT<span class="hljs-emphasis">_ID&amp;</span><br><span class="hljs-emphasis">  redirect_</span>uri=CALLBACK<span class="hljs-emphasis">_URL&amp;</span><br><span class="hljs-emphasis">  scope=read</span><br></code></pre></td></tr></table></figure><ul><li><code>response_type</code>: <code>code</code> 要返回授权码</li><li><code>client_id</code>: 让 B 知道是谁在请求</li><li><code>redirect_url</code>: B 接受或者拒绝请求后的跳转网址</li><li><code>scope</code>: 表示请求的授权范围</li></ul></li><li><p>用户跳转之后， B 网站会要求用户登录，然后询问是否愿意给予 A 网站授权。用户表示同意，这时 B 网站会跳会<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs md">https://a.com/callback?code=AUTHORIZATION<span class="hljs-emphasis">_CODE</span><br></code></pre></td></tr></table></figure></li><li><p>A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md">https://b.com/oauth/token?<br> client<span class="hljs-emphasis">_id=CLIENT_</span>ID&amp;<br> client<span class="hljs-emphasis">_secret=CLIENT_</span>SECRET&amp;<br> grant<span class="hljs-emphasis">_type=authorization_</span>code&amp;<br> code=AUTHORIZATION<span class="hljs-emphasis">_CODE&amp;</span><br><span class="hljs-emphasis"> redirect_</span>uri=CALLBACK<span class="hljs-emphasis">_URL</span><br></code></pre></td></tr></table></figure><ul><li><code>client_id client_secret</code>: 用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）</li><li><code>grant_type</code>: <code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码</li><li><code>code</code>: 上一步拿到的授权码</li><li><code>redirect_uri</code>: 与步骤1中的<code>redirect_uri</code>一致</li></ul></li><li><p>B 网站收到请求以后，就会颁发令牌。具体做法是发送一段 JSON 数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;read&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">100101</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span>...<span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>第三方登录<ul><li>以允许 github 第三方登录举例<ul><li>实际为需要授权访问用户信息</li></ul></li><li><a href="https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps">https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps</a></li><li>Github 只支持授权码方式</li></ul></li></ul><h3 id="用户使用流程"><a href="#用户使用流程" class="headerlink" title="用户使用流程"></a>用户使用流程</h3><ol><li>A 网站让用户跳转到 GitHub</li><li>GitHub 要求用户登录，然后询问”A 网站要求获得 xx 权限，你是否同意？”</li><li>用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码</li><li>A 网站使用授权码，向 GitHub 请求令牌</li><li>GitHub 返回令牌</li><li>A 网站使用令牌，向 GitHub 请求用户数据</li></ol><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li>应用登记<ol><li>一个应用要求 Oauth 授权，必须先到对方网站登记，让对方知道是谁在请求</li><li>提交登记之后，会返回客户端 ID 和客户端秘钥</li></ol></li><li>开发跳转部分:      </li><li>开发回调接口（上述的步骤3）<ol><li>拿着授权码访问 Github 索要 AccessToken:      </li><li>设置重定向地址，重定向至主页</li></ol></li><li>后续便可以通过 AccessToken 获取用户信息资源<ol><li>拿着 AccessToken 向 github 获取用户信息:</li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Oauth 在第三方登录例子中，仅用于获取用户信息，但不仅限于此</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;net/http&quot;</span><br><br>   <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>   <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>   <br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   cli := httpcli.New()<br>   engine := gin.Default()<br><br>   <span class="hljs-keyword">var</span> accessToken <span class="hljs-type">string</span><br><br>   engine.GET(<span class="hljs-string">&quot;/oauth/redirect&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      <span class="hljs-keyword">type</span> CodeS <span class="hljs-keyword">struct</span> &#123;<br>         Code <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;code&quot; binding:&quot;required&quot;`</span><br>      &#125;<br><br>      <span class="hljs-keyword">var</span> code CodeS<br>      <span class="hljs-keyword">if</span> err := ctx.ShouldBindQuery(&amp;code); err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">400</span>&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      req, err := request.Post(<span class="hljs-string">&quot;https://github.com/login/oauth/access_token&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;client_id&quot;</span>, <span class="hljs-string">&quot;---&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;client_secret&quot;</span>, <span class="hljs-string">&quot;---&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;code&quot;</span>, code.Code).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">type</span> AccessTokenResp <span class="hljs-keyword">struct</span> &#123;<br>         AccessToken <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;access_token&quot;`</span><br>         Scope       <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;scope&quot;`</span><br>         TokenType   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;token_type&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> accessTokenResp AccessTokenResp<br>      _, err = cli.DoDecodeJSON(req, &amp;accessTokenResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      accessToken = accessTokenResp.AccessToken<br><br>      req, err = request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessTokenResp.AccessToken).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>         Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;login&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>      _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      ctx.SetCookie(<span class="hljs-string">&quot;username&quot;</span>, userInfoResp.Name, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>      ctx.Redirect(http.StatusFound, <span class="hljs-string">&quot;http://localhost:8080/homepage&quot;</span>)<br>   &#125;)<br><br>   engine.GET(<span class="hljs-string">&quot;/homepage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      username, err := ctx.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> errors.Is(err, http.ErrNoCookie) &#123;<br>            ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;请先登录&lt;/p&gt;\n&lt;a href=\&quot;https://github.com/login/oauth/authorize?client_id=c263072748e5306ad088&amp;redirect_uri=http://localhost:8080/oauth/redirect\&quot;&gt;github 登录&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> company <span class="hljs-type">string</span><br>      <span class="hljs-keyword">if</span> accessToken != <span class="hljs-string">&quot;&quot;</span> &#123;<br>         req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessToken).<br>            Build()<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br><br>         <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">interface</span>&#123;&#125;<br>         <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>         _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         company = userInfoResp.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;company&quot;</span>].(<span class="hljs-type">string</span>)<br>      &#125;<br>      ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello %s!&lt;/p&gt;\n&lt;p&gt;Company: %s&lt;/p&gt;    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>, username, company)))<br>   &#125;)<br><br>   engine.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结合现有库"><a href="#结合现有库" class="headerlink" title="结合现有库"></a>结合现有库</h3><blockquote><p>可以帮你简化一部分工作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;context&quot;</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;net/http&quot;</span><br><br>   <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>   <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>   <span class="hljs-string">&quot;golang.org/x/oauth2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   oauthConfig := oauth2.Config&#123;<br>      ClientID:     <span class="hljs-string">&quot;---&quot;</span>,<br>      ClientSecret: <span class="hljs-string">&quot;---&quot;</span>,<br>      Endpoint: oauth2.Endpoint&#123;<br>         AuthURL:  <span class="hljs-string">&quot;https://github.com/login/oauth/authorize&quot;</span>,<br>         TokenURL: <span class="hljs-string">&quot;https://github.com/login/oauth/access_token&quot;</span>,<br>      &#125;,<br>      RedirectURL: <span class="hljs-string">&quot;http://localhost:8080/oauth/redirect&quot;</span>,<br>      Scopes:      <span class="hljs-literal">nil</span>,<br>   &#125;<br><br>   state := <span class="hljs-string">&quot;a-random-string&quot;</span><br><br>   cli := httpcli.New()<br>   engine := gin.Default()<br>   engine.GET(<span class="hljs-string">&quot;/github_login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      url := oauthConfig.AuthCodeURL(state)<br>      ctx.Redirect(http.StatusTemporaryRedirect, url)<br>   &#125;)<br><br>   <span class="hljs-keyword">var</span> accessToken <span class="hljs-type">string</span><br><br>   engine.GET(<span class="hljs-string">&quot;/oauth/redirect&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      <span class="hljs-keyword">type</span> CodeS <span class="hljs-keyword">struct</span> &#123;<br>         State <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;state&quot; binding:&quot;required&quot;`</span><br>         Code  <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;code&quot; binding:&quot;required&quot;`</span><br>      &#125;<br><br>      <span class="hljs-keyword">var</span> code CodeS<br>      <span class="hljs-keyword">if</span> err := ctx.ShouldBindQuery(&amp;code); err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">400</span>&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br><br>      token, err := oauthConfig.Exchange(context.Background(), code.Code)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br><br>      req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+token.AccessToken).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      accessToken = token.AccessToken<br>      <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>         Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;login&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>      _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      ctx.SetCookie(<span class="hljs-string">&quot;username&quot;</span>, userInfoResp.Name, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>      ctx.Redirect(http.StatusFound, <span class="hljs-string">&quot;http://localhost:8080/homepage&quot;</span>)<br>   &#125;)<br><br>   engine.GET(<span class="hljs-string">&quot;/homepage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      username, err := ctx.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> errors.Is(err, http.ErrNoCookie) &#123;<br>            ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;请先登录&lt;/p&gt;\n&lt;a href=\&quot;http://localhost:8080/github_login\&quot;&gt;github 登录&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> company <span class="hljs-type">string</span><br>      <span class="hljs-keyword">if</span> accessToken != <span class="hljs-string">&quot;&quot;</span> &#123;<br>         req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessToken).<br>            Build()<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br><br>         <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">interface</span>&#123;&#125;<br>         <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>         _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         company = userInfoResp.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;company&quot;</span>].(<span class="hljs-type">string</span>)<br>      &#125;<br>      ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello %s!&lt;/p&gt;\n&lt;p&gt;Company: %s&lt;/p&gt;    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>, username, company)))<br>   &#125;)<br><br>   engine.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Oauth2-0-和-单点登录的关系"><a href="#Oauth2-0-和-单点登录的关系" class="headerlink" title="Oauth2.0 和 单点登录的关系"></a>Oauth2.0 和 单点登录的关系</h2><ul><li>Oauth2.0 主要用于授权资源<ul><li>授权原则上不一定必须用户点击来授权</li></ul></li><li>单点登录可以利用 Oauth2.0 来实现，利用 Oauth2.0 授权用户信息资源至目标应用来实现登录，并可以获取用户信息</li><li>Oauth2.0 本身是需要用户授权，才能第三方登录（授权用户信息），但如果当前应用本身足够信任目标应用，认为在当前应用中的用户都可以直接授权用户信息到目标应用，则可以实现无缝单点登录</li></ul><h2 id="令牌和密码的区别"><a href="#令牌和密码的区别" class="headerlink" title="令牌和密码的区别"></a>令牌和密码的区别</h2><ul><li>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异<ul><li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li><li>令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</li><li>令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li></ul></li><li>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</li><li>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</li></ul>]]></content>
    
    
    <categories>
      
      <category>醍醐灌顶</category>
      
      <category>技术篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术篇</tag>
      
      <tag>Cookie</tag>
      
      <tag>Session</tag>
      
      <tag>Oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务架构</title>
    <link href="/2024/07/12/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/07/12/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><h2 id="微服务架构整体感受"><a href="#微服务架构整体感受" class="headerlink" title="微服务架构整体感受"></a>微服务架构整体感受</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol><li>什么是微服务架构？</li><li>服务应该如何拆分？</li><li>微服务架构带来了哪些问题？以及如何去解决这些问题。</li></ol><h3 id="典型架构图"><a href="#典型架构图" class="headerlink" title="典型架构图"></a>典型架构图</h3><p><img src="https://i.imgur.com/JXw7vLg.png" alt="image-20240710222819833"></p><p>微服务架构知识内容：</p><ol><li>应用由多个服务构成。</li><li>服务独享自身数据。</li><li>服务会共享配置，使用配置中心来支持。</li><li>服务还会共享中间件，主要缓存、消息队列、搜索、日志等。</li><li>服务间需要通信，第一步需要找到目标服务。需要服务注册中心，提供服务注册和发现。</li><li>服务需要通信，规范通信协议，典型的协议：gRPC，RestFul API，HTTP、MQ。</li><li>应用要响应外部的请求，并将请求转发给目标服务。需要 API 网关技术。</li><li>服务请求需要被控制的管理，使用负载均衡、限流、熔断、降级等控制。</li><li>服务间数据一致性的问题，通常需要分布式事务、分布式锁、分布式 Session。</li><li>服务需要被监控、需要链路追踪、监控平台、日志分析。</li></ol><h3 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h3><ol><li>Go 核心语法，我们需要用 go 编写测试用例。</li><li>Linux 基础操作，需要的程序软件大都安装在 linux 上。</li><li>Web 相关编程技术，需要使用 http 请求响应相关操作。</li></ol><h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><h3 id="巨石架构"><a href="#巨石架构" class="headerlink" title="巨石架构"></a>巨石架构</h3><p>早期，大部分的应用程序是将全部的功能模块作为一个整体进行打包、发布、运行。这样程序会越来越大，像一块大石头一样，因此称为巨石架构（the monolithic architecture）。例如，一个商城系统可能包含：分类、商品、购物车、订单、支付、物流、评价、售后、会员、推广、商户等功能模块。那么程序的架构就是：</p><p><img src="https://i.imgur.com/6GYGacV.png" alt="image-20240710223242786"></p><p>巨石应用的劣势：</p><ul><li>更新局部，需要重新部署整体</li><li>整体发布时间过长，包括编译、发布等</li><li>回归测试周期过长</li><li>不利于新技术应用，否则需要重构整体应用</li></ul><p>巨石应用也有自己的优势，例如部署容易，整体打包，整体部署即可；IDE 友好，测试容易、监控方便。</p><h3 id="微服务架构-1"><a href="#微服务架构-1" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构（MicroServices Architecture Pattern）的目的是将大型的、复杂的、长期运行的应用程序（巨石应用）构建为一组相互配合的服务，每个服务都可以很容易得局部改良。<strong>Micro</strong> 意味着服务应该足够小，服务的大小应该从业务逻辑上衡量，而不是用代码量。符合 SRP （单一职责原则）的才叫微服务。</p><p>微服务是去中心化的分布式软件架构。微服务通常是无状态服务。</p><p>微服务架构的优势：</p><ul><li>服务可以使用不同技术栈研发</li><li>每个微服务都可以独立优化，部署或扩展</li><li>更好的故障处理和错误检测</li><li>服务复用性强</li><li>服务扩展性强</li></ul><p>单体应用拆解成大量的微服务，带来的新问题是服务间通信和一致性等问题，通常需要通过服务注册发现、服务网格、分布式锁、分布式事务来解决。</p><p>上面的应用，拆分之后：</p><p><img src="https://i.imgur.com/84ZJjjR.png" alt="image-20240710223419599"></p><h3 id="SOA-与服务"><a href="#SOA-与服务" class="headerlink" title="SOA 与服务"></a>SOA 与服务</h3><p>SOA（Service-Oriented Architecture，面向服务的架构）是一种在计算机环境中设计、开发、部署和管理离散模型的方法。在 SOA 模型中，所有的功能都被定义成了独立的服务，所有的服务通过企业服务总线(ESB, Enterprise Service Bus)或流程管理器来连接。</p><p>带有 ESB 的架构典型如下：</p><p><img src="https://i.imgur.com/8K6F5ei.png" alt="image-20240710223558517"></p><p>微服务架构与 SOA 架构最重要的区别是：</p><ul><li>微服务架构是去中心化的分布式架构</li><li>SOA 是中心化的分布式架构。</li></ul><h3 id="云原生中的微服务"><a href="#云原生中的微服务" class="headerlink" title="云原生中的微服务"></a>云原生中的微服务</h3><p>微服务是云原生技术的核心部分，在微服务架构上运行的现代云原生应用程序依赖于以下关键组件：</p><ul><li>容器化，通过将服务分成多个进程来进行有效的管理和部署，例如 Docker 类平台。</li><li>编排，用于配置、分配和管理服务的可用系统资源，例如 Kubernetes 类平台。</li><li>服务网格，通过服务代理网格进行服务间通信，连接，管理和保护微服务，例如 Istio 类平台。</li></ul><p>以上三个是微服务架构在云原生中最重要的组件，这些组件允许云原生中的应用程序在负载下扩展，甚至在故障期间也能执行。</p><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><p>微服务是化整为零、分而治之的思想。</p><p>拆分原则一览：</p><p><strong>业务拆分：</strong></p><p>业务逻辑拆分，单一职责，服务自身可治理数据库。</p><p>独立功能用例拆分，独立的二方或三方用例，通常拆分为独立服务。例如二方的账号服务和三方的支付服务。</p><p><strong>技术拆分：</strong></p><p>服务的并发性，考虑持续并发、瞬时并发，拆分服务独立。</p><p>服务处理的数据，考虑数据量、读写操作的数据、冷热数据量、边长定长数据类型，将服务拆分。</p><p>服务的安全等级，考虑服务业务、数据的安全等级、采用不同的安全策略，来进行拆分。</p><p>服务需要的资源，考虑服务需要计算、I&#x2F;O、网络、存储等资源、来进行拆分。</p><p>服务扩展性，考虑服务中技术、业务等的更新率、扩展率，进行拆分。</p><p>架构的稳定性，考虑单体服务的技术架构稳定性。</p><p>便于测试，测试可集成、可回溯。</p><p>便于监控，便于日志分析、指标监控等。</p><p><strong>项目拆分：</strong></p><p>团队（开发、测试、运维）小而美。小指的是规模，团队通常 10 人左右；美指的是团队可自治，与其他团队人员协调尽量少。</p><p>成本因素，考虑技术（学习）成本、人力成本、时间成本、设施成本，来拆分服务。</p><h3 id="AKF-扩展立方体"><a href="#AKF-扩展立方体" class="headerlink" title="AKF 扩展立方体"></a>AKF 扩展立方体</h3><p>立方体图：</p><p><img src="https://i.imgur.com/VWvqOOl.png" alt="image-20240711113639989"></p><h4 id="X-轴，克隆扩展（水平复制）"><a href="#X-轴，克隆扩展（水平复制）" class="headerlink" title="X 轴，克隆扩展（水平复制）"></a>X 轴，克隆扩展（水平复制）</h4><p>X轴，代表无差别服务和数据的克隆，也称水平扩展。它指的是，相同的服务部署多个，通过负载均衡器在多个应用间做选择。</p><p>图例：</p><p><img src="https://i.imgur.com/98Xf4y3.png" alt="image-20240711113729258"></p><h4 id="Y-轴，功能拆分扩展"><a href="#Y-轴，功能拆分扩展" class="headerlink" title="Y 轴，功能拆分扩展"></a>Y 轴，功能拆分扩展</h4><p>Y轴，代表依据资源、服务或功能进行拆分。指的是把任何特定功能的操作以及操作所需的数据资源从整体（或其他操作）中分离出来。X 轴体现的是相同功能的复制，而 Y 轴体现的是多个不同功能的组合。</p><p>如图：用户购买商品，需要浏览商品信息、购买、订单管理、支付等操作，依据功能将应用拆分为：</p><p><img src="https://i.imgur.com/lyE8H0n.png" alt="image-20240711113804383"></p><p>这种拆分，就是典型微服务架构中业务逻辑的拆分方案，每个服务负责具体的某个特定功能，整体应用由多个服务组成。</p><p>同样，若某个服务需要更多的资源，也可以采用 X 轴扩展模式，例如上图中的订单服务。</p><h4 id="Z-轴，数据拆分扩展"><a href="#Z-轴，数据拆分扩展" class="headerlink" title="Z 轴，数据拆分扩展"></a>Z 轴，数据拆分扩展</h4><p>当业务基于 X、Y 做了克隆或拆分后，数据存储的压力需要通过 Z 轴扩展解决。Z 轴扩展通常指的是数据库拆分。数据库拆分如依据地域划分、依据不同功能的表划分或将表中的记录依据主键hash（或其他分区算法）划分等。</p><p>地域：</p><p><img src="https://i.imgur.com/njoLZmv.png" alt="image-20240711113907153"></p><p>基于功能：</p><p><img src="https://i.imgur.com/7XsuXnX.png" alt="image-20240711113957121"></p><p>记录划分：</p><p><img src="https://i.imgur.com/j1C2q2p.png" alt="image-20240711114009105"></p><h4 id="原点"><a href="#原点" class="headerlink" title="原点"></a>原点</h4><p>坐标原点 (0, 0, 0) 表示应用系统的最小扩展性。</p><h3 id="SRP-单一职责原则"><a href="#SRP-单一职责原则" class="headerlink" title="SRP 单一职责原则"></a>SRP 单一职责原则</h3><p>单一职责原则，应该表达最朴素的一个原则了，顾名思义，就是一个服务负责单独的一个职责，就意味着我们的设计满足单一职责。</p><p>SRP，Single Responsibility Principle，单一职责原则来自于面向对象设计的基本原则，是这么说的：</p><blockquote><p>There should never be more than one reason for a class to change.</p></blockquote><p>映射到我们微服务其实就是：对于服务而言，应该只有一个理由引起它的变化。</p><p>也就是，一个服务的功能要单一，只做与之相关的事情，在服务的设计过程中要按照职责进行设计。如果需要更多功能呢，那么就需要更多的服务，服务彼此互不干涉。</p><p>单一职责原则在使用时，要注意粒度，也就是我们应该将单体服务的规模设计多大。如果粒度过细，会导致在开发、测试、部署上都会带来额外的负担。同样若粒度过粗，那么特定功能的更新，直接会导致整体服务更新。因此，我们在拆分服务时，除了要考虑功能性，还要考虑和预测需求的变化点、变化率，以及数据增长点、并发热点等，相互结合，设计出相对平衡的独立服务。</p><p>例如，对于商品服务，商品的品牌、标签、属性、库存等，是否需要独立设计为一个服务呢？这个需要基于我们自身的业务逻辑进行设计。这个例子中，库存通常需要独立服务设计的，因为库存在订单生成和仓库管理时，会被高频率使用。而其他功能，通常隶属于商品服务的范畴。</p><p>SRP 原则通常也会被表述为服务设计的高内聚低耦合。内聚度是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好只做一件事，高内聚就是一个类封装的很完善，每个类只完成一项任务，也就是常说的单一责任原则。   耦合度是对模块间关联程度的度量，模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系，模块间联系越多，耦合性越强，模块的独立性越差。</p><h3 id="DDD-领域设计"><a href="#DDD-领域设计" class="headerlink" title="DDD 领域设计"></a>DDD 领域设计</h3><h2 id="微服务架构需要解决的问题"><a href="#微服务架构需要解决的问题" class="headerlink" title="微服务架构需要解决的问题"></a>微服务架构需要解决的问题</h2><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><h3 id="服务间发现"><a href="#服务间发现" class="headerlink" title="服务间发现"></a>服务间发现</h3><h3 id="服务间通讯"><a href="#服务间通讯" class="headerlink" title="服务间通讯"></a>服务间通讯</h3><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="熔断和降级"><a href="#熔断和降级" class="headerlink" title="熔断和降级"></a>熔断和降级</h3>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fish Shell</title>
    <link href="/2024/05/11/GNULinux%20%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%20Fish%20shell%20%E5%B9%B6%E7%BE%8E%E5%8C%96/"/>
    <url>/2024/05/11/GNULinux%20%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%20Fish%20shell%20%E5%B9%B6%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="GNU-Linux-终端下使用-Fish-shell-并美化"><a href="#GNU-Linux-终端下使用-Fish-shell-并美化" class="headerlink" title="GNU&#x2F;Linux 终端下使用 Fish shell 并美化"></a><strong>GNU&#x2F;Linux 终端下使用 Fish shell 并美化</strong></h1><h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h1><p>相信大多数开发者在使用 GNU&#x2F;Linux 的同时也免不了使用终端这个“黑框框”😃。对于绝大多数终端而言，默认的 shell 皆为<code>bash</code>。原生的 bash 看起来并不“现代化”，哦~这不免比较糟糕！<br>于是，在此基础上。开发者们通过选择其他 shell 代替 bash 以获得更佳的体验。比如：<code>zsh shell</code>，虽然原生的 zsh shell 有许多功能并不具备，但是在众多开发者的应用美化下，zsh shell 看起来很“现代化”。But 😃，虽然 zsh shell 深受开发者的喜爱，但是 zsh 整体加载性能并不是很快，同时需要依靠<code>oh-my-zsh</code>的配置才能使得 zsh 更为优雅，配置相对麻烦。<br>这就引出我们今天的主角“Fish shell”，相较于 zsh shell，<code>Fish shell</code>具有一下特点：</p><ul><li>开箱即用，内置自动提示、语法高亮、自动补全、搜索历史等功能，无需添加额外插件。</li><li>可视化的 Web 配置功能。</li><li>可以使用人机界面数据完成制表页。</li><li>具有<code>Oh-My-Fish</code> shell 框架，若 Fish shell 并不能满足您的需要，可以使用该框架进行更深入配置。</li><li>相较于<code>zsh shell</code>个更加高效的<code>prompt</code>（命令提示符）加载速度。</li></ul><p>这里，列出 <a href="https://www.slant.co/topics/16984/~linux-shells">Slant</a> 网站“What are the best Linux shells?”6 佳 shell 排名：</p><p><img src="https://i.imgur.com/1xvA0ph.png" alt="img"></p><p>了解完背景，就让我开始 Fish shell 之旅吧！</p><h1 id="二-Fish-简介及安装"><a href="#二-Fish-简介及安装" class="headerlink" title="二. Fish 简介及安装"></a>二. Fish 简介及安装</h1><p>Fish 是什么呢？</p><p>笔者先简单介绍一些什么是<code>shell</code>，为读者提供清晰地认识。</p><h2 id="（一）shell简介"><a href="#（一）shell简介" class="headerlink" title="（一）shell简介"></a>（一）shell简介</h2><p>Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。<br>实际上 Shell 是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell 有自己的编程语言用于对命令的编辑，它允许用户编写由 shell 命令组成的程序。Shell 编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的 Shell 程序与其他应用程序具有同样的效果[^1]。</p><p>常见的 shell 包括：Bash 、Korn Shell 、C Shell、Z Shell 等。</p><p>简单来说，关系图谱如下：</p><pre><code class=" mermaid">graph TD;A[用户层] --&gt; B&#123;应用层&#125;;B&#123;应用层&#125; --&gt; C[shell层];C --&gt; E[end]</code></pre><p>介绍完 shell 是什么，我们便开始进入今天的正题：“Fish shell”。</p><h2 id="（二）Fish简介"><a href="#（二）Fish简介" class="headerlink" title="（二）Fish简介"></a>（二）Fish简介</h2><p>什么是 Fish 呢？鱼 @_@ ? 。其实 Fish 的全名叫做“”friendly interactive shell”, 即友好的交互式 Shell。如其名，对比 Bash 和 Z shell(zsh) 来说，Fish 具有更加优雅的定制化策略、开箱即用的便捷。相信您一定会对 Fish 爱不释手！</p><h2 id="（三）Fish-安装"><a href="#（三）Fish-安装" class="headerlink" title="（三）Fish 安装"></a>（三）Fish 安装</h2><h4 id="1-下载及安装"><a href="#1-下载及安装" class="headerlink" title="1.下载及安装"></a>1.下载及安装</h4><p>在 Fish 官网上有详细的教程供各位读者安装在不同的 <a href="https://fishshell.com/">GNU&#x2F;Linux</a> 发行版上（当然，Fish 远不止此，还可以安装在 <a href="https://fishshell.com/">Windows</a>、<a href="https://fishshell.com/">macOS</a>、<a href="https://fishshell.com/">BSD</a> 上），由于笔者的工作环境在linux mint（基于Debian的操作系统）上，笔者仅对笔者使用的 GNU&#x2F;Linux 发行版环境做详细介绍，望海涵。</p><ul><li><p>首先我们，需要下载Fish官网提供的deb包</p><blockquote><p>我们得到的包名为“fish_3.6.1-1_amd64.deb”。</p></blockquote></li><li><p>如果读者使用的操作系统具备图形化界面，当然可以直接使用包管理器进行安装。假如仅有命令行界面，这可以使用命令：“sudo dpkg -i fish_3.6.1-1_amd64.deb”进行安装</p></li></ul><h4 id="2-应用Fish"><a href="#2-应用Fish" class="headerlink" title="2.应用Fish"></a>2.应用Fish</h4><p>由于大部分的终端默认 shell 使用的是 Bash，所以我们还需要修改当前使用的 shell 为 Fish。</p><p>笔者使用的终端模拟器为Alacritty，可以直接设置终端模拟器默认shell</p><h1 id="三-Fish的特别之处"><a href="#三-Fish的特别之处" class="headerlink" title="三. Fish的特别之处"></a>三. Fish的特别之处</h1><p>Fish 有什么特别之处？</p><p>简单易用<br>相对于需要进行大量的配置才能获得良好体验的 ZSH，Fish 原生附带有最为广泛使用的特性，比如：自动提示、语法高亮等等。同时其配置设置的语法清晰明了，通过模块化和 Web 可视化配置，能为您节省大量时间</p><ul><li><p>自动提示。</p><ul><li><p>Fish 会通过显示灰色提示，提醒您最近浏览历史，和您可能希望浏览的内容。如果命令有误，则会将命令设置为红色提醒您。</p></li><li><p>除了显示命令是否正确外，Fish 还可以显示你所搜索的目录是否存在、拼写是否正确、括号是否匹配等等。</p></li><li><p>哦~，除此之外，如果你觉得 Fish 的色彩显示并不美观，还可以自行配置美化。在 <a href="https://fishshell.com/">Fish</a> 官网有详细的教程。</p><p><img src="https://i.imgur.com/Lq6RZ7X.png" alt="图一"></p></li></ul></li><li><p>文件和命令高亮</p><ul><li>Fish 会将文件设置为绿色，目录设置为蓝色。（当然，颜色设置您也可以自行配置）、</li><li>当然，除了高亮当前目录下的文件与目录，还可以将命令高亮显示。比如输入“sudo apt”命令就会将“apt”进行高亮显示。</li></ul><p><img src="https://i.imgur.com/9HMRkGp.png" alt="img"></p></li><li><p>生成数据制表页</p><ul><li>Fish 可以解析各种格式的工具手册页，假如你不知道该命令下有什么作用，可以通过输入“Tab”键获得提示</li></ul><p><img src="https://i.imgur.com/HwDB5LI.png" alt="img"></p></li><li><p>自动补全</p><ul><li>输入命令时，Fish 会自动显示上一次使用该命令历史记录（如果还希望查看之前的历史，还可以通过按”up”向上键查看）。</li><li>假如，并没有该命令历史记录，则会显示可能使用的命令。</li><li>使用<code>Tab</code>键进行补全，假如有多种结果，则会都列出来并显示给出理由。当然，除了补全命令外，还可以补全参数以及 Git 分支，是不是很优雅 b（￣▽￣）d</li></ul></li><li><p>可视化 Web 配置页面</p><ul><li>笔者认为这绝对是 Fish 如此受欢迎的原因之一，可视化的操作为配置 Fish 提供很大的帮助。</li></ul><p><img src="https://i.imgur.com/BP2h8vN.png" alt="img"></p><blockquote><p>解释</p><blockquote><p>进入可视化界面，仅需要在Final Shell 下输入”fish_config” 命令即可</p><p>在可视化web页面下，你可以设置主题颜色（包括自定义）、提示符样式、函数、变量、查看历史命令、快捷键、设置缩写等。</p></blockquote></blockquote></li><li><p>简单配置</p><ul><li>Fish 通过函数封装命令或者起别名。同时 Fish 使用的语法也很简单，比如常见的：“if”、“switch”、“for”、“while”等</li></ul></li></ul><p>相信你一定会爱上 Fish 的！</p><h1 id="四-Fish的美化与配置"><a href="#四-Fish的美化与配置" class="headerlink" title="四.Fish的美化与配置"></a>四.Fish的美化与配置</h1><blockquote><p> 注意：<br>由于 Fish 对于笔者来说已经足够优秀了，所以笔者仅仅对 Fish 进行简单的微调和美化，如果还希望更加深入了解 Fish，可以直接在输入<code>help</code>命令，查看 Fish 的<a href="https://fishshell.com/docs/current/index.html">帮助文档</a>。请见谅。</p></blockquote><p>终于来到本文的第二个关键点了！体验完 Fish 是不是觉得很 nice？<br>假如，您觉得 Fish 还差一点味道。那么欢迎来到 Fish 的配置与美化。 😉</p><p>本节共分为三节，分别介绍：对 Fish 进行配置、oh-my-fish 使用、oh-my-posh 使用。<br>那么，开始吧！</p><h2 id="（一）对Fish进行配置"><a href="#（一）对Fish进行配置" class="headerlink" title="（一）对Fish进行配置"></a>（一）对Fish进行配置</h2><p>Fish 的配置文件位于<code>~/.config/fish/config.fish</code>。</p><p>由于，Fish 使用函数对命令进行封装。我们也可以直接在可视化 Web 页面通过编写函数实现我们想要的效果。</p><p><img src="https://i.imgur.com/HwVHHlr.png" alt="img"></p><p>在这里，我仅做一个演示，望理解。</p><h2 id="（二）使用Oh-My-Fish"><a href="#（二）使用Oh-My-Fish" class="headerlink" title="（二）使用Oh-My-Fish"></a>（二）使用Oh-My-Fish</h2><p>相信大家都听说过“Oh-My-Zsh”，对“Oh-My-Fish”可能有些陌生，其实“Oh-My-Fish”和“Oh-My-Zsh”一样都是基于对应 shell 所设计的框架，通过该框架您可以自行安装所需扩展、Shell 外观等。</p><h4 id="1-安装-Oh-My-Fish"><a href="#1-安装-Oh-My-Fish" class="headerlink" title="1.安装 Oh-My-Fish"></a>1.安装 Oh-My-Fish</h4><p>使用以下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L https://get.oh-my.fish | fish<br></code></pre></td></tr></table></figure><h4 id="2-使用Oh-MyFish进行美化"><a href="#2-使用Oh-MyFish进行美化" class="headerlink" title="2.使用Oh-MyFish进行美化"></a>2.使用Oh-MyFish进行美化</h4><p>通过使用“omf list”命令，可以查看 Fish 中已经安装的插件和主题。比如：我并未安装任何主题，则会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>$ omf list<br>Plugins<br>fish-spec       omf<br><br>Themes<br>default<br></code></pre></td></tr></table></figure><p>如果想要更改背景，则可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">omf theme<br></code></pre></td></tr></table></figure><p>查看 Oh-My-Fish 全部背景和已经安装背景。如果希望查看背景具体效果，则可以 <a href="https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md">点击这里</a></p><p>有关主题的一些命令，可以查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">omf install 主题名  <span class="hljs-comment">#安装主题</span><br><br>omf theme 主题名  <span class="hljs-comment">#更换主题</span><br><br>omf search 主题名  <span class="hljs-comment">#搜索主题</span><br><br>omf search -t 主题名  <span class="hljs-comment">#限制搜索主题，比如 omf search -t cha 便仅会搜索含有 cha 名的主题</span><br></code></pre></td></tr></table></figure><p>同样，插件的使用命令也类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">omf install  插件名  <span class="hljs-comment">#安装主题</span><br><br>omf theme 插件名  <span class="hljs-comment">#更换主题</span><br><br>omf search 插件名  <span class="hljs-comment">#搜索主题</span><br><br>omf search -p 插件名  <span class="hljs-comment">#限制搜索插件</span><br></code></pre></td></tr></table></figure><p>如果还想了解更多信息，可以查看 Oh-My-Fish 官方 <a href="https://github.com/oh-my-fish/oh-my-fish/tree/master/docs/zh-CN">README</a> 文件，也可以阅读 Linux 中国推出的 <a href="https://linux.cn/article-9515-1.html">Oh My Fish! 让你的 Shell 漂亮起来</a>。</p><h4 id="3-使用oh-my-posh美化"><a href="#3-使用oh-my-posh美化" class="headerlink" title="3.使用oh-my-posh美化"></a>3.使用oh-my-posh美化</h4><blockquote><p>注意：<br><strong>使用 oh-my-posh 需要 Fish 版本高于或等于 V3.4.0</strong><br>可以使用命令“fish –version”查看当前 Fish 版本</p></blockquote><p>oh-my-posh 是什么？用官方原话来说是：“A prompt theme engine for any shell.”，适用于任何 shell 的提示主题引擎。</p><p>如其名，oh-my-posh 对主流的 shell 都进行了配置。笔者喜欢使用 oh-my-posh 的原因便因其美丽的主题和对 Git 的良好支持。</p><p>比如，笔者现在所使用的一款主题<code>clean-detailed</code>：</p><p><img src="https://i.imgur.com/TPoRx19.png" alt="img"></p><p>除了常规的显示当前目录外，还显示 CPU 使用率、内存所占容量、命令执行时间以及最为重要的 Git 信息显示。</p><p>是不是觉得挺不错的。づ￣ 3￣) づ</p><p>就让我们开始 oh-my-posh 美化之路吧！</p><blockquote><p>注意：<br>在本次配置过程中，会进行详略讲解。如果读者并未明白某个配置过程，可以查阅「<a href="https://ohmyposh.dev/docs/installation/linux">官方文档</a>」</p></blockquote><h5 id="（1）下载oh-my-posh"><a href="#（1）下载oh-my-posh" class="headerlink" title="（1）下载oh-my-posh"></a>（1）下载oh-my-posh</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 注意：此 CPU 架构为 amd64</span><br>sudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O /usr/local/bin/oh-my-posh<br><span class="hljs-comment"># 注意：此 CPU 架构为 arm64</span><br>sudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-arm64 -O /usr/local/bin/oh-my-posh<br><span class="hljs-comment"># 注意：此 CPU 架构为 arm</span><br>sudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-arm -O /usr/local/bin/oh-my-posh<br></code></pre></td></tr></table></figure><p>并设置其权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/oh-my-posh<br></code></pre></td></tr></table></figure><blockquote><p>解释：<br>如果读者不知晓自己电脑的处理器体系结构，可以在命令行输入命令“uname -m”查看。<br>比如：笔者输出结果为“X86_64”，那么我就应该选择“amd64”。</p></blockquote><p>以上是笔者自己的做法，但其实官方提供了一个脚本，但是由于其脚本下载github源文件速度太慢所以被舍弃。</p><p>以下是官方的做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>curl -s https://ohmyposh.dev/install.sh | bash -s<br><span class="hljs-comment"># 上述是官方原本的写法，如果你不是root用户，请使用下述方式：</span><br><span class="hljs-comment"># curl -s https://ohmyposh.dev/install.sh | sudo bash -s</span><br></code></pre></td></tr></table></figure><p>默认的安装路径为：<code>/usr/local/bin/oh-my-posh</code>，可以自己设置路径，比如我希望在<code>～/bin</code>下，那么则应该写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://ohmyposh.dev/install.sh | sudo bash -s -- -d ~/bin<br></code></pre></td></tr></table></figure><p>注意，如果你安装的路径为自定义，则需要在<code>~/.config/fish/config.fish</code>下，也就是在fish的配置文件下设置oh-my-posh的PATH。</p><h5 id="（2）下载主题"><a href="#（2）下载主题" class="headerlink" title="（2）下载主题"></a>（2）下载主题</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建主题存放文件夹，读者可以根据需要自定义存放位置，</span><br><span class="hljs-comment"># 如果自定义修改位置，那么后续的命令也需要做出相应更改</span><br><span class="hljs-built_in">mkdir</span> ~/.poshthemes<br><span class="hljs-comment"># 获取主题zip文件并存放至对应主题文件夹（如果使用该命令下载zip较慢，</span><br><span class="hljs-comment"># 可以通过复制该URL使用“github文件加速下载下载”文件</span><br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zip<br><span class="hljs-comment"># 解压主题压缩包文件</span><br>unzip ~/.poshthemes/themes.zip -d ~/.poshthemes<br><span class="hljs-comment"># 将所有主题文件设置可读权限</span><br><span class="hljs-built_in">chmod</span> u+rw ~/.poshthemes/*.omp.*<br><span class="hljs-comment"># 删除主题压缩包</span><br><span class="hljs-built_in">rm</span> ~/.poshthemes/themes.zip<br></code></pre></td></tr></table></figure><h5 id="（3-安装字体"><a href="#（3-安装字体" class="headerlink" title="（3) 安装字体"></a>（3) 安装字体</h5><p>因为 oh-my-posh 的主题需要显示字体图标，所以需要使用 <a href="https://www.nerdfonts.com/font-downloads">Nerd Fonts</a>“家族”的字体。在 oh-my-posh 官方文档推荐使用 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip">Meslo LGM NF</a> 字体，但是根据笔者的经验，使用其他“Nerd Fonts”也是没有问题的。比如笔者使用的字体便是“JetBrainsMono Nerd Font”，随读者自己的爱好。</p><p>除了手动下载安装字体外，oh-my-posh 也提供在线安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo oh-my-posh font install<br></code></pre></td></tr></table></figure><p>通过移动上下键选择自己想要安装的字体即可。</p><h5 id="（4）安装主题"><a href="#（4）安装主题" class="headerlink" title="（4）安装主题"></a>（4）安装主题</h5><p>oh-my-posh 安装 Fish 也比较简单，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 注意“~/.poshthemes/jandedobbeleer.omp.json”，根据实际安装情况选择读者自己设置的 oh-my-posh 主题位置而定，在此仅作为参考。</span><br>oh-my-posh init fish --config ~/.poshthemes/jandedobbeleer.omp.json | <span class="hljs-built_in">source</span><br></code></pre></td></tr></table></figure><blockquote><p>注意</p><p>主题可以在<a href="https://ohmyposh.dev/docs/themes">官网</a>查看，当读者看到适合自己的主题时，可以暂时通过命令“oh-my-posh init fish –config ~&#x2F;.poshthemes&#x2F;看到的主题名.omp.json | source”查看使用效果，如果合适则直接将该命令添加到fish的配置文件中即可。</p></blockquote><p>重载 Fish 配置文件，那么 oh-my-posh 便成功完成美化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">. ~/.config/fish/config.fish<br></code></pre></td></tr></table></figure><p>至此，便结束 Fish 的配置与美化。</p><p>如果，读者对配置教程有不明白地方，可以阅读下方的参考文档。</p><p><strong>参考</strong></p><p><a href="https://stackoverflow.com/questions/52281264/how-to-reset-fish-shell-key-bindings">遇到的错误结局办法</a></p><p><a href="https://blog.csdn.net/duninet/article/details/107115082">Fish vs. Zsh vs. Bash 以及为什么要改用 Fish</a></p><p><a href="https://blog.csdn.net/lixinze779/article/details/81012318">Zsh 和 Bash 究竟有何不同</a></p><p><a href="https://www.ruanyifeng.com/blog/2017/05/fish_shell.html">Fish shell 入门教程</a></p><p><a href="https://linux.cn/article-9515-1.html">Oh My Fish! 让你的 Shell 漂亮起来</a></p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Fish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2024/05/11/Docker/"/>
    <url>/2024/05/11/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li>官方文档地址:<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></li><li>中文参考手册:<a href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></li></ul><h2 id="1-Docker的基本概念"><a href="#1-Docker的基本概念" class="headerlink" title="1. Docker的基本概念"></a>1. Docker的基本概念</h2><h3 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h3><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h3 id="1-2-为什么是Docker"><a href="#1-2-为什么是Docker" class="headerlink" title="1.2 为什么是Docker"></a>1.2 为什么是Docker</h3><ul><li><p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p><p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p><p><strong>优势1: 一致的运行环境,更轻松的迁移</strong></p></li><li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p><p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p><p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p></li><li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p><p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p><p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p></li></ul><h3 id="1-3-Docker和虚拟机的区别"><a href="#1-3-Docker和虚拟机的区别" class="headerlink" title="1.3 Docker和虚拟机的区别"></a>1.3 Docker和虚拟机的区别</h3><blockquote><p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p></blockquote><p><img src="https://i.imgur.com/pwU9rfo.png" alt="img"></p><p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p><table><thead><tr><th align="left"></th><th align="left">传统虚拟机</th><th align="left">Docker容器</th></tr></thead><tbody><tr><td align="left">磁盘占用</td><td align="left">几个GB到几十个GB左右</td><td align="left">几十MB到几百MB左右</td></tr><tr><td align="left">CPU内存占用</td><td align="left">虚拟操作系统非常占用CPU和内存</td><td align="left">Docker引擎占用极低</td></tr><tr><td align="left">启动速度</td><td align="left">（从开机到运行项目）几分钟</td><td align="left">（从开启容器到运行项目）几秒</td></tr><tr><td align="left">安装管理</td><td align="left">需要专门的运维技术</td><td align="left">安装、管理方便</td></tr><tr><td align="left">应用部署</td><td align="left">每次部署都费时费力</td><td align="left">从第二次部署开始轻松简捷</td></tr><tr><td align="left">耦合性</td><td align="left">多个应用服务安装到一起，容易互相影响</td><td align="left">每个应用服务一个容器，达成隔离</td></tr><tr><td align="left">系统依赖</td><td align="left">无</td><td align="left">需求相同或相似的内核，目前推荐是Linux</td></tr></tbody></table><hr><h2 id="2-Docker的安装"><a href="#2-Docker的安装" class="headerlink" title="2. Docker的安装"></a>2. Docker的安装</h2><blockquote><p>以centos7为例 文档： <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p></blockquote><ul><li><p>卸载原始docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><p>安装docker依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils<br>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo <span class="hljs-comment"># 国内可能无法使用 可以使用下面的镜像源</span><br><span class="hljs-comment"># sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure></li><li><p>兼容性卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 卸载旧版本的docker</span><br>yum remove docker \<br>           docker-client \<br>           docker-client-latest \<br>           docker-common \<br>           docker-latest \<br>           docker-latest-logrotate \<br>           docker-logrotate \<br>           docker-selinux \<br>           docker-engine-selinux \<br>           docker-engine<br><span class="hljs-comment"># 卸载新版本的docker（叫docker-ce）</span><br>yum remove docker-ce \<br>           docker-ce-cli \<br>           containerd<br><br><span class="hljs-comment"># 停止删除服务</span><br>systemctl stop docker<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service.d<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service<br><span class="hljs-built_in">rm</span> -rf /var/lib/docker<br><span class="hljs-built_in">rm</span> -rf /var/run/docker<br><span class="hljs-built_in">rm</span> -rf /usr/local/docker<br><span class="hljs-built_in">rm</span> -rf /etc/docker<br><span class="hljs-built_in">rm</span> -rf /usr/bin/docker* /usr/bin/containerd* /usr/bin/runc /usr/bin/ctr<br></code></pre></td></tr></table></figure><p>删除之后再进行<strong>安装</strong>可能会遇到报错</p><p><img src="https://i.imgur.com/k9kZxJn.png" alt="image-20240528220125947"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看冲突的依赖包</span><br>yum list installed | grep docker<br><span class="hljs-comment"># 删除后安装其他指定版本</span><br>rpm -e docker-client.x86_64、rpm -e docker-common.x86_64<br></code></pre></td></tr></table></figure></li></ul><p>​<img src="https://i.imgur.com/6t0ZMvR.png" alt="image-20240528220350909"></p><h2 id="3-Docker的核心架构"><a href="#3-Docker的核心架构" class="headerlink" title="3. Docker的核心架构"></a>3. Docker的核心架构</h2><p><img src="https://i.imgur.com/qULQy2h.png" alt="img"></p><ul><li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li><li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li><li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li><li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li><li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li></ul><h2 id="4-Docker配置阿里云镜像加速"><a href="#4-Docker配置阿里云镜像加速" class="headerlink" title="4. Docker配置阿里云镜像加速"></a>4. Docker配置阿里云镜像加速</h2><ul><li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li><code>验证docker的镜像加速是否生效</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker info<br>..........<br>    127.0.0.0/8<br>   Registry Mirrors:<br>    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;<br>   Live Restore Enabled: false<br>   Product License: Community Engine<br></code></pre></td></tr></table></figure><hr><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><h3 id="5-1-辅助命令"><a href="#5-1-辅助命令" class="headerlink" title="5.1 辅助命令"></a>5.1 辅助命令</h3><pre><code class="hljs">    docker version--------------------------查看docker的信息    docker info--------------------------查看更详细的信息    docker --help--------------------------帮助命令</code></pre><h3 id="5-2-Images-镜像命令"><a href="#5-2-Images-镜像命令" class="headerlink" title="5.2 Images 镜像命令"></a>5.2 Images 镜像命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看本机中所有镜像</span><br>docker images--------------------------列出本地所有镜像<br>-a列出所有镜像（包含中间映像层）<br>  -q只显示镜像<span class="hljs-built_in">id</span><br><span class="hljs-comment"># 2.搜索镜像</span><br>docker search [options] 镜像名-------------------去dockerhub上查询当前镜像<br>-s 指定值列出收藏数不少于指定值的镜像<br>  --no-trunc  显示完整的镜像信息<br><span class="hljs-comment"># 3.从仓库下载镜像</span><br>docker pull 镜像名[:TAG|@DIGEST]----------------- 下载镜像<br><span class="hljs-comment"># 4.删除镜像</span><br>docker rmi 镜像名--------------------------  删除镜像<br>-f强制删除<br></code></pre></td></tr></table></figure><h3 id="5-3-Container命令"><a href="#5-3-Container命令" class="headerlink" title="5.3 Container命令"></a>5.3 Container命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.运行容器</span><br>docker run 镜像名--------------------------镜像名新建并启动容器<br>    --name 别名为容器起一个名字<br>    -d启动守护式容器（在后台启动容器）<br>    -p 映射端口号：原始端口号 指定端口号启动<br><br>例：docker run -it --name myTomcat -p 8888:8080 tomcat<br>    docker run -d --name myTomcat -P tomcat<br><br><span class="hljs-comment"># 2.查看运行的容器</span><br>docker ps--------------------------列出所有正在运行的容器<br>    -a正在运行的和历史运行过的容器<br>    -q静默模式，只显示容器编号<br><br><span class="hljs-comment"># 3.停止|关闭|重启容器</span><br>docker start   容器名字或者容器<span class="hljs-built_in">id</span>  --------------- 开启容器<br>docker restart 容器名或者容器<span class="hljs-built_in">id</span>    --------------- 重启容器<br>docker stop  容器名或者容器<span class="hljs-built_in">id</span>     ------------------ 正常停止容器运行<br>docker <span class="hljs-built_in">kill</span>  容器名或者容器<span class="hljs-built_in">id</span>      ------------------ 立即停止容器运行<br><br><span class="hljs-comment"># 4.删除容器</span><br>docker <span class="hljs-built_in">rm</span> -f 容器<span class="hljs-built_in">id</span>和容器名     <br>docker <span class="hljs-built_in">rm</span> -f $(docker ps -aq)--------------------------删除所有容器<br><br><span class="hljs-comment"># 5.查看容器内进程</span><br>docker top 容器<span class="hljs-built_in">id</span>或者容器名 ------------------ 查看容器内的进程<br><br><span class="hljs-comment"># 6.查看查看容器内部细节</span><br>docker inspect 容器<span class="hljs-built_in">id</span> ------------------ 查看容器内部细节<br><br><span class="hljs-comment"># 7.查看容器的运行日志</span><br>docker logs [OPTIONS] 容器<span class="hljs-built_in">id</span>或容器名------------------ 查看容器日志<br>    -t 加入时间戳<br>    -f 跟随最新的日志打印<br>    --<span class="hljs-built_in">tail</span>  数字显示最后多少条<br><br><span class="hljs-comment"># 8.进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> [options] 容器<span class="hljs-built_in">id</span> 容器内命令 ------------------ 进入容器执行命令<br>-i以交互模式运行容器，通常与-t一起使用<br>    -t分配一个伪终端    shell窗口   bash <br><br><span class="hljs-comment"># 9.容器和宿主机之间复制文件</span><br>docker <span class="hljs-built_in">cp</span> 文件|目录 容器<span class="hljs-built_in">id</span>:容器路径           -----------------   将宿主机复制到容器内部<br>docker <span class="hljs-built_in">cp</span> 容器<span class="hljs-built_in">id</span>:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上<br><br><span class="hljs-comment"># 10.数据卷(volum)实现与宿主机共享目录</span><br>docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名<br>注意: <br>    1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容<br>    2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中<br><br><span class="hljs-comment"># 11.打包镜像</span><br>docker save 镜像名 -o  名称.tar<br><br><span class="hljs-comment"># 12.载入镜像</span><br>docker load -i   名称.tar<br><br><span class="hljs-comment"># 13.容器打包成新的镜像</span><br>docker commit -m <span class="hljs-string">&quot;描述信息&quot;</span> -a <span class="hljs-string">&quot;作者信息&quot;</span>   （容器<span class="hljs-built_in">id</span>或者名称）打包的镜像名称:标签<br><br><span class="hljs-comment"># 14. 容器重新命名</span><br>docker tag [镜像<span class="hljs-built_in">id</span>] [新镜像名称]:[新镜像标签]<br></code></pre></td></tr></table></figure><h2 id="6-Docker镜像的原理"><a href="#6-Docker镜像的原理" class="headerlink" title="6. Docker镜像的原理"></a>6. Docker镜像的原理</h2><h3 id="6-1-镜像是什么"><a href="#6-1-镜像是什么" class="headerlink" title="6.1 镜像是什么"></a>6.1 镜像是什么</h3><blockquote><p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p></blockquote><h3 id="6-2-Docker的镜像原理"><a href="#6-2-Docker的镜像原理" class="headerlink" title="6.2 Docker的镜像原理"></a>6.2 Docker的镜像原理</h3><blockquote><p><strong>docker的镜像实际是由一层一层的文件系统组成。</strong></p></blockquote><ul><li>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux&#x2F;Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</li><li>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu&#x2F;CentOS等等。</li><li>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</li></ul><p><img src="https://i.imgur.com/mYIKz3o.png" alt="img"></p><p><code>UnionFS</code> (联合文件系统)： Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同的目录挂载到同一个虚拟机文件系统下，Union文件系统是Docker镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以用来制作各种具体的应用镜像。</p><p>特性： 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>怎么理解？当我们执行docker pull 的时候会拉取很多模块</p></blockquote><h2 id="7-Docker安装常用服务"><a href="#7-Docker安装常用服务" class="headerlink" title="7. Docker安装常用服务"></a>7. Docker安装常用服务</h2><h3 id="7-1-ETCD"><a href="#7-1-ETCD" class="headerlink" title="7.1 ETCD"></a>7.1 ETCD</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull bitnami/etcd:3.5.9<br></code></pre></td></tr></table></figure></li><li><p>准备挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/docker/etcd/data ~/docker/etcd/conf<br><br><span class="hljs-built_in">chmod</span> -R 777 ~/docker/etcd/data <br><span class="hljs-built_in">chmod</span> -R 777 ~/docker/etcd/conf<br></code></pre></td></tr></table></figure></li><li><p>准备配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/docker/etcd/conf/etcd.yml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#成员名称</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">etcd01</span><br><span class="hljs-comment"># 数据保存路径</span><br><span class="hljs-attr">data-dir:</span> <span class="hljs-string">/data</span><br><span class="hljs-comment">#对外提供服务的地址</span><br><span class="hljs-attr">listen-client-urls:</span> <span class="hljs-string">http://0.0.0.0:2379</span><br><span class="hljs-comment">#成员之间通信地址</span><br><span class="hljs-attr">listen-peer-urls:</span> <span class="hljs-string">http://0.0.0.0:2380</span><br><span class="hljs-comment">#此成员的客户端URL列表，用于通告群集的其余部分。这些URL可以包含域名</span><br><span class="hljs-attr">advertise-client-urls:</span> <span class="hljs-string">http://etcd01:2379</span><br></code></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name etcd -p 2379:2379 -p 2380:2380 \<br>-e ALLOW_NONE_AUTHENTICATION=<span class="hljs-built_in">yes</span> \<br>-e ETCD_CONFIG_FILE=/opt/bitnami/etcd/conf/etcd.yml \<br>-v ~/docker/etcd/data:/data \<br>-v ~/docker/etcd/conf:/opt/bitnami/etcd/conf \<br>bitnami/etcd:3.5.9<br></code></pre></td></tr></table></figure></li><li><p>进入 ETCD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -u root -it etcd /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker update --restart=always etcd<br></code></pre></td></tr></table></figure></li><li><p>其他</p><p><a href="https://xie.infoq.cn/link?target=https://github.com/etcd-io/etcd/blob/main/etcd.conf.yml.sample">详细配置文件地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 验证安装</span><br>etcd --version<br></code></pre></td></tr></table></figure><ol><li><p>增加认证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下命令都需要进入 etcd 容器 shell</span><br>etcdctl user add root --interactive <span class="hljs-comment"># 增加用户 并以命令行形式设置密码</span><br>etcdctl role add root <span class="hljs-comment"># 增加root</span><br>etcdctl user grant-role root root <span class="hljs-comment"># 给 root 设置 root权限</span><br>etcdctl auth <span class="hljs-built_in">enable</span> <span class="hljs-comment"># 开启认证</span><br><br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="7-2-MySQL"><a href="#7-2-MySQL" class="headerlink" title="7.2 MySQL"></a>7.2 MySQL</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mysql:5.7<br></code></pre></td></tr></table></figure></li><li><p>准备挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /root/docker/mysql/data /root/docker/mysql/conf.d:/etc/mysql/conf.d <br></code></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name mysql -v /root/docker/mysql/data:/var/lib/mysql -v /root/docker/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 13306:3306 -d mysql:5.7<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-Dockerfile"><a href="#8-Dockerfile" class="headerlink" title="8. Dockerfile"></a>8. Dockerfile</h2><h3 id="8-1-什么是Dockerfile"><a href="#8-1-什么是Dockerfile" class="headerlink" title="8.1 什么是Dockerfile"></a>8.1 什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p><p><img src="https://i.imgur.com/teEfIcy.png" alt="img"></p><ul><li>通过架构图可以看出Docker file 可以直接构建镜像</li></ul><h3 id="8-2-Docker-file解析过程"><a href="#8-2-Docker-file解析过程" class="headerlink" title="8.2 Docker file解析过程"></a>8.2 Docker file解析过程</h3><p><img src="https://i.imgur.com/4y60ija.png" alt="img"></p><h3 id="8-3-Dockerfile的保留命令"><a href="#8-3-Dockerfile的保留命令" class="headerlink" title="8.3 Dockerfile的保留命令"></a>8.3 Dockerfile的保留命令</h3><p>官方说明:<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><table><thead><tr><th align="left">保留字</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left"><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td></tr><tr><td align="left">MAINTAINER</td><td align="left">镜像维护者的姓名和邮箱地址</td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left"><strong>构建镜像时需要运行的指令</strong></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left"><strong>当前容器对外暴露出的端口号</strong></td></tr><tr><td align="left"><strong>WORKDIR</strong></td><td align="left"><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left"><strong>用来在构建镜像过程中设置环境变量</strong></td></tr><tr><td align="left"><strong>ADD</strong></td><td align="left"><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left"><strong>类似于ADD，拷贝文件和目录到镜像中 将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td></tr><tr><td align="left"><strong>VOLUME</strong></td><td align="left"><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr><td align="left"><strong>CMD</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h4 id="8-3-1-FROM-命令"><a href="#8-3-1-FROM-命令" class="headerlink" title="8.3.1 FROM 命令"></a>8.3.1 FROM 命令</h4><ul><li><p>基于哪个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span>  &lt;image&gt;<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[@&lt;digest&gt;]  使用摘要<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-2-MAINTAINER-命令"><a href="#8-3-2-MAINTAINER-命令" class="headerlink" title="8.3.2 MAINTAINER 命令"></a>8.3.2 MAINTAINER 命令</h4><ul><li><p>镜像维护者的姓名和邮箱地址[废弃]</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-3-RUN-命令"><a href="#8-3-3-RUN-命令" class="headerlink" title="8.3.3 RUN 命令"></a>8.3.3 RUN 命令</h4><ul><li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt; (shell form, the <span class="hljs-built_in">command</span> is run <span class="hljs-keyword">in</span> a shell, <span class="hljs-built_in">which</span> by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> hello</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo hello&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-4-EXPOSE-命令"><a href="#8-3-4-EXPOSE-命令" class="headerlink" title="8.3.4 EXPOSE 命令"></a>8.3.4 EXPOSE 命令</h4><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/udp<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-5-CMD-命令"><a href="#8-3-5-CMD-命令" class="headerlink" title="8.3.5 CMD 命令"></a>8.3.5 CMD 命令</h4><ul><li><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li><li><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form, this is the preferred form)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (as default parameters to ENTRYPOINT)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2 (shell form)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-6-WORKDIR-命令"><a href="#8-3-6-WORKDIR-命令" class="headerlink" title="8.3.6 WORKDIR 命令"></a>8.3.6 WORKDIR 命令</h4><ul><li><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br>`注意:<span class="hljs-keyword">WORKDIR</span><span class="language-bash">指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-7-ENV-命令"><a href="#8-3-7-ENV-命令" class="headerlink" title="8.3.7 ENV 命令"></a>8.3.7 ENV 命令</h4><ul><li><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-8-ADD-命令"><a href="#8-3-8-ADD-命令" class="headerlink" title="8.3.8 ADD 命令"></a>8.3.8 ADD 命令</h4><ul><li><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> url </span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-9-COPY-命令"><a href="#8-3-9-COPY-命令" class="headerlink" title="8.3.9 COPY 命令"></a>8.3.9 COPY 命令</h4><ul><li><p>用来将context目录中指定文件复制到镜像的指定目录中</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-10-VOLUME-命令"><a href="#8-3-10-VOLUME-命令" class="headerlink" title="8.3.10 VOLUME 命令"></a>8.3.10 VOLUME 命令</h4><ul><li><p>用来定义容器运行时可以挂在到宿主机的目录</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-11-ENTRYPOINT-命令"><a href="#8-3-11-ENTRYPOINT-命令" class="headerlink" title="8.3.11 ENTRYPOINT 命令"></a>8.3.11 ENTRYPOINT 命令</h4><ul><li><p>用来指定容器启动时执行命令和CMD类似</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]<br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="8-4-Dockerfile构建SpringBoot应用"><a href="#8-4-Dockerfile构建SpringBoot应用" class="headerlink" title="8.4 Dockerfile构建SpringBoot应用"></a>8.4 Dockerfile构建SpringBoot应用</h3><ol><li><p>创建Spring Boot应用</p></li><li><p>执行打包命令</p></li><li><p>创建Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-spring-boot-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-spring-boot-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-springboot-demo .<br></code></pre></td></tr></table></figure></li><li><p>运行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8081:8080 docker-springboot-demo<br></code></pre></td></tr></table></figure></li><li><p>访问项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --location <span class="hljs-string">&#x27;http://localhost:8081/index&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="9-Docker网络"><a href="#9-Docker网络" class="headerlink" title="9. Docker网络"></a>9. Docker网络</h2><p>当项目大规模使用 Docker 时，容器通信的问题也就产生了。要解决容器通信问题，必须先了解很多关于网络的知识。Docker 作为目前最火的轻量级容器技术，有很多令人称道的功能，如 Docker 的镜像管理。然而，Docker 同样有着很多不完善的地方，网络方面就是 Docker 比较薄弱的部分。因此，我们有必要深入了解 Docker 的网络知识，以满足更高的网络需求。</p><p>我们在启动docker的时候，主机会有增加一个docker0的网络</p><p><img src="https://i.imgur.com/nZMAhP9.png" alt="image-20240513221855243"></p><blockquote><p>默认网络</p></blockquote><p>安装 Docker 以后，会默认创建三种网络，可以通过 <code>docker network ls</code> 查看。</p><p><img src="https://i.imgur.com/HNAdhQ7.png" alt="image-20240513222000607"></p><ul><li><p>bridge 网络模式</p><p>在该模式中，Docker 守护进程创建了一个虚拟以太网桥 <code>docker0</code>，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包，并为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code></p><p>虚拟网桥，默认为该模式</p></li><li><p>host 网络模式</p><p>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</p></li><li><p>none 网络模式</p><p>容器具有独立的Network namespace, 但并没有对其进行任何网络设置，如分配veth part和网桥连接，IP等</p></li><li><p>container 网络模式</p><p>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等</p></li></ul><h3 id="9-1-Docker-网络常用命令"><a href="#9-1-Docker-网络常用命令" class="headerlink" title="9.1 Docker 网络常用命令"></a>9.1 Docker 网络常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network --<span class="hljs-built_in">help</span><br><br>Usage:  docker network COMMAND<br><br>Manage networks<br><br>Commands:<br>  connect     Connect a container to a network<br>  create      Create a network<br>  disconnect  Disconnect a container from a network<br>  inspect     Display detailed information on one or more networks<br>  <span class="hljs-built_in">ls</span>          List networks<br>  prune       Remove all unused networks<br>  <span class="hljs-built_in">rm</span>          Remove one or more networks<br><br>Run <span class="hljs-string">&#x27;docker network COMMAND --help&#x27;</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h3 id="9-2-Docker-网络能干嘛"><a href="#9-2-Docker-网络能干嘛" class="headerlink" title="9.2 Docker 网络能干嘛"></a>9.2 Docker 网络能干嘛</h3><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不收到任何影响</li></ul><h3 id="9-3-Docker-容器之间内部的通信"><a href="#9-3-Docker-容器之间内部的通信" class="headerlink" title="9.3 Docker 容器之间内部的通信"></a>9.3 Docker 容器之间内部的通信</h3><blockquote><p>Tips 通过自建网络实现</p></blockquote><ol><li><p>准备所需要环境</p><p>笔者使用ubuntu镜像实现，需要先拉取对应镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull ubuntu<br>docker images<br></code></pre></td></tr></table></figure><blockquote><p>如果出现docker search 可以使用，docker pull 失败的问题可以尝试看看是否是DNS的问题 &#x2F;etc</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/6BhHiZO.png" alt="image-20240514184217779"></p></li><li><p>创建网络</p><p>如果不清楚docker network命令可以使用<code>docker network --help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create test-network<br></code></pre></td></tr></table></figure><p>创建网络之后执行<code>docker network ls</code>看看是否执行成功</p></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动两个docker容器</span><br>docker run -it --name u1 --network test-network --network-alias ubuntu1  ubuntu bash<br>docker run -it --name u2 --network test-network --network-alias ubuntu2  ubuntu bash<br>   <br></code></pre></td></tr></table></figure><ul><li>–network 指定网络</li><li>–network-alias 指定网络名称（类似于主机名称，后续可以直接通过<code>ping</code>这个主机）</li></ul></li><li><p>安装容器环境</p><p>启动的容器是没有<code>ifconfig</code>,<code>ping</code>这些命令的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update &amp;&amp; apt install -y net-tools &amp;&amp; apt install -y iputils-ping<br><br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>分别启动两个容器，并进入<code>shell</code>，进入容器命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it [container_id] bash<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://i.imgur.com/C9PS4pG.jpeg" alt="image-20240514184129680"></p></li></ol><h2 id="9-Docker-Compose"><a href="#9-Docker-Compose" class="headerlink" title="9. Docker Compose"></a>9. Docker Compose</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p><h3 id="9-2-docker-compose-安装"><a href="#9-2-docker-compose-安装" class="headerlink" title="9.2 docker-compose 安装"></a>9.2 docker-compose 安装</h3><blockquote><p>官网： <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>下载地址：<a href="https://docs.docker.com/compose/install">https://docs.docker.com/compose/install</a></p></blockquote><h3 id="9-3-docker-compose"><a href="#9-3-docker-compose" class="headerlink" title="9.3 docker compose"></a>9.3 docker compose</h3><ol><li><p>To download and install Compose standalone, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Apply executable permissions to the standalone binary in the target path for the installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Test and execute compose commands using <code>docker-compose</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose --version<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/CxmN9fd.png" alt="image-20240514212055991"></p></li></ol><h3 id="9-4-docker-compose常用命令"><a href="#9-4-docker-compose常用命令" class="headerlink" title="9.4 docker-compose常用命令"></a>9.4 docker-compose常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -h <span class="hljs-comment"># 查看帮助</span><br>docker-compose up <span class="hljs-comment"># 启动所有服务</span><br>docker-compose up -d <span class="hljs-comment"># 启动所有docker-compose服务并后台运行</span><br>docker-compose down <span class="hljs-comment"># 停止并删除容器、网络、卷、镜像</span><br>docker-compose <span class="hljs-built_in">exec</span> [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 进入容器实例内部</span><br>docker-compose ps <span class="hljs-comment"># 展示当前docker-compose编排过的运行的容器</span><br>docker-compose top <span class="hljs-comment"># 展示当前docker-compose编排过的容器进程</span><br><br>docker-compose logs [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 查看容器输出日志</span><br>docker-compose config <span class="hljs-comment"># 检查配置</span><br>docker-compose config -q <span class="hljs-comment"># 检查配置，有问题才输出</span><br>docker-compose restart <span class="hljs-comment"># 重启服务</span><br>docker-compose start <span class="hljs-comment"># 启动服务</span><br>docker-compose stop <span class="hljs-comment"># 停止服务</span><br></code></pre></td></tr></table></figure><h3 id="9-5-docker-compose-使用"><a href="#9-5-docker-compose-使用" class="headerlink" title="9.5 docker-compose 使用"></a>9.5 docker-compose 使用</h3><ol><li><p>构建镜像（基于Spring Boot）</p><ol><li><p>编写代码</p></li><li><p>配置文件修改</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">docker-compose</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc://mysql:13306/compose?useUnicode=true&amp;useSSL=false</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure></li><li><p>编写Dockerfile、docker-compose.yml</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-compose-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-compose-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">composeService:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker-compose:1.6</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">dc1.6</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6001:6001&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/java-demo:/java-demo</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="hljs-string">&quot;no&quot;</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">&quot;compose&quot;</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">&quot;root&quot;</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">&quot;root&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/db:/var/lib/mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/conf/my.cnf:/etc/my.cnf</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/init:/docker-entrypoint-initdb.d</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span> <span class="hljs-comment"># 解决外部无法访问</span><br><span class="hljs-attr">networks:</span><br>    <span class="hljs-attr">compose_net:</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>上传镜像和相关文件</p></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-compose:1.6 .<br></code></pre></td></tr></table></figure></li><li><p>执行核心操作</p><ul><li>docker-compose up -d</li></ul></li></ol><blockquote><p>总结 尽量不要使用docker-compose 不好用</p></blockquote><h2 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10. 异常处理"></a>10. 异常处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># docker search mysql 或者 docker pull 这些命令无法使用</span><br>Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid<br></code></pre></td></tr></table></figure><blockquote><p>这个错误的原因是因为系统的时间和docker hub时间不一致，需要做系统时间与网络时间同步</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装时间同步</span><br>sudo yum -y install ntp ntpdate<br><span class="hljs-comment"># 2.同步时间</span><br>sudo ntpdate cn.pool.ntp.org<br><span class="hljs-comment"># 3.查看本机时间</span><br><span class="hljs-built_in">date</span><br><span class="hljs-comment"># 4.重新测试</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务概览</title>
    <link href="/2024/05/11/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/"/>
    <url>/2024/05/11/Go%E7%B3%BB%E5%88%97/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务-一-微服务概览"><a href="#微服务-一-微服务概览" class="headerlink" title="微服务(一) 微服务概览"></a>微服务(一) 微服务概览</h1><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>先问自己几个问题，看是否可以回答，下面我们就带着问题总结课程的内容</p><ul><li>为什么会有微服务？</li><li>微服务是什么？</li><li>微服务可以带来什么好处，又有那些缺点？</li><li>微服务如何构建？</li><li>微服务如何对外暴露？</li><li>微服务如何拆分？</li><li>如何保证微服务之间的安全？</li></ul><h3 id="Q1-为什么会有微服务？"><a href="#Q1-为什么会有微服务？" class="headerlink" title="Q1:为什么会有微服务？"></a>Q1:为什么会有微服务？</h3><ul><li>之前一般是一个单一的巨石架构，存在很多问题<ul><li>应用比较复杂，没有人能够搞懂</li><li>应用扩展比较复杂，可靠性比较低</li><li>无法进行敏捷开发和部署</li></ul></li><li>所以一般这个时候就会考虑按照服务、功能进行拆分</li></ul><h3 id="Q2-微服务是什么？"><a href="#Q2-微服务是什么？" class="headerlink" title="Q2:微服务是什么？"></a>Q2:微服务是什么？</h3><ul><li>SOA （面向服务）是什么？<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>单一职责，</strong>一个服务只做一件事情</li><li><strong>尽可能的早的创建原型，</strong>先定义 API，达成契约</li><li><strong>可移植性比效率更重要，</strong>通讯协议的可移植性更加重要</li></ul></li><li>SOA 和 微服务 是什么关系？<ul><li>微服务是 SOA 的一种实践，微服务也是面向服务的一种架构</li></ul></li><li>微服务是什么？<ul><li><strong>围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术</strong></li></ul></li></ul><h3 id="Q3-微服务可以带来哪些好处，又有哪些缺点？"><a href="#Q3-微服务可以带来哪些好处，又有哪些缺点？" class="headerlink" title="Q3:微服务可以带来哪些好处，又有哪些缺点？"></a>Q3:微服务可以带来哪些好处，又有哪些缺点？</h3><ul><li><p>优点</p><ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>原子服务，</strong>一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去</li><li><strong>独立进程，</strong>一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处</li><li><strong>隔离部署，</strong>每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本</li><li>去中心化服务治理<ul><li>数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台</li><li>治理去中心化</li><li>技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的</li></ul></li></ul></li><li><p>缺点</p><ul><li><p>服务之间的依赖关系复杂成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。</p><ul><li>常见的解决方案：全链路追踪，例如， opentracing</li></ul></li><li><p>微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</p><ul><li>例子：服务调用流量会容易被放大，如果 服务 A -&gt; B -&gt;C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的</li><li><strong>常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡</strong></li></ul></li><li><p>会有分布式事务问题，</p><p>因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦</p><ul><li>常见解决方案：两阶段提交、TCC 等</li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">小米信息部技术团队: 分布式事务，这一篇就够了</a></li></ul></li><li><p>测试会非常复杂，</p><p>由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题</p><ul><li>常见解决方案：独立测试环境，后面会有一个解决方案</li></ul></li><li><p>服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。</p><ul><li>切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，<strong>时刻谨记保持服务契约(接口)的兼容性</strong></li><li>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</li></ul></li><li><p>对基础建设的要求很高，</p><p>基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等</p><ul><li>常见解决方案：上云</li></ul></li></ul><h3 id="Q4-微服务如何构建？"><a href="#Q4-微服务如何构建？" class="headerlink" title="Q4: 微服务如何构建？"></a>Q4: <strong>微服务如何构建？</strong></h3><blockquote><p>多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</p></blockquote><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><h3 id="Q5-微服务如何对外暴露？"><a href="#Q5-微服务如何对外暴露？" class="headerlink" title="Q5:微服务如何对外暴露？"></a>Q5:<strong>微服务如何对外暴露？</strong></h3><p><img src="https://i.imgur.com/qejM7Jh.png" alt="1718629799961"></p></li></ul><h4 id="流量链路是什么？"><a href="#流量链路是什么？" class="headerlink" title="流量链路是什么？"></a>流量链路是什么？</h4><ul><li>移动端 -&gt; API Gateway -&gt; BFF -&gt; 微服务</li><li>不含 CDN、负载均衡（LB）</li><li>BFF 纯 web 的业务一般用 nodejs 做 SSR</li></ul><h4 id="为什么我们的服务不直接对外进行暴露？"><a href="#为什么我们的服务不直接对外进行暴露？" class="headerlink" title="为什么我们的服务不直接对外进行暴露？"></a>为什么我们的服务不直接对外进行暴露？</h4><ul><li>前端（移动端、客户端、web）同学非常痛苦，需要对接多个服务，兼容性差，沟通效率低</li><li>后端同学也很痛苦，一年前的版本都有人使用，服务无法进行重构升级</li></ul><h4 id="为什么需要最外层的-api-gateway"><a href="#为什么需要最外层的-api-gateway" class="headerlink" title="为什么需要最外层的 api gateway?"></a>为什么需要最外层的 api gateway?</h4><ul><li>基础库的同学非常痛苦，限流熔断安全等业务无关的功能需要进行升级的时候升不动</li></ul><h3 id="Q6-微服务如何拆分？"><a href="#Q6-微服务如何拆分？" class="headerlink" title="Q6: 微服务如何拆分？"></a>Q6: <strong>微服务如何拆分？</strong></h3><ul><li><p>在对业务领域不是特别熟悉的时候，按照<strong>部门职能进行划分，例如账号、财务等</strong></p><ul><li>注意划分的时候<strong>要闭环</strong>，不要相同的功能散落到几个部门当中</li></ul></li><li><p>在系统稳定之后，积累了相关的业务经验和微服务开发经验之后，再考虑使用 DDD 限界上下文进行划分</p></li><li><p>如果可以闭环的解决一个用户场景，那么它应该是一个微服务</p></li><li><p>还可以根据访问频率进行区分划分，将用户高频访问的部分划分为一个服务</p></li><li><p>还可以根据读写进行划分</p><ul><li><p>CQRS: 将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新</p><p><img src="https://i.imgur.com/k83Ex8Q.png" alt="1718630014302"></p></li></ul></li></ul><h3 id="Q7-如何保证微服务之间的安全？"><a href="#Q7-如何保证微服务之间的安全？" class="headerlink" title="Q7:如何保证微服务之间的安全？"></a>Q7:<strong>如何保证微服务之间的安全？</strong></h3><p><img src="https://i.imgur.com/aUAJjYf.png" alt="1718630058407"></p><p>在内网主要看安全级别一般有三种：</p><ul><li>Full Trust：假定内网服务之间是安全的，在内网裸奔</li><li>Half Trust：内网服务之间需要进行认证鉴权，但是不需要所有的都进行加密</li><li>Zero Trust: 零信任，任务内部网络是不安全的，类似公网，所有的请求通过身份认证鉴权之后，都需要通过安全加密，防止被嗅探<ul><li><a href="https://www.microsoft.com/en-us/security/business/zero-trust">https://www.microsoft.com/en-us/security/business/zero-trust</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go系列</category>
      
      <category>Go进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-grpc</title>
    <link href="/2024/04/20/grpc/"/>
    <url>/2024/04/20/grpc/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-grpc"><a href="#Go-grpc" class="headerlink" title="Go-grpc"></a>Go-grpc</h1><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><h3 id="1-1-安装-protoc"><a href="#1-1-安装-protoc" class="headerlink" title="1.1 安装 protoc"></a>1.1 安装 protoc</h3><p>安装protocol buffers <a href="https://github.com/protocolbuffers/protobuf/releases">protocol</a></p><ul><li><p>Protocol buffers, 通常称为Protobuf，是Google开发的一种协议，用于允许结构体数据进行序列化和反序列化。他开发程序以通过网络相互通信或存储数据时很有用。谷歌开发它的目的是提供一种比XML更好的方式来通信。</p></li><li><p>我们将找到所有操作系统的zip文件。基于目前的操作系统。下载特定的即可。笔者使用的debian</p></li><li><p><img src="https://i.imgur.com/mJXMPVe.png" alt="image-20240424211235999"></p></li><li><p>配置环境变量，笔者使用的shell是zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.zshrc<br><span class="hljs-built_in">export</span> PATH=~/env/protoc/bin/:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li><li><p>检查是否有效，在终端中输入 protoc 命令</p></li></ul><h3 id="1-2-初始化go项目并安装grpc"><a href="#1-2-初始化go项目并安装grpc" class="headerlink" title="1.2 初始化go项目并安装grpc"></a>1.2 初始化go项目并安装grpc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init github.com/hailong-bot/h-grpc<br>go get google.golang.org/grpc<br></code></pre></td></tr></table></figure><h3 id="1-3-安装代码生成工具"><a href="#1-3-安装代码生成工具" class="headerlink" title="1.3 安装代码生成工具"></a>1.3 安装代码生成工具</h3><p>上面安装的是protoc编译器。他可以各种语言的代码。因此除了这个编译器，我们还需要配合各个语言的代码生成工具。对于Golang来说，称为<strong>protoc-gen-go</strong>。不过在这有点小坑，<strong>github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</strong>和<strong>google.golang.org&#x2F;protobuf&#x2F;cmd&#x2F;proto-gen-go</strong>是不同的。区别在于前者是旧版本，后者是google接手后的版本，他们之间API是不同的，也就是用于生成的命令，以及生成的文件是不同的。因为目前gRPC-go源码中的example采用的是后者的方式，为了与时俱进，我们也采取最新的方式。你需要安装两个库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest<br>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest<br></code></pre></td></tr></table></figure><p>因为这些文件在安装<strong>grpc</strong>的时候已经下载下来了，因此使用<strong>install</strong>命令就可以了，而不需要使用<strong>get</strong></p><p>然后$GOPATH&#x2F;bin下会出现两个文件</p><h2 id="2-proto文件编写"><a href="#2-proto文件编写" class="headerlink" title="2. proto文件编写"></a>2. proto文件编写</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 说明我们在使用proto3语法 </span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span><br><br><span class="hljs-comment">// 这部分的内容是关于最后生成的go文件在哪个目录哪个包里面，.代表当前目录, service代表生成的go文件的包名是service </span><br><span class="hljs-keyword">option</span> go_package =<span class="hljs-string">&quot;.;service&quot;</span><br><br><span class="hljs-comment">// 定义一个服务一个方法 这个方法接受一个参数并返回一个响应</span><br><span class="hljs-comment">// 这个方法会发送一个HelloRequest，然后返回一个HelloResponse</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">SayHello</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// message关键字 可以理解为定义结构体</span><br><span class="hljs-comment">// 这里面比较特殊 后面的赋值是表明变量在这个message中的位置</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> requestName = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> responseMsg = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写完上面的文件，在proto文件同级目录执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --go_out=. hello.proto<br>protoc --go-grpc_out=. hello.proto<br></code></pre></td></tr></table></figure><p>最后会生成两个go代码，更改具体方法即可</p><h3 id="2-1-proto文件介绍"><a href="#2-1-proto文件介绍" class="headerlink" title="2.1 proto文件介绍"></a>2.1 proto文件介绍</h3><blockquote><p>message</p></blockquote><p>messgae: protobug中定义一个消息类型式是通过message字段制定的。消息就是需要传输的数据格式的定义</p><p>message关键字类似于c++中的class, java中的class, go中的struct</p><blockquote><p>字段规则</p></blockquote><p>required: 消息中必填字段，不设置会导致编码异常。在protobuf3中被删去</p><p>optional: 消息中设置可选字段，protobuf3中被删除</p><p>repeated: 消息体中可重复字段，重复的值的顺序会被保留在go中重复的会被定义为切片</p><blockquote><p>消息号</p></blockquote><p>在消息体的定义中，<strong>每个字段都必须要有唯一一个标识号</strong>，标识号是[1, 2^29-1]的<strong>一个整数</strong></p><blockquote><p>嵌套消息</p></blockquote><p>可以在其他消息类型中定义、使用消息类型，在下面的例子中,Person消息就定义在PersonInfo消息内</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">PersonInfo</span>&#123;<br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br><span class="hljs-type">int32</span> height = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">repeated</span> <span class="hljs-type">int32</span> weight = <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">repeated</span> Person info = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要在它的父消息类型的外部重用这个消息类型，需要PersonInfo.Person形式使用，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">PersonMessage</span> &#123;<br>PersonInfo.Person info = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>服务定义</p></blockquote><p>如果想要将消息类型用在RPC系统中，可以在.proto文件中定义一个rpc服务接口，protocol buffer编译器将会根据所选择的语言生成服务接口代码</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>上述代表，定义了一个RPC服务，该方法接受SearchRequest返回SearchResponse</p><h2 id="3-服务端编写"><a href="#3-服务端编写" class="headerlink" title="3. 服务端编写"></a>3. 服务端编写</h2><ul><li><p>创建gRPC Server对象，可以理解为它是Server端的抽象对象</p></li><li><p>将server(其中包含需要被调用的服务端接口) 注册到gRPC Server的内部注册中心，这样可以在接受到请求的时候，通过内部服务发现，发现该服务端接口并转发进行逻辑处理</p></li><li><p>创建Listen，监听TCP端口</p></li><li><p>gRPC Server 开始lis.Accept，直到Stop</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 服务端</span><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span> &#123;<br>pb.UnimplementedSayHelloServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> &amp;pb.HelloResponse&#123;<br>ResponseMsg: <span class="hljs-string">&quot;HelloWord&quot;</span> + req.RequestName,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:9090&quot;</span>)<br>grpcServer := grpc.NewServer()<br>pb.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;)<br>fmt.Println(<span class="hljs-string">&quot;启动成功&quot;</span>)<br>err := grpcServer.Serve(listen)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;启动失败&quot;</span>)<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-客户端编写"><a href="#4-客户端编写" class="headerlink" title="4. 客户端编写"></a>4. 客户端编写</h2><ul><li><p>创建与给定目标（服务端）的连接交互</p></li><li><p>创建Server的客户端对象</p></li><li><p>发送RPC请求，等待同步响应，得到回调后返回响应结果</p></li><li><p>输出响应结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:9090&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;did not connect: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>client := pb.NewSayHelloClient(conn)<br>helloResponse, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;RequestName: <span class="hljs-string">&quot;phoenix&quot;</span>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;失败&quot;</span>)<br>&#125;<br>fmt.Println(helloResponse)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口幂等性</title>
    <link href="/2024/02/28/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2024/02/28/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h1><h1 id="1-什么是幂等性"><a href="#1-什么是幂等性" class="headerlink" title="1. 什么是幂等性"></a>1. 什么是幂等性</h1><p>接口幂等性就是用户对于同一操作发起的一次请求或则多次请求的结果是一致的，不回因为多次点击而产生了副作用。比如说支付场景，用户购买了商品支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条．．．,这就没有保证接口的幂等性</p><h1 id="2-哪些情况需要防止"><a href="#2-哪些情况需要防止" class="headerlink" title="2. 哪些情况需要防止"></a>2. 哪些情况需要防止</h1><p>用户多次点击按钮</p><p>用户页面回退再次提交</p><p>微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制（或代码中的重试机制）</p><p>其他业务情况</p><h1 id="3-什么情况下需要幂等"><a href="#3-什么情况下需要幂等" class="headerlink" title="3. 什么情况下需要幂等"></a>3. 什么情况下需要幂等</h1><p>以 SQL 为例，有些操作是天然幂等的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> WHER id<span class="hljs-operator">=</span>? #无论执行多少次都不会改变状态，是天然的幂等<br><span class="hljs-keyword">UPDATE</span> tab1 <span class="hljs-keyword">SET</span> col1<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> col2<span class="hljs-operator">=</span><span class="hljs-number">2</span> #无论执行成功多少次状态都是一致的，也是幂等操作<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid<span class="hljs-operator">=</span><span class="hljs-number">1</span> #多次操作，结果一样，具备幂等性<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(userid,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>) # 如 userid 为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<br><br><br><span class="hljs-keyword">UPDATE</span> tab1 <span class="hljs-keyword">SET</span> col1<span class="hljs-operator">=</span>col1<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> col2<span class="hljs-operator">=</span><span class="hljs-number">2</span> # 每次执行的结果都会发生变化，不是幂等的<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(userid,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>) #) 如 userid 不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性<br></code></pre></td></tr></table></figure><h1 id="4-幂等解决方案"><a href="#4-幂等解决方案" class="headerlink" title="4. 幂等解决方案"></a>4. 幂等解决方案</h1><h2 id="4-1-token实现接口幂等性"><a href="#4-1-token实现接口幂等性" class="headerlink" title="4.1 token实现接口幂等性"></a>4.1 token实现接口幂等性</h2><ol><li><p>实现思路</p><p>为需要保证幂等性的每一次请求创建一个唯一标识token, 先获取token, 并将此token存入redis, 请求接口时, 将此token放到header或者作为请求参数请求接口, 后端接口判断redis中是否存在此token: 如果存在, 正常处理业务逻辑, 并从redis中删除此token, 那么, 如果是重复请求, 由于token已被删除, 则不能通过校验, 返回请勿重复操作提示， 如果不存在, 说明参数不合法或者是重复请求, 返回提示即可。</p></li><li><p>Java版实现逻辑</p><blockquote><p>pom.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>RedisUtil</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisUtil</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(RedisUtil.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;set key:&#123;&#125; value:&#123;&#125;&quot;</span>, key, value);<br>        stringRedisTemplate.opsForValue().set(key,value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 过期时间, 单位: s</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String value, <span class="hljs-type">int</span> expireTime)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;set key:&#123;&#125; value:&#123;&#125; expireTime:&#123;&#125;&quot;</span>, key, value, expireTime);<br>        stringRedisTemplate.opsForValue().set(key,value, expireTime,TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;get key:&#123;&#125;&quot;</span>, key);<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">del</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (exists(key)) &#123;<br>            <span class="hljs-keyword">return</span> stringRedisTemplate.delete(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.error(<span class="hljs-string">&quot;del key:&#123;&#125;&quot;</span>, key+<span class="hljs-string">&quot; 不存在&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断key是否存在</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">exists</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> stringRedisTemplate.hasKey(key);<br>        logger.info(<span class="hljs-string">&quot;exists key:&#123;&#125; hasKey:&#123;&#125;&quot;</span>, key, exists);<br>        <span class="hljs-keyword">return</span> exists;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自定义注解 @ApiIdempotent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.smartMap.media.common.apiIdempotent.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ApiIdempotent &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>响应状态码 ResponseCode</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ResponseCode</span> &#123;<br><br>    ILLEGAL_ARGUMENT(<span class="hljs-number">10000</span>, <span class="hljs-string">&quot;参数不合法&quot;</span>),<br>    REPETITIVE_OPERATION(<span class="hljs-number">10001</span>, <span class="hljs-string">&quot;请勿重复操作&quot;</span>),<br>    ;<br><br>    ResponseCode(Integer code, String msg) &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Integer code;<br><br>    <span class="hljs-keyword">private</span> String msg;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(Integer code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMsg</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>常量 Constant</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constant</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Redis</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">OK</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_MINUTE</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<span class="hljs-comment">// 过期时间, 60s, 一分钟</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_FIVE_MINUTE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span> * <span class="hljs-number">60</span>;<span class="hljs-comment">// 过期时间, 60s, 一分钟</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_HOUR</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<span class="hljs-comment">// 过期时间, 一小时</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">EXPIRE_TIME_DAY</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>;<span class="hljs-comment">// 过期时间, 一天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">TOKEN_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;API_IDEMPOTENT_TOKEN:&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>token接口 ApiIdempotentTokenService</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.R;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiIdempotentTokenService</span> &#123;<br><br>    R <span class="hljs-title function_">createToken</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkToken</span><span class="hljs-params">(HttpServletRequest request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>token接口实现类 ApiIdempotentTokenServiceImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.smartMap.media.common.apiIdempotent.service.impl;<br><br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.common.Constant;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.common.ResponseCode;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.service.ApiIdempotentTokenService;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.utils.RedisUtil;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.exception.RRException;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.R;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.UuidUtils;<br><span class="hljs-keyword">import</span> org.apache.commons.lang.text.StrBuilder;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service(&quot;apiIdempotentTokenService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiIdempotentTokenServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApiIdempotentTokenService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">API_IDEMPOTENT_TOKEN_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apiIdempotentToken&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">createToken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> UuidUtils.randomUUID();<br>        <span class="hljs-type">StrBuilder</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrBuilder</span>();<br>        token.append(Constant.Redis.TOKEN_PREFIX).append(str);<br>        redisUtil.set(token.toString(), token.toString(), Constant.Redis.EXPIRE_TIME_FIVE_MINUTE);<br>        <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">&quot;token&quot;</span>,token.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkToken</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(API_IDEMPOTENT_TOKEN_NAME);<br>        <span class="hljs-comment">// header中不存在token</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>            token = request.getParameter(API_IDEMPOTENT_TOKEN_NAME);<br>            <span class="hljs-comment">// parameter中也不存在token</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RRException</span>(ResponseCode.ILLEGAL_ARGUMENT.getMsg(),ResponseCode.ILLEGAL_ARGUMENT.getCode());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!redisUtil.exists(token)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RRException</span>(ResponseCode.REPETITIVE_OPERATION.getMsg(),ResponseCode.REPETITIVE_OPERATION.getCode());<br>        &#125;<br><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">del</span> <span class="hljs-operator">=</span> redisUtil.del(token);<br>        <span class="hljs-keyword">if</span> (!del) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RRException</span>(ResponseCode.REPETITIVE_OPERATION.getMsg(),ResponseCode.REPETITIVE_OPERATION.getCode());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>拦截器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.annotation.ApiIdempotent;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.service.ApiIdempotentTokenService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiIdempotentInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandlerInterceptorAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApiIdempotentTokenService apiIdempotentTokenService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> handlerMethod.getMethod();<br><br>        <span class="hljs-type">ApiIdempotent</span> <span class="hljs-variable">methodAnnotation</span> <span class="hljs-operator">=</span> method.getAnnotation(ApiIdempotent.class);<br>        <span class="hljs-keyword">if</span> (methodAnnotation != <span class="hljs-literal">null</span>) &#123;<br>            check(request);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        apiIdempotentTokenService.checkToken(request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>拦截器注册WebConfig</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.interceptor.ApiIdempotentInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApiIdempotentInterceptor apiIdempotentInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(apiIdempotentInterceptor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试验证 controller</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.annotation.ApiIdempotent;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.apiIdempotent.service.ApiIdempotentTokenService;<br><span class="hljs-keyword">import</span> com.smartMap.media.common.utils.R;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/mobile/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApiIdempotentTokenService apiIdempotentTokenService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;getToken&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> apiIdempotentTokenService.createToken();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试接口幂等性, 在需要幂等性校验的方法上声明此注解即可</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiIdempotent</span><br>    <span class="hljs-meta">@RequestMapping(&quot;testIdempotence&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">testIdempotence</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> R.ok(<span class="hljs-string">&quot;测试接口幂等性&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>流程</p></blockquote><p>前端获取接口token -&gt; 请求幂等性接口时请求头带上token </p><blockquote><p>tips</p></blockquote><p>删除token时校验下，没有使用分布式锁，不能保证原子性，删除token时那个操作对于redis来说具有原子性，因此必须校验。</p><p>弊端：此操作每次都要去请求token。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>如果要保证获取token、判断、删除具有原子性可以采取上面的措施</p></li></ol><h2 id="4-2-各种锁机制"><a href="#4-2-各种锁机制" class="headerlink" title="4.2 各种锁机制"></a>4.2 各种锁机制</h2><h3 id="4-2-1-数据库悲观锁"><a href="#4-2-1-数据库悲观锁" class="headerlink" title="4.2.1 数据库悲观锁"></a>4.2.1 数据库悲观锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xxxx <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。<strong>不推荐使用</strong></p><blockquote><p>Java示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;MyEntity&gt; &#123;<br><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM my_entity WHERE request_id = #&#123;requestId&#125; FOR UPDATE&quot;)</span><br>    MyEntity <span class="hljs-title function_">lockByRequestId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;requestId&quot;)</span> String requestId)</span>;<br>&#125;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyMapper myMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(MyMapper myMapper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myMapper = myMapper;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(String requestId)</span> &#123;<br>        <span class="hljs-type">MyEntity</span> <span class="hljs-variable">existingRecord</span> <span class="hljs-operator">=</span> myMapper.selectById(requestId);<br><br>        <span class="hljs-keyword">if</span> (existingRecord != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">MyEntity</span> <span class="hljs-variable">lockedEntity</span> <span class="hljs-operator">=</span> myMapper.lockByRequestId(requestId);<br><br>            <span class="hljs-comment">// 由于设置了行锁 同一个请求ID 进来 这一行进行了行锁</span><br>            <span class="hljs-comment">// 执行业务逻辑，处理请求</span><br>        handleOrderProcessing(lockedOrder);<br>            <span class="hljs-comment">// ...</span><br><br>            <span class="hljs-comment">// 锁会在事务提交时自动释放</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 未找到记录，可能需要创建新的记录</span><br>            <br>            <span class="hljs-type">MyEntity</span> <span class="hljs-variable">newRecord</span> <span class="hljs-operator">=</span> createNewRecord(requestId);<br>            myMapper.insert(newRecord);<br><br>            <span class="hljs-comment">// 执行业务逻辑，处理请求</span><br>            handleRequestProcessing(newRecord);<br>            <span class="hljs-comment">// 锁会在事务提交时自动释放</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码使用了Spring的<code>@Transactional</code>注解，确保整个方法在一个数据库事务中运行。<code>myRepository.lockByRequestId(requestId)</code>表示使用悲观锁锁定具有给定请求标识符的数据库行。如果已经存在具有相同请求标识符的记录，则直接返回之前的处理结果，否则执行实际的业务逻辑并将结果保存到数据库。这确保了在悲观锁的保护下，对相同请求的多次处理仅执行一次实际的业务逻辑。</p><p><strong>锁在事务提交时自动释放的意思时：在事务中获取的悲观锁（例如，在 <code>lockByOrderId</code> 方法中的 <code>SELECT ... FOR UPDATE</code> 查询）会一直持续到事务提交。一旦事务成功提交，数据库会自动释放这个锁，使得其他事务可以访问相应的资源。</strong></p><p>实体中  requestId 需要要设置唯一索引</p><h3 id="4-2-2-数据库乐观锁"><a href="#4-2-2-数据库乐观锁" class="headerlink" title="4.2.2 数据库乐观锁"></a>4.2.2 数据库乐观锁</h3><p>数据库乐观锁通常用于解决多个事务同时访问相同数据时可能引发的并发问题。在数据库乐观锁的场景中，接口幂等性的实现通常是通过版本号（或者称为修改时间戳）来保证的。以下是一个简单的示例，演示如何使用乐观锁和版本号来实现接口幂等性：</p><ol><li><p>数据表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_entity (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    request_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    data <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>    version <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span><br>);<br></code></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;my_entity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEntity</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String data;<br>    <span class="hljs-keyword">private</span> Integer version;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Update;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;MyEntity&gt; &#123;<br><br>    <span class="hljs-meta">@Update(&quot;UPDATE my_entity SET data = #&#123;data&#125;, version = version + 1 WHERE request_id = #&#123;requestId&#125; AND version = #&#123;version&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateDataByVersion</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;requestId&quot;)</span> String requestId, <span class="hljs-meta">@Param(&quot;data&quot;)</span> String data, <span class="hljs-meta">@Param(&quot;version&quot;)</span> <span class="hljs-type">int</span> version)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>updateDataByVersion</code> 方法使用了 MyBatis Plus 的 <code>@Update</code> 注解，执行了一个带有版本号检查的更新操作。更新时，会检查传入的版本号是否与数据库中的版本号一致，如果一致才执行更新操作。</p></li><li><p>核心逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyMapper myMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(MyMapper myMapper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myMapper = myMapper;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(String requestId, String newData)</span> &#123;<br>        <span class="hljs-comment">// 根据请求ID查询记录</span><br>        <span class="hljs-type">MyEntity</span> <span class="hljs-variable">existingRecord</span> <span class="hljs-operator">=</span> myMapper.selectById(requestId);<br><br>        <span class="hljs-keyword">if</span> (existingRecord != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新数据（带版本号检查）</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">updatedRows</span> <span class="hljs-operator">=</span> myMapper.updateDataByVersion(requestId, newData, existingRecord.getVersion());<br><br>            <span class="hljs-keyword">if</span> (updatedRows &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 更新成功，执行业务逻辑</span><br>                handleRequestProcessing(requestId, newData);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 更新失败，可能是版本号不匹配</span><br>                <span class="hljs-comment">// 可以根据实际情况进行处理，比如抛出异常</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 未找到记录，创建新的记录</span><br>            <span class="hljs-type">MyEntity</span> <span class="hljs-variable">newRecord</span> <span class="hljs-operator">=</span> createNewRecord(requestId, newData);<br>            myMapper.insert(newRecord);<br><br>            <span class="hljs-comment">// 执行业务逻辑，处理请求</span><br>            handleRequestProcessing(requestId, newData);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequestProcessing</span><span class="hljs-params">(String requestId, String newData)</span> &#123;<br>        <span class="hljs-comment">// 具体的业务逻辑，例如记录日志等</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> MyEntity <span class="hljs-title function_">createNewRecord</span><span class="hljs-params">(String requestId, String newData)</span> &#123;<br>        <span class="hljs-comment">// 创建新的记录</span><br>        <span class="hljs-type">MyEntity</span> <span class="hljs-variable">newRecord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEntity</span>();<br>        newRecord.setRequestId(requestId);<br>        newRecord.setData(newData);<br>        newRecord.setVersion(<span class="hljs-number">0</span>); <span class="hljs-comment">// 初始版本号</span><br>        <span class="hljs-keyword">return</span> newRecord;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>笔者强烈推荐使用悲观锁实现，特别是Java开发人员，如果是使用Mybatis Plus可以使用插件来完成这一系列的操作 ，来避免重复操作，后续代码笔者会给出 github 地址。</strong></p></li></ol><h2 id="4-3-各种唯一索引"><a href="#4-3-各种唯一索引" class="headerlink" title="4.3 各种唯一索引"></a>4.3 各种唯一索引</h2><h3 id="4-3-1-数据库唯一索引"><a href="#4-3-1-数据库唯一索引" class="headerlink" title="4.3.1 数据库唯一索引"></a>4.3.1 数据库唯一索引</h3><p>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。<strong>不推荐 比较难以控制</strong></p><h3 id="4-3-2-redis-set防重"><a href="#4-3-2-redis-set防重" class="headerlink" title="4.3.2 redis set防重"></a>4.3.2 redis set防重</h3><p>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的 set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理。</p><h2 id="4-4-防重表"><a href="#4-4-防重表" class="headerlink" title="4.4 防重表"></a>4.4 防重表</h2><p>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。之前说的 redis 防重也算</p><h2 id="4-5-全局请求唯一ID"><a href="#4-5-全局请求唯一ID" class="headerlink" title="4.5 全局请求唯一ID"></a>4.5 全局请求唯一ID</h2><p>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。可以使用 nginx 设置每一个请求的唯一 id；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">proxy_set_header X-Request-Id $request_id;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>方法论</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mongo</title>
    <link href="/2024/02/28/Mongo/"/>
    <url>/2024/02/28/Mongo/</url>
    
    <content type="html"><![CDATA[<h1 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</p><p>在高负载的情况下，添加更多的节点，可以保证服务器性能。</p><p>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><h2 id="1-1-主要特点"><a href="#1-1-主要特点" class="headerlink" title="1.1 主要特点"></a>1.1 主要特点</h2><ul><li>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</li><li>你可以在MongoDB记录中设置任何属性的索引 (如：FirstName&#x3D;”Sameer”,Address&#x3D;”8 Gandhi Road”)来实现更快的排序。</li><li>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li><li>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li><li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li><li>Mongodb中的Map&#x2F;reduce主要是用来对数据进行批量处理和聚合操作。</li><li>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</li><li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</li><li>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</li><li>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li><li>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li><li>MongoDB安装简单</li></ul><h2 id="1-2-MongoDB概念解析"><a href="#1-2-MongoDB概念解析" class="headerlink" title="1.2  MongoDB概念解析"></a>1.2  MongoDB概念解析</h2><p>不管我们学习什么数据库都应该学习其中的基础概念，在mongodb中基本的概念是文档、集合、数据库，下面我们挨个介绍。</p><p>下表将帮助您更容易理解Mongo中的一些概念：</p><table><thead><tr><th>SQL术语&#x2F;概念</th><th>MongoDB术语概念</th><th>解释&#x2F;说明</th></tr></thead><tbody><tr><td>database</td><td>databse</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表&#x2F;集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行&#x2F;文档</td></tr><tr><td>column</td><td>field</td><td>数据库字段&#x2F;域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接， MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键，MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p>通过下图实例，我们也可以更直观的了解Mongo中的一些概念：</p><p><img src="https://i.imgur.com/m7H6Ewr.png" alt="img"></p><h1 id="2-MongoDB-连接"><a href="#2-MongoDB-连接" class="headerlink" title="2. MongoDB 连接"></a>2. MongoDB 连接</h1><blockquote><p>本文建议使用mongo命令进行连接</p></blockquote><p><img src="https://i.imgur.com/KIwvBx0.png" alt="3be8fe49ad683912270fcd513242793"></p><p>连接示例： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongo --host localhsot --username admin --passwod admin123 --port 27017<br></code></pre></td></tr></table></figure><p>由于mongo安装比较简单，推荐使用docker安装，目前我是直接向docker里面起了一个mongo容器，进入容器后使用的mongo，windows安装mongo后可能没有这个命令。</p><h1 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h1><h2 id="3-1-查询数据库"><a href="#3-1-查询数据库" class="headerlink" title="3.1 查询数据库"></a>3.1 查询数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show databases<br>show dbs<br></code></pre></td></tr></table></figure><h2 id="3-2-删除数据库"><a href="#3-2-删除数据库" class="headerlink" title="3.2 删除数据库"></a>3.2 删除数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.dropDatabase()<br></code></pre></td></tr></table></figure><h2 id="3-3-创建集合"><a href="#3-3-创建集合" class="headerlink" title="3.3 创建集合"></a>3.3 创建集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.createCollectction(<span class="hljs-string">&quot;phoenix&quot;</span>)<br></code></pre></td></tr></table></figure><p>当在集合不存在的情况下，直接插入文档，MongoDB会自动创建文档</p><h2 id="3-4-查询集合"><a href="#3-4-查询集合" class="headerlink" title="3.4 查询集合"></a>3.4 查询集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show tables<br>show collections<br></code></pre></td></tr></table></figure><h2 id="3-5-删除集合"><a href="#3-5-删除集合" class="headerlink" title="3.5 删除集合"></a>3.5 删除集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.phoenix.drop()<br></code></pre></td></tr></table></figure><h2 id="3-6-插入文档"><a href="#3-6-插入文档" class="headerlink" title="3.6 插入文档"></a>3.6 插入文档</h2><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.COLLECTION_NAME.insert(document)<br>或<br>db.COLLECTION_NAME.save(document)<br></code></pre></td></tr></table></figure><ul><li>save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。</li><li>insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。</li></ul><p>**3.2 版本之后新增了 db.collection.insertOne() 和 db.collection.insertMany()**。</p><p>db.collection.insertOne() 用于向集合插入一个新文档，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.insertOne(<br>   &lt;document&gt;,<br>   &#123;<br>      writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>db.collection.insertMany() 用于向集合插入一个多个文档，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.insertMany(<br>   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],<br>   &#123;<br>      writeConcern: &lt;document&gt;,<br>      ordered: &lt;boolean&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>document：要写入的文档。</li><li>writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。</li><li>ordered：指定是否按顺序写入，默认 true，按顺序写入。</li></ul><blockquote><p>例子</p></blockquote><p>以下文档可以存储在 MongoDB 的 phoenix 数据库 的 demo集合中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">use phoenix<br>db.demo.insertOne(<span class="hljs-punctuation">&#123;</span><br>desc<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;demo&quot;</span><span class="hljs-punctuation">,</span><br>    by<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;phoenix&quot;</span><span class="hljs-punctuation">,</span><br>    tags<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;demo&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;learn&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;MongoDB&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span>)<br></code></pre></td></tr></table></figure><p>以上实例中 col 是我们的集合名，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。</p><h2 id="3-7-更新文档"><a href="#3-7-更新文档" class="headerlink" title="3.7 更新文档"></a>3.7 更新文档</h2><p>MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。</p><p><strong>update() 方法</strong><br>update() 方法用于更新已存在的文档。语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.update(<br>   &lt;query&gt;,<br>   &lt;update&gt;,<br>   &#123;<br>     upsert: &lt;boolean&gt;,<br>     multi: &lt;boolean&gt;,<br>     writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query : update的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\</li><li>writeConcern :可选，抛出异常的级别。</li></ul><p>更新开始插入phoenix中的数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">db.demo.update(<br>    <span class="hljs-punctuation">&#123;</span>&#x27;desc&#x27;<span class="hljs-punctuation">:</span> &#x27;demo&#x27;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-punctuation">&#123;</span>$set<span class="hljs-punctuation">:</span><br>     <span class="hljs-punctuation">&#123;</span>&#x27;desc&#x27;<span class="hljs-punctuation">:</span>&#x27;MognoDB&#x27;<span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>updateOne、updateMany方法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.collection.updateOne(<br><span class="hljs-operator">&lt;</span>query<span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-operator">&lt;</span><span class="hljs-keyword">update</span><span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-operator">&lt;</span>option<span class="hljs-operator">&gt;</span><br>)<br></code></pre></td></tr></table></figure><p>实际开发过程中可能updateOne和updateMany使用的比较多</p><p>举个例子：可能会遇到字段中包含数组对象的情况，arrayFilter选项可以选择具体是哪个元素（根据条件）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.form.updateMany(<br>&#123;<br>&quot;fieldGroupList.name&quot;: &quot;相对方信息&quot;,<br>&quot;fieldGroupList.fieldList.id&quot;: &#123;<br>            &quot;$eq&quot;: &quot;counterpartyGroup_group&quot;,<br>        &#125;,<br>&#125;,<br>&#123;<br>&quot;$set&quot; : &#123;<br>&quot;fieldGroupList.$[elem].fieldList.$[e]&quot;: &#123;<br>&quot;id&quot;:         &quot;counterpartyGroup_chabaidao&quot;,<br>&quot;name&quot;:       &quot;相对方组&quot;,<br>&quot;type&quot;:       <span class="hljs-number">-32</span>,<br>&quot;isRequired&quot;: <span class="hljs-literal">false</span>,<br>&quot;isFixed&quot;:    <span class="hljs-literal">true</span>,<br>&#125;<br>&#125;<br>&#125;,<br>&#123;<br>&quot;arrayFilters&quot;: [<br>&#123;<br>&quot;elem.name&quot;: &quot;相对方信息&quot;<br>&#125;,<br>&#123;<br>&quot;e.id&quot;: &quot;counterpartyGroup_chabaidao&quot;<br>&#125;<br>]<br>&#125;<br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.contract_chabaidao.updateOne(<br>&#123;<br>&quot;contractType.formFields.name&quot;: &quot;相对方信息&quot;,<br>&quot;contractType.formFields.fieldList.name&quot;: &#123;<br>&quot;$in&quot;: [&quot;外部相对方&quot;,&quot;内部相对方&quot;]<br>&#125;,<br>&quot;_id&quot;: ObjectId(&quot;650fd2e1f6c3e755d4d3fca6&quot;)<br>&#125;,<br>&#123;<br>&quot;$pull&quot;: &#123;<br>&quot;contractType.formFields.$[counter].fieldList&quot;: &#123;<br>&quot;name&quot;: &#123;<br>&quot;$in&quot;: [&quot;内部相对方&quot;,&quot;外部相对方&quot;]<br>&#125;<br>&#125;<br>&#125;<br>&#125;,<br>&#123;<br>&quot;arrayFilters&quot;: [&#123;&quot;counter.name&quot;: &quot;相对方信息&quot;&#125;]<br>&#125;<br>)<br></code></pre></td></tr></table></figure><p><strong>save() 方法</strong></p><p>save() 方法通过传入的文档来替换已有文档，_id 主键存在就更新，不存在就插入。语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.save(<br>   &lt;document&gt;,<br>   &#123;<br>     writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>document : 文档数据。</li><li>writeConcern :可选，抛出异常的级别。</li></ul><blockquote><p>例子</p></blockquote><p>以下实例中我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;db.col.save(&#123;<br>    <span class="hljs-string">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;56064f89ade2f21f36b03136&quot;</span>),<br>    <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB&quot;</span>,<br>    <span class="hljs-string">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>,<br>    <span class="hljs-string">&quot;by&quot;</span> : <span class="hljs-string">&quot;Runoob&quot;</span>,<br>    <span class="hljs-string">&quot;tags&quot;</span> : [<br>            <span class="hljs-string">&quot;mongodb&quot;</span>,<br>            <span class="hljs-string">&quot;NoSQL&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;likes&quot;</span> : 110<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-8-删除文档"><a href="#3-8-删除文档" class="headerlink" title="3.8 删除文档"></a>3.8 删除文档</h2><p>MongoDB remove() 函数是用来移除集合中的数据。</p><p>MongoDB 数据更新可以使用 update() 函数。在执行 remove() 函数前先执行 find() 命令来判断执行的条件是否正确，这是一个比较好的习惯。</p><p><strong>语法</strong></p><p>remove() 方法的基本语法格式如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.remove(<br>   &lt;query&gt;,<br>   &lt;justOne&gt;<br>)<br></code></pre></td></tr></table></figure><p>如果你的 MongoDB 是 2.6 版本以后的，语法格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.collection.remove(<br>   &lt;query&gt;,<br>   &#123;<br>     justOne: &lt;boolean&gt;,<br>     writeConcern: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><p><strong>例子</strong></p><p>以下文档我们执行两次插入操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;db.col.insertOne(&#123;title: <span class="hljs-string">&#x27;MongoDB 教程&#x27;</span>, <br>    description: <span class="hljs-string">&#x27;MongoDB 是一个 Nosql 数据库&#x27;</span>,<br>    tags: [<span class="hljs-string">&#x27;mongodb&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;NoSQL&#x27;</span>],<br>    likes: 100<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用 find() 函数查询数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; db.col.<span class="hljs-function"><span class="hljs-title">find</span></span>()<br>&#123; <span class="hljs-string">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;56066169ade2f21f36b03137&quot;</span>), <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB 教程&quot;</span>, <span class="hljs-string">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>, <span class="hljs-string">&quot;tags&quot;</span> : [ <span class="hljs-string">&quot;mongodb&quot;</span>, <span class="hljs-string">&quot;database&quot;</span>, <span class="hljs-string">&quot;NoSQL&quot;</span> ], <span class="hljs-string">&quot;likes&quot;</span> : 100 &#125;<br>&#123; <span class="hljs-string">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;5606616dade2f21f36b03138&quot;</span>), <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB 教程&quot;</span>, <span class="hljs-string">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>, <span class="hljs-string">&quot;tags&quot;</span> : [ <span class="hljs-string">&quot;mongodb&quot;</span>, <span class="hljs-string">&quot;database&quot;</span>, <span class="hljs-string">&quot;NoSQL&quot;</span> ], <span class="hljs-string">&quot;likes&quot;</span> : 100 &#125;<br></code></pre></td></tr></table></figure><p>移除 title 为 ‘MongoDB 教程’ 的文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;db.col.remove(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB 教程&#x27;</span>&#125;)<br>WriteResult(&#123; <span class="hljs-string">&quot;nRemoved&quot;</span> : 2 &#125;)           <span class="hljs-comment"># 删除了两条数据</span><br>&gt;db.col.find()<br>……                                        <span class="hljs-comment"># 没有数据</span><br></code></pre></td></tr></table></figure><p>如果向删除所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">&gt;db.col.remove(&#123;&#125;)<br></code></pre></td></tr></table></figure><h1 id="4-DSL语句"><a href="#4-DSL语句" class="headerlink" title="4. DSL语句"></a>4. DSL语句</h1><blockquote><p>常用的就那些</p></blockquote><h1 id="5-聚合查询"><a href="#5-聚合查询" class="headerlink" title="5. 聚合查询"></a>5. 聚合查询</h1><p>MongoDB  中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。</p><p>有点类似 <strong>SQL</strong> 语句中的 **count(*)**。</p><h2 id="5-1-aggregate-方法"><a href="#5-1-aggregate-方法" class="headerlink" title="5.1 aggregate 方法"></a>5.1 aggregate 方法</h2><p>MongoDB 中聚合的方法使用aggregate()。</p><p>aggregate() 方法的基本语法格式如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)<br></code></pre></td></tr></table></figure><p>AGGREGATE_OPERATION 详解</p><blockquote><p>示例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.orders.aggregate([<br>  &#123;<br>    $<span class="hljs-keyword">group</span>: &#123;<br>      _id: &quot;$category&quot;,<br>      totalOrders: &#123; $sum: <span class="hljs-number">1</span> &#125;,<br>      averagePrice: &#123; $avg: &quot;$price&quot; &#125;<br>    &#125;<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><p><strong>用法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;<br>  $<span class="hljs-keyword">group</span>: &#123;<br>    _id: <span class="hljs-operator">&lt;</span>expression<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 用于指定分组的依据，可以是字段名或者表达式<br>    field1: &#123; <span class="hljs-operator">&lt;</span>accumulator1<span class="hljs-operator">&gt;</span> : <span class="hljs-operator">&lt;</span>expression1<span class="hljs-operator">&gt;</span> &#125;, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对应于要计算的字段<span class="hljs-number">1</span>的累加器和表达式<br>    field2: &#123; <span class="hljs-operator">&lt;</span>accumulator2<span class="hljs-operator">&gt;</span> : <span class="hljs-operator">&lt;</span>expression2<span class="hljs-operator">&gt;</span> &#125;, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对应于要计算的字段<span class="hljs-number">2</span>的累加器和表达式<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细用法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.orders.aggregate([<br>  &#123;<br>    $<span class="hljs-keyword">match</span>: &#123;<br>      category: &quot;food&quot; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 过滤category字段为&quot;food&quot;的文档<br>    &#125;<br>  &#125;,<br>  &#123;<br>    $<span class="hljs-keyword">group</span>: &#123;<br>      _id: &quot;$category&quot;,<br>      totalOrders: &#123; $sum: <span class="hljs-number">1</span> &#125;,<br>      averagePrice: &#123; $avg: &quot;$price&quot; &#125;<br>    &#125;<br>  &#125;,<br>  &#123;<br>    $sort: &#123; averagePrice: <span class="hljs-number">-1</span> &#125; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 按照平均价格降序排序<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><h3 id="5-1-1-accumulator"><a href="#5-1-1-accumulator" class="headerlink" title="5.1.1 accumulator"></a>5.1.1 accumulator</h3><p>在MongoDB的聚合管道中，累加器（accumulator）是用于对文档进行聚合计算的操作符。累加器操作符允许您在聚合过程中对文档的字段进行累加、平均、最小值、最大值、首个值、最后一个值等操作。以下是一些常用的累加器操作符以及它们的用途：</p><ol><li><p><code>$sum</code>: 对指定字段的值进行求和计算。</p><ul><li>用途：计算某个字段的总和，例如订单金额的总和等。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.locations.aggregate([<br>  &#123;<br>    $<span class="hljs-keyword">group</span>: &#123;<br>      _id: <span class="hljs-keyword">null</span>, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 由于我们希望对整个集合中的文档进行聚合，因此将 _id 设置为 <span class="hljs-keyword">null</span><br>      totalDistance: &#123; $sum: &quot;$distance&quot; &#125;,<br>   count: &#123;$sum: <span class="hljs-number">1</span>&#125;, <span class="hljs-comment">-- 文档数量</span><br>    &#125;<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><p>后续大同小异，类似与Group By</p></li><li><p><code>$avg</code>: 对指定字段的值进行平均计算。</p><ul><li>用途：计算某个字段的平均值，例如订单价格的平均值等。</li></ul></li><li><p><code>$min</code>: 获取指定字段的最小值。</p><ul><li>用途：获取某个字段的最小值，例如订单中的最低价格等。</li></ul></li><li><p><code>$max</code>: 获取指定字段的最大值。</p><ul><li>用途：获取某个字段的最大值，例如订单中的最高价格等。</li></ul></li><li><p><code>$first</code>: 获取每个分组中指定字段的首个值。</p><ul><li>用途：获取每个分组中某个字段的首个值，例如获取每个用户的首次购买时间等。</li></ul></li><li><p><code>$last</code>: 获取每个分组中指定字段的最后一个值。</p><ul><li>用途：获取每个分组中某个字段的最后一个值，例如获取每个用户的最后一次购买时间等。</li></ul></li></ol><h1 id="6-关键字"><a href="#6-关键字" class="headerlink" title="6. 关键字"></a>6. 关键字</h1><h1 id="7-排序"><a href="#7-排序" class="headerlink" title="7. 排序"></a>7. 排序</h1><h1 id="8-索引"><a href="#8-索引" class="headerlink" title="8. 索引"></a>8. 索引</h1><h1 id="9-聚合"><a href="#9-聚合" class="headerlink" title="9. 聚合"></a>9. 聚合</h1><h1 id="10-监控、备份、恢复、分片"><a href="#10-监控、备份、恢复、分片" class="headerlink" title="10. 监控、备份、恢复、分片"></a>10. 监控、备份、恢复、分片</h1>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异步编程</title>
    <link href="/2024/02/24/Java%E5%BC%82%E6%AD%A5/"/>
    <url>/2024/02/24/Java%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java异步"><a href="#Java异步" class="headerlink" title="Java异步"></a>Java异步</h1><h2 id="1-CompletableFuture"><a href="#1-CompletableFuture" class="headerlink" title="1. CompletableFuture"></a>1. CompletableFuture</h2><h3 id="1-1-什么是CompletableFuture"><a href="#1-1-什么是CompletableFuture" class="headerlink" title="1.1 什么是CompletableFuture"></a>1.1 什么是CompletableFuture</h3><p>在Java 8中, 新增加了一个包含50个方法左右的类: CompletableFuture，结合了Future的优点，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p><p>CompletableFuture被设计在Java中进行异步编程。异步编程意味着在主线程之外创建一个独立的线程，与主线程分隔开，并在上面运行一个非阻塞的任务，然后通知主线程进展，成功或者失败。</p><p>通过这种方式，你的主线程不用为了任务的完成而阻塞&#x2F;等待，你可以用主线程去并行执行其他的任务。 使用这种并行方式，极大地提升了程序的表现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mark">当一个Future可能需要显示地完成时，使用CompletionStage接口去支持完成时触发的函数和操作。<br>当2个以上线程同时尝试完成、异常完成、取消一个CompletableFuture时，只有一个能成功。<br><br>CompletableFuture实现了CompletionStage接口的如下策略：<br><br>1.为了完成当前的CompletableFuture接口或者其他完成方法的回调函数的线程，提供了非异步的完成操作。<br><br>2.没有显式入参Executor的所有async方法都使用ForkJoinPool.commonPool()为了简化监视、调试和跟踪，<br>    所有生成的异步任务都是标记接口AsynchronousCompletionTask的实例。<br><br>3.所有的CompletionStage方法都是独立于其他共有方法实现的，因此一个方法的行为不会受到子类中其他<br>    方法的覆盖。<br><br>CompletableFuture实现了Futurre接口的如下策略：<br><br>1.CompletableFuture无法直接控制完成，所以cancel操作被视为是另一种异常完成形式。<br>    方法isCompletedExceptionally可以用来确定一个CompletableFuture是否以任何异常的方式完成。<br><br>2.以一个CompletionException为例，方法get()和get(long,TimeUnit)抛出一个ExecutionException，<br>    对应CompletionException。为了在大多数上下文中简化用法，这个类还定义了方法join()和getNow，<br>    而不是直接在这些情况中直接抛出CompletionException。<br></code></pre></td></tr></table></figure><h3 id="1-2-CompletableFuture-API"><a href="#1-2-CompletableFuture-API" class="headerlink" title="1.2 CompletableFuture API"></a>1.2 CompletableFuture API</h3><h4 id="1-2-1-实例化CompletableFuture"><a href="#1-2-1-实例化CompletableFuture" class="headerlink" title="1.2.1 实例化CompletableFuture"></a>1.2.1 实例化CompletableFuture</h4><p>实例化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span>;<br></code></pre></td></tr></table></figure><p>有两种格式，一种是supply开头的方法，一种是run开头的方法</p><ul><li>supply开头：这种方法，可以返回异步线程执行之后的结果</li><li>run开头：这种不会返回结果，就只是执行线程任务</li></ul><p>或者可以通过一个简单的无参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; completableFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>tips</p></blockquote><p>我们注意到，在实例化方法中，我们是可以指定Executor参数的，当我们不指定的话，我们所开的并行线程使用的是默认系统及公共线程池ForkJoinPool，而且这些线程都是守护线程。我们在编程的时候需要谨慎使用守护线程，如果将我们普通的用户线程设置成守护线程，当我们的程序主线程结束，JVM中不存在其余用户线程，那么CompletableFuture的守护线程会直接退出，造成任务无法完成的问题，其余的包括守护线程阻塞问题我就不在本篇赘述。</p><p>Java8实战：</p><p>其中supplyAsync用于有返回值的任务，runAsync则用于没有返回值的任务。Executor参数可以手动指定线程池，否则默认ForkJoinPool.commonPool()系统级公共线程池，注意：这些线程都是Daemon线程，主线程结束Daemon线程不结束，只有JVM关闭时，生命周期终止</p><h3 id="1-3-获取结果"><a href="#1-3-获取结果" class="headerlink" title="1.3 获取结果"></a>1.3 获取结果</h3><p>同步获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">get</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">getNow</span><span class="hljs-params">(T valueIfAbsent)</span><br><span class="hljs-keyword">public</span> T    <span class="hljs-title function_">join</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">CompletableFuture&lt;Integer&gt; future = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> future.get();<br></code></pre></td></tr></table></figure><p><strong>get()</strong> 方法同样会阻塞直到任务完成，上面的代码，主线程会一直阻塞，因为这种方式创建的future从未完成。有兴趣的小伙伴可以打个断点看看，状态会一直是not completed</p><p>前两个方法比较通俗易懂，认真看完上面Future部分的小伙伴肯定知道什么意思。 getNow() 则有所区别，参数valueIfAbsent的意思是当计算结果不存在或者Now时刻没有完成任务，给定一个确定的值。</p><p>join() 与get() 区别在于join() 返回计算的结果或者抛出一个unchecked异常(CompletionException)，而get() 返回一个具体的异常.</p><h3 id="1-4-计算完成后序操作1-complete"><a href="#1-4-计算完成后序操作1-complete" class="headerlink" title="1.4 计算完成后序操作1-complete"></a>1.4 计算完成后序操作1-complete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">whenComplete</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> Throwable&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> Throwable&gt; action)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> Throwable&gt; action, Executor executor)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt;     <span class="hljs-title function_">exceptionally</span><span class="hljs-params">(Function&lt;Throwable,? extends T&gt; fn)</span><br></code></pre></td></tr></table></figure><p>方法1和2的区别在于是否使用异步处理，2和3的区别在于是否使用自定义的线程池，前三个方法都会提供一个返回结果和可抛出异常，我们可以使用lambda表达式的来接收这两个参数，然后自己处理。 方法4，接收一个可抛出的异常，且必须return一个返回值，类型与钻石表达式中的类型一样，详见下文的exceptionally() 部分，更详细</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(<br>    () -&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10086</span>;<br>    &#125;);<br>future.whenComplete(<br>    (result, error) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;拨打&quot;</span>+result);<br>        error.printStackTrace();<br>     &#125;);<br></code></pre></td></tr></table></figure><h3 id="1-5-计算完成后序操作2-handle"><a href="#1-5-计算完成后序操作2-handle" class="headerlink" title="1.5 计算完成后序操作2-handle"></a>1.5 计算完成后序操作2-handle</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
